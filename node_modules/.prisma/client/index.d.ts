
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model CustomerFormField
 * 
 */
export type CustomerFormField = $Result.DefaultSelection<Prisma.$CustomerFormFieldPayload>
/**
 * Model CustomerResponse
 * 
 */
export type CustomerResponse = $Result.DefaultSelection<Prisma.$CustomerResponsePayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model ItemAttributeTemplate
 * 
 */
export type ItemAttributeTemplate = $Result.DefaultSelection<Prisma.$ItemAttributeTemplatePayload>
/**
 * Model ItemCategory
 * 
 */
export type ItemCategory = $Result.DefaultSelection<Prisma.$ItemCategoryPayload>
/**
 * Model ItemImage
 * 
 */
export type ItemImage = $Result.DefaultSelection<Prisma.$ItemImagePayload>
/**
 * Model ItemPrice
 * 
 */
export type ItemPrice = $Result.DefaultSelection<Prisma.$ItemPricePayload>
/**
 * Model ItemType
 * 
 */
export type ItemType = $Result.DefaultSelection<Prisma.$ItemTypePayload>
/**
 * Model ItemUpdateHistory
 * 
 */
export type ItemUpdateHistory = $Result.DefaultSelection<Prisma.$ItemUpdateHistoryPayload>
/**
 * Model ItemVariant
 * 
 */
export type ItemVariant = $Result.DefaultSelection<Prisma.$ItemVariantPayload>
/**
 * Model ItemVideo
 * 
 */
export type ItemVideo = $Result.DefaultSelection<Prisma.$ItemVideoPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserAdmin
 * 
 */
export type UserAdmin = $Result.DefaultSelection<Prisma.$UserAdminPayload>
/**
 * Model UserCustomer
 * 
 */
export type UserCustomer = $Result.DefaultSelection<Prisma.$UserCustomerPayload>
/**
 * Model UserCustomerAddress
 * 
 */
export type UserCustomerAddress = $Result.DefaultSelection<Prisma.$UserCustomerAddressPayload>
/**
 * Model UserMember
 * 
 */
export type UserMember = $Result.DefaultSelection<Prisma.$UserMemberPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const FieldType: {
  TEXT: 'TEXT',
  NUMBER: 'NUMBER',
  OPTION: 'OPTION'
};

export type FieldType = (typeof FieldType)[keyof typeof FieldType]


export const ItemStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  ARCHIVED: 'ARCHIVED',
  SUSPENDED: 'SUSPENDED'
};

export type ItemStatus = (typeof ItemStatus)[keyof typeof ItemStatus]


export const AttributeType: {
  TEXT: 'TEXT',
  NUMBER: 'NUMBER',
  COLOR: 'COLOR'
};

export type AttributeType = (typeof AttributeType)[keyof typeof AttributeType]


export const PriceType: {
  ONCE: 'ONCE',
  WEEKLY: 'WEEKLY',
  DAILY: 'DAILY'
};

export type PriceType = (typeof PriceType)[keyof typeof PriceType]


export const UserRole: {
  OWNER: 'OWNER',
  MANAGER: 'MANAGER',
  STAFF: 'STAFF',
  CUSTOMER: 'CUSTOMER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const MemberTier: {
  BRONZE: 'BRONZE',
  SILVER: 'SILVER',
  GOLD: 'GOLD',
  PLATINUM: 'PLATINUM'
};

export type MemberTier = (typeof MemberTier)[keyof typeof MemberTier]

}

export type FieldType = $Enums.FieldType

export const FieldType: typeof $Enums.FieldType

export type ItemStatus = $Enums.ItemStatus

export const ItemStatus: typeof $Enums.ItemStatus

export type AttributeType = $Enums.AttributeType

export const AttributeType: typeof $Enums.AttributeType

export type PriceType = $Enums.PriceType

export const PriceType: typeof $Enums.PriceType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type MemberTier = $Enums.MemberTier

export const MemberTier: typeof $Enums.MemberTier

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more CustomerFormFields
 * const customerFormFields = await prisma.customerFormField.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more CustomerFormFields
   * const customerFormFields = await prisma.customerFormField.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.customerFormField`: Exposes CRUD operations for the **CustomerFormField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerFormFields
    * const customerFormFields = await prisma.customerFormField.findMany()
    * ```
    */
  get customerFormField(): Prisma.CustomerFormFieldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerResponse`: Exposes CRUD operations for the **CustomerResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerResponses
    * const customerResponses = await prisma.customerResponse.findMany()
    * ```
    */
  get customerResponse(): Prisma.CustomerResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemAttributeTemplate`: Exposes CRUD operations for the **ItemAttributeTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemAttributeTemplates
    * const itemAttributeTemplates = await prisma.itemAttributeTemplate.findMany()
    * ```
    */
  get itemAttributeTemplate(): Prisma.ItemAttributeTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemCategory`: Exposes CRUD operations for the **ItemCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemCategories
    * const itemCategories = await prisma.itemCategory.findMany()
    * ```
    */
  get itemCategory(): Prisma.ItemCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemImage`: Exposes CRUD operations for the **ItemImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemImages
    * const itemImages = await prisma.itemImage.findMany()
    * ```
    */
  get itemImage(): Prisma.ItemImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemPrice`: Exposes CRUD operations for the **ItemPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemPrices
    * const itemPrices = await prisma.itemPrice.findMany()
    * ```
    */
  get itemPrice(): Prisma.ItemPriceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemType`: Exposes CRUD operations for the **ItemType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemTypes
    * const itemTypes = await prisma.itemType.findMany()
    * ```
    */
  get itemType(): Prisma.ItemTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemUpdateHistory`: Exposes CRUD operations for the **ItemUpdateHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemUpdateHistories
    * const itemUpdateHistories = await prisma.itemUpdateHistory.findMany()
    * ```
    */
  get itemUpdateHistory(): Prisma.ItemUpdateHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemVariant`: Exposes CRUD operations for the **ItemVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemVariants
    * const itemVariants = await prisma.itemVariant.findMany()
    * ```
    */
  get itemVariant(): Prisma.ItemVariantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemVideo`: Exposes CRUD operations for the **ItemVideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemVideos
    * const itemVideos = await prisma.itemVideo.findMany()
    * ```
    */
  get itemVideo(): Prisma.ItemVideoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAdmin`: Exposes CRUD operations for the **UserAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAdmins
    * const userAdmins = await prisma.userAdmin.findMany()
    * ```
    */
  get userAdmin(): Prisma.UserAdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userCustomer`: Exposes CRUD operations for the **UserCustomer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCustomers
    * const userCustomers = await prisma.userCustomer.findMany()
    * ```
    */
  get userCustomer(): Prisma.UserCustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userCustomerAddress`: Exposes CRUD operations for the **UserCustomerAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCustomerAddresses
    * const userCustomerAddresses = await prisma.userCustomerAddress.findMany()
    * ```
    */
  get userCustomerAddress(): Prisma.UserCustomerAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userMember`: Exposes CRUD operations for the **UserMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserMembers
    * const userMembers = await prisma.userMember.findMany()
    * ```
    */
  get userMember(): Prisma.UserMemberDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.2.1
   * Query Engine version: 4123509d24aa4dede1e864b46351bf2790323b69
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    CustomerFormField: 'CustomerFormField',
    CustomerResponse: 'CustomerResponse',
    Item: 'Item',
    ItemAttributeTemplate: 'ItemAttributeTemplate',
    ItemCategory: 'ItemCategory',
    ItemImage: 'ItemImage',
    ItemPrice: 'ItemPrice',
    ItemType: 'ItemType',
    ItemUpdateHistory: 'ItemUpdateHistory',
    ItemVariant: 'ItemVariant',
    ItemVideo: 'ItemVideo',
    User: 'User',
    UserAdmin: 'UserAdmin',
    UserCustomer: 'UserCustomer',
    UserCustomerAddress: 'UserCustomerAddress',
    UserMember: 'UserMember'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "customerFormField" | "customerResponse" | "item" | "itemAttributeTemplate" | "itemCategory" | "itemImage" | "itemPrice" | "itemType" | "itemUpdateHistory" | "itemVariant" | "itemVideo" | "user" | "userAdmin" | "userCustomer" | "userCustomerAddress" | "userMember"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      CustomerFormField: {
        payload: Prisma.$CustomerFormFieldPayload<ExtArgs>
        fields: Prisma.CustomerFormFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFormFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFormFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFormFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFormFieldPayload>
          }
          findFirst: {
            args: Prisma.CustomerFormFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFormFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFormFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFormFieldPayload>
          }
          findMany: {
            args: Prisma.CustomerFormFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFormFieldPayload>[]
          }
          create: {
            args: Prisma.CustomerFormFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFormFieldPayload>
          }
          createMany: {
            args: Prisma.CustomerFormFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerFormFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFormFieldPayload>
          }
          update: {
            args: Prisma.CustomerFormFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFormFieldPayload>
          }
          deleteMany: {
            args: Prisma.CustomerFormFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerFormFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerFormFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFormFieldPayload>
          }
          aggregate: {
            args: Prisma.CustomerFormFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerFormField>
          }
          groupBy: {
            args: Prisma.CustomerFormFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerFormFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerFormFieldCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerFormFieldCountAggregateOutputType> | number
          }
        }
      }
      CustomerResponse: {
        payload: Prisma.$CustomerResponsePayload<ExtArgs>
        fields: Prisma.CustomerResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerResponsePayload>
          }
          findFirst: {
            args: Prisma.CustomerResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerResponsePayload>
          }
          findMany: {
            args: Prisma.CustomerResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerResponsePayload>[]
          }
          create: {
            args: Prisma.CustomerResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerResponsePayload>
          }
          createMany: {
            args: Prisma.CustomerResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerResponsePayload>
          }
          update: {
            args: Prisma.CustomerResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerResponsePayload>
          }
          deleteMany: {
            args: Prisma.CustomerResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerResponsePayload>
          }
          aggregate: {
            args: Prisma.CustomerResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerResponse>
          }
          groupBy: {
            args: Prisma.CustomerResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerResponseCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerResponseCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      ItemAttributeTemplate: {
        payload: Prisma.$ItemAttributeTemplatePayload<ExtArgs>
        fields: Prisma.ItemAttributeTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemAttributeTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemAttributeTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemAttributeTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemAttributeTemplatePayload>
          }
          findFirst: {
            args: Prisma.ItemAttributeTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemAttributeTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemAttributeTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemAttributeTemplatePayload>
          }
          findMany: {
            args: Prisma.ItemAttributeTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemAttributeTemplatePayload>[]
          }
          create: {
            args: Prisma.ItemAttributeTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemAttributeTemplatePayload>
          }
          createMany: {
            args: Prisma.ItemAttributeTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ItemAttributeTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemAttributeTemplatePayload>
          }
          update: {
            args: Prisma.ItemAttributeTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemAttributeTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ItemAttributeTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemAttributeTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItemAttributeTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemAttributeTemplatePayload>
          }
          aggregate: {
            args: Prisma.ItemAttributeTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemAttributeTemplate>
          }
          groupBy: {
            args: Prisma.ItemAttributeTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemAttributeTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemAttributeTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ItemAttributeTemplateCountAggregateOutputType> | number
          }
        }
      }
      ItemCategory: {
        payload: Prisma.$ItemCategoryPayload<ExtArgs>
        fields: Prisma.ItemCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          findFirst: {
            args: Prisma.ItemCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          findMany: {
            args: Prisma.ItemCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>[]
          }
          create: {
            args: Prisma.ItemCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          createMany: {
            args: Prisma.ItemCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ItemCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          update: {
            args: Prisma.ItemCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ItemCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItemCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          aggregate: {
            args: Prisma.ItemCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemCategory>
          }
          groupBy: {
            args: Prisma.ItemCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCategoryCountAggregateOutputType> | number
          }
        }
      }
      ItemImage: {
        payload: Prisma.$ItemImagePayload<ExtArgs>
        fields: Prisma.ItemImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemImagePayload>
          }
          findFirst: {
            args: Prisma.ItemImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemImagePayload>
          }
          findMany: {
            args: Prisma.ItemImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemImagePayload>[]
          }
          create: {
            args: Prisma.ItemImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemImagePayload>
          }
          createMany: {
            args: Prisma.ItemImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ItemImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemImagePayload>
          }
          update: {
            args: Prisma.ItemImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemImagePayload>
          }
          deleteMany: {
            args: Prisma.ItemImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItemImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemImagePayload>
          }
          aggregate: {
            args: Prisma.ItemImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemImage>
          }
          groupBy: {
            args: Prisma.ItemImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemImageCountArgs<ExtArgs>
            result: $Utils.Optional<ItemImageCountAggregateOutputType> | number
          }
        }
      }
      ItemPrice: {
        payload: Prisma.$ItemPricePayload<ExtArgs>
        fields: Prisma.ItemPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemPriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemPriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload>
          }
          findFirst: {
            args: Prisma.ItemPriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemPriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload>
          }
          findMany: {
            args: Prisma.ItemPriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload>[]
          }
          create: {
            args: Prisma.ItemPriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload>
          }
          createMany: {
            args: Prisma.ItemPriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ItemPriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload>
          }
          update: {
            args: Prisma.ItemPriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload>
          }
          deleteMany: {
            args: Prisma.ItemPriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemPriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItemPriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload>
          }
          aggregate: {
            args: Prisma.ItemPriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemPrice>
          }
          groupBy: {
            args: Prisma.ItemPriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemPriceCountArgs<ExtArgs>
            result: $Utils.Optional<ItemPriceCountAggregateOutputType> | number
          }
        }
      }
      ItemType: {
        payload: Prisma.$ItemTypePayload<ExtArgs>
        fields: Prisma.ItemTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          findFirst: {
            args: Prisma.ItemTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          findMany: {
            args: Prisma.ItemTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>[]
          }
          create: {
            args: Prisma.ItemTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          createMany: {
            args: Prisma.ItemTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ItemTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          update: {
            args: Prisma.ItemTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          deleteMany: {
            args: Prisma.ItemTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItemTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          aggregate: {
            args: Prisma.ItemTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemType>
          }
          groupBy: {
            args: Prisma.ItemTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ItemTypeCountAggregateOutputType> | number
          }
        }
      }
      ItemUpdateHistory: {
        payload: Prisma.$ItemUpdateHistoryPayload<ExtArgs>
        fields: Prisma.ItemUpdateHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemUpdateHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemUpdateHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemUpdateHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemUpdateHistoryPayload>
          }
          findFirst: {
            args: Prisma.ItemUpdateHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemUpdateHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemUpdateHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemUpdateHistoryPayload>
          }
          findMany: {
            args: Prisma.ItemUpdateHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemUpdateHistoryPayload>[]
          }
          create: {
            args: Prisma.ItemUpdateHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemUpdateHistoryPayload>
          }
          createMany: {
            args: Prisma.ItemUpdateHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ItemUpdateHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemUpdateHistoryPayload>
          }
          update: {
            args: Prisma.ItemUpdateHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemUpdateHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ItemUpdateHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItemUpdateHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemUpdateHistoryPayload>
          }
          aggregate: {
            args: Prisma.ItemUpdateHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemUpdateHistory>
          }
          groupBy: {
            args: Prisma.ItemUpdateHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemUpdateHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemUpdateHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ItemUpdateHistoryCountAggregateOutputType> | number
          }
        }
      }
      ItemVariant: {
        payload: Prisma.$ItemVariantPayload<ExtArgs>
        fields: Prisma.ItemVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemVariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemVariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemVariantPayload>
          }
          findFirst: {
            args: Prisma.ItemVariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemVariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemVariantPayload>
          }
          findMany: {
            args: Prisma.ItemVariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemVariantPayload>[]
          }
          create: {
            args: Prisma.ItemVariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemVariantPayload>
          }
          createMany: {
            args: Prisma.ItemVariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ItemVariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemVariantPayload>
          }
          update: {
            args: Prisma.ItemVariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemVariantPayload>
          }
          deleteMany: {
            args: Prisma.ItemVariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemVariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItemVariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemVariantPayload>
          }
          aggregate: {
            args: Prisma.ItemVariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemVariant>
          }
          groupBy: {
            args: Prisma.ItemVariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemVariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemVariantCountArgs<ExtArgs>
            result: $Utils.Optional<ItemVariantCountAggregateOutputType> | number
          }
        }
      }
      ItemVideo: {
        payload: Prisma.$ItemVideoPayload<ExtArgs>
        fields: Prisma.ItemVideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemVideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemVideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemVideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemVideoPayload>
          }
          findFirst: {
            args: Prisma.ItemVideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemVideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemVideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemVideoPayload>
          }
          findMany: {
            args: Prisma.ItemVideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemVideoPayload>[]
          }
          create: {
            args: Prisma.ItemVideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemVideoPayload>
          }
          createMany: {
            args: Prisma.ItemVideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ItemVideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemVideoPayload>
          }
          update: {
            args: Prisma.ItemVideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemVideoPayload>
          }
          deleteMany: {
            args: Prisma.ItemVideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemVideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItemVideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemVideoPayload>
          }
          aggregate: {
            args: Prisma.ItemVideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemVideo>
          }
          groupBy: {
            args: Prisma.ItemVideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemVideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemVideoCountArgs<ExtArgs>
            result: $Utils.Optional<ItemVideoCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserAdmin: {
        payload: Prisma.$UserAdminPayload<ExtArgs>
        fields: Prisma.UserAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdminPayload>
          }
          findFirst: {
            args: Prisma.UserAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdminPayload>
          }
          findMany: {
            args: Prisma.UserAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdminPayload>[]
          }
          create: {
            args: Prisma.UserAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdminPayload>
          }
          createMany: {
            args: Prisma.UserAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdminPayload>
          }
          update: {
            args: Prisma.UserAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdminPayload>
          }
          deleteMany: {
            args: Prisma.UserAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdminPayload>
          }
          aggregate: {
            args: Prisma.UserAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAdmin>
          }
          groupBy: {
            args: Prisma.UserAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAdminCountArgs<ExtArgs>
            result: $Utils.Optional<UserAdminCountAggregateOutputType> | number
          }
        }
      }
      UserCustomer: {
        payload: Prisma.$UserCustomerPayload<ExtArgs>
        fields: Prisma.UserCustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomerPayload>
          }
          findFirst: {
            args: Prisma.UserCustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomerPayload>
          }
          findMany: {
            args: Prisma.UserCustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomerPayload>[]
          }
          create: {
            args: Prisma.UserCustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomerPayload>
          }
          createMany: {
            args: Prisma.UserCustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserCustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomerPayload>
          }
          update: {
            args: Prisma.UserCustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomerPayload>
          }
          deleteMany: {
            args: Prisma.UserCustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserCustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomerPayload>
          }
          aggregate: {
            args: Prisma.UserCustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCustomer>
          }
          groupBy: {
            args: Prisma.UserCustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCustomerCountArgs<ExtArgs>
            result: $Utils.Optional<UserCustomerCountAggregateOutputType> | number
          }
        }
      }
      UserCustomerAddress: {
        payload: Prisma.$UserCustomerAddressPayload<ExtArgs>
        fields: Prisma.UserCustomerAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCustomerAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomerAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCustomerAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomerAddressPayload>
          }
          findFirst: {
            args: Prisma.UserCustomerAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomerAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCustomerAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomerAddressPayload>
          }
          findMany: {
            args: Prisma.UserCustomerAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomerAddressPayload>[]
          }
          create: {
            args: Prisma.UserCustomerAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomerAddressPayload>
          }
          createMany: {
            args: Prisma.UserCustomerAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserCustomerAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomerAddressPayload>
          }
          update: {
            args: Prisma.UserCustomerAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomerAddressPayload>
          }
          deleteMany: {
            args: Prisma.UserCustomerAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCustomerAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserCustomerAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomerAddressPayload>
          }
          aggregate: {
            args: Prisma.UserCustomerAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCustomerAddress>
          }
          groupBy: {
            args: Prisma.UserCustomerAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCustomerAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCustomerAddressCountArgs<ExtArgs>
            result: $Utils.Optional<UserCustomerAddressCountAggregateOutputType> | number
          }
        }
      }
      UserMember: {
        payload: Prisma.$UserMemberPayload<ExtArgs>
        fields: Prisma.UserMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMemberPayload>
          }
          findFirst: {
            args: Prisma.UserMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMemberPayload>
          }
          findMany: {
            args: Prisma.UserMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMemberPayload>[]
          }
          create: {
            args: Prisma.UserMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMemberPayload>
          }
          createMany: {
            args: Prisma.UserMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMemberPayload>
          }
          update: {
            args: Prisma.UserMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMemberPayload>
          }
          deleteMany: {
            args: Prisma.UserMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMemberPayload>
          }
          aggregate: {
            args: Prisma.UserMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserMember>
          }
          groupBy: {
            args: Prisma.UserMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserMemberCountArgs<ExtArgs>
            result: $Utils.Optional<UserMemberCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    customerFormField?: CustomerFormFieldOmit
    customerResponse?: CustomerResponseOmit
    item?: ItemOmit
    itemAttributeTemplate?: ItemAttributeTemplateOmit
    itemCategory?: ItemCategoryOmit
    itemImage?: ItemImageOmit
    itemPrice?: ItemPriceOmit
    itemType?: ItemTypeOmit
    itemUpdateHistory?: ItemUpdateHistoryOmit
    itemVariant?: ItemVariantOmit
    itemVideo?: ItemVideoOmit
    user?: UserOmit
    userAdmin?: UserAdminOmit
    userCustomer?: UserCustomerOmit
    userCustomerAddress?: UserCustomerAddressOmit
    userMember?: UserMemberOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomerFormFieldCountOutputType
   */

  export type CustomerFormFieldCountOutputType = {
    responses: number
  }

  export type CustomerFormFieldCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | CustomerFormFieldCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * CustomerFormFieldCountOutputType without action
   */
  export type CustomerFormFieldCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFormFieldCountOutputType
     */
    select?: CustomerFormFieldCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerFormFieldCountOutputType without action
   */
  export type CustomerFormFieldCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerResponseWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    variants: number
    images: number
    videos: number
    updateHistories: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | ItemCountOutputTypeCountVariantsArgs
    images?: boolean | ItemCountOutputTypeCountImagesArgs
    videos?: boolean | ItemCountOutputTypeCountVideosArgs
    updateHistories?: boolean | ItemCountOutputTypeCountUpdateHistoriesArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemVariantWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemImageWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemVideoWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountUpdateHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemUpdateHistoryWhereInput
  }


  /**
   * Count Type ItemCategoryCountOutputType
   */

  export type ItemCategoryCountOutputType = {
    children: number
    items: number
    attributeTemplates: number
  }

  export type ItemCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ItemCategoryCountOutputTypeCountChildrenArgs
    items?: boolean | ItemCategoryCountOutputTypeCountItemsArgs
    attributeTemplates?: boolean | ItemCategoryCountOutputTypeCountAttributeTemplatesArgs
  }

  // Custom InputTypes
  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCountOutputType
     */
    select?: ItemCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCategoryWhereInput
  }

  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }

  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeCountAttributeTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemAttributeTemplateWhereInput
  }


  /**
   * Count Type ItemTypeCountOutputType
   */

  export type ItemTypeCountOutputType = {
    items: number
  }

  export type ItemTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ItemTypeCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * ItemTypeCountOutputType without action
   */
  export type ItemTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTypeCountOutputType
     */
    select?: ItemTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemTypeCountOutputType without action
   */
  export type ItemTypeCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }


  /**
   * Count Type ItemVariantCountOutputType
   */

  export type ItemVariantCountOutputType = {
    prices: number
  }

  export type ItemVariantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prices?: boolean | ItemVariantCountOutputTypeCountPricesArgs
  }

  // Custom InputTypes
  /**
   * ItemVariantCountOutputType without action
   */
  export type ItemVariantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVariantCountOutputType
     */
    select?: ItemVariantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemVariantCountOutputType without action
   */
  export type ItemVariantCountOutputTypeCountPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemPriceWhereInput
  }


  /**
   * Count Type UserCustomerCountOutputType
   */

  export type UserCustomerCountOutputType = {
    addresses: number
    responses: number
  }

  export type UserCustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addresses?: boolean | UserCustomerCountOutputTypeCountAddressesArgs
    responses?: boolean | UserCustomerCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * UserCustomerCountOutputType without action
   */
  export type UserCustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomerCountOutputType
     */
    select?: UserCustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCustomerCountOutputType without action
   */
  export type UserCustomerCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCustomerAddressWhereInput
  }

  /**
   * UserCustomerCountOutputType without action
   */
  export type UserCustomerCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerResponseWhereInput
  }


  /**
   * Models
   */

  /**
   * Model CustomerFormField
   */

  export type AggregateCustomerFormField = {
    _count: CustomerFormFieldCountAggregateOutputType | null
    _avg: CustomerFormFieldAvgAggregateOutputType | null
    _sum: CustomerFormFieldSumAggregateOutputType | null
    _min: CustomerFormFieldMinAggregateOutputType | null
    _max: CustomerFormFieldMaxAggregateOutputType | null
  }

  export type CustomerFormFieldAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomerFormFieldSumAggregateOutputType = {
    id: number | null
  }

  export type CustomerFormFieldMinAggregateOutputType = {
    id: number | null
    label: string | null
    fieldKey: string | null
    type: $Enums.FieldType | null
    isRequired: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerFormFieldMaxAggregateOutputType = {
    id: number | null
    label: string | null
    fieldKey: string | null
    type: $Enums.FieldType | null
    isRequired: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerFormFieldCountAggregateOutputType = {
    id: number
    label: number
    fieldKey: number
    type: number
    options: number
    isRequired: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerFormFieldAvgAggregateInputType = {
    id?: true
  }

  export type CustomerFormFieldSumAggregateInputType = {
    id?: true
  }

  export type CustomerFormFieldMinAggregateInputType = {
    id?: true
    label?: true
    fieldKey?: true
    type?: true
    isRequired?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerFormFieldMaxAggregateInputType = {
    id?: true
    label?: true
    fieldKey?: true
    type?: true
    isRequired?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerFormFieldCountAggregateInputType = {
    id?: true
    label?: true
    fieldKey?: true
    type?: true
    options?: true
    isRequired?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerFormFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerFormField to aggregate.
     */
    where?: CustomerFormFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerFormFields to fetch.
     */
    orderBy?: CustomerFormFieldOrderByWithRelationInput | CustomerFormFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerFormFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerFormFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerFormFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerFormFields
    **/
    _count?: true | CustomerFormFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerFormFieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerFormFieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerFormFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerFormFieldMaxAggregateInputType
  }

  export type GetCustomerFormFieldAggregateType<T extends CustomerFormFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerFormField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerFormField[P]>
      : GetScalarType<T[P], AggregateCustomerFormField[P]>
  }




  export type CustomerFormFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerFormFieldWhereInput
    orderBy?: CustomerFormFieldOrderByWithAggregationInput | CustomerFormFieldOrderByWithAggregationInput[]
    by: CustomerFormFieldScalarFieldEnum[] | CustomerFormFieldScalarFieldEnum
    having?: CustomerFormFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerFormFieldCountAggregateInputType | true
    _avg?: CustomerFormFieldAvgAggregateInputType
    _sum?: CustomerFormFieldSumAggregateInputType
    _min?: CustomerFormFieldMinAggregateInputType
    _max?: CustomerFormFieldMaxAggregateInputType
  }

  export type CustomerFormFieldGroupByOutputType = {
    id: number
    label: string
    fieldKey: string
    type: $Enums.FieldType
    options: JsonValue | null
    isRequired: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerFormFieldCountAggregateOutputType | null
    _avg: CustomerFormFieldAvgAggregateOutputType | null
    _sum: CustomerFormFieldSumAggregateOutputType | null
    _min: CustomerFormFieldMinAggregateOutputType | null
    _max: CustomerFormFieldMaxAggregateOutputType | null
  }

  type GetCustomerFormFieldGroupByPayload<T extends CustomerFormFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerFormFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerFormFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerFormFieldGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerFormFieldGroupByOutputType[P]>
        }
      >
    >


  export type CustomerFormFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    fieldKey?: boolean
    type?: boolean
    options?: boolean
    isRequired?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    responses?: boolean | CustomerFormField$responsesArgs<ExtArgs>
    _count?: boolean | CustomerFormFieldCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerFormField"]>



  export type CustomerFormFieldSelectScalar = {
    id?: boolean
    label?: boolean
    fieldKey?: boolean
    type?: boolean
    options?: boolean
    isRequired?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerFormFieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "fieldKey" | "type" | "options" | "isRequired" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["customerFormField"]>
  export type CustomerFormFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | CustomerFormField$responsesArgs<ExtArgs>
    _count?: boolean | CustomerFormFieldCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomerFormFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerFormField"
    objects: {
      responses: Prisma.$CustomerResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      label: string
      fieldKey: string
      type: $Enums.FieldType
      options: Prisma.JsonValue | null
      isRequired: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerFormField"]>
    composites: {}
  }

  type CustomerFormFieldGetPayload<S extends boolean | null | undefined | CustomerFormFieldDefaultArgs> = $Result.GetResult<Prisma.$CustomerFormFieldPayload, S>

  type CustomerFormFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFormFieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerFormFieldCountAggregateInputType | true
    }

  export interface CustomerFormFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerFormField'], meta: { name: 'CustomerFormField' } }
    /**
     * Find zero or one CustomerFormField that matches the filter.
     * @param {CustomerFormFieldFindUniqueArgs} args - Arguments to find a CustomerFormField
     * @example
     * // Get one CustomerFormField
     * const customerFormField = await prisma.customerFormField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFormFieldFindUniqueArgs>(args: SelectSubset<T, CustomerFormFieldFindUniqueArgs<ExtArgs>>): Prisma__CustomerFormFieldClient<$Result.GetResult<Prisma.$CustomerFormFieldPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CustomerFormField that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFormFieldFindUniqueOrThrowArgs} args - Arguments to find a CustomerFormField
     * @example
     * // Get one CustomerFormField
     * const customerFormField = await prisma.customerFormField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFormFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFormFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerFormFieldClient<$Result.GetResult<Prisma.$CustomerFormFieldPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CustomerFormField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFormFieldFindFirstArgs} args - Arguments to find a CustomerFormField
     * @example
     * // Get one CustomerFormField
     * const customerFormField = await prisma.customerFormField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFormFieldFindFirstArgs>(args?: SelectSubset<T, CustomerFormFieldFindFirstArgs<ExtArgs>>): Prisma__CustomerFormFieldClient<$Result.GetResult<Prisma.$CustomerFormFieldPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CustomerFormField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFormFieldFindFirstOrThrowArgs} args - Arguments to find a CustomerFormField
     * @example
     * // Get one CustomerFormField
     * const customerFormField = await prisma.customerFormField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFormFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFormFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerFormFieldClient<$Result.GetResult<Prisma.$CustomerFormFieldPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CustomerFormFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFormFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerFormFields
     * const customerFormFields = await prisma.customerFormField.findMany()
     * 
     * // Get first 10 CustomerFormFields
     * const customerFormFields = await prisma.customerFormField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerFormFieldWithIdOnly = await prisma.customerFormField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFormFieldFindManyArgs>(args?: SelectSubset<T, CustomerFormFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerFormFieldPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CustomerFormField.
     * @param {CustomerFormFieldCreateArgs} args - Arguments to create a CustomerFormField.
     * @example
     * // Create one CustomerFormField
     * const CustomerFormField = await prisma.customerFormField.create({
     *   data: {
     *     // ... data to create a CustomerFormField
     *   }
     * })
     * 
     */
    create<T extends CustomerFormFieldCreateArgs>(args: SelectSubset<T, CustomerFormFieldCreateArgs<ExtArgs>>): Prisma__CustomerFormFieldClient<$Result.GetResult<Prisma.$CustomerFormFieldPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CustomerFormFields.
     * @param {CustomerFormFieldCreateManyArgs} args - Arguments to create many CustomerFormFields.
     * @example
     * // Create many CustomerFormFields
     * const customerFormField = await prisma.customerFormField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerFormFieldCreateManyArgs>(args?: SelectSubset<T, CustomerFormFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerFormField.
     * @param {CustomerFormFieldDeleteArgs} args - Arguments to delete one CustomerFormField.
     * @example
     * // Delete one CustomerFormField
     * const CustomerFormField = await prisma.customerFormField.delete({
     *   where: {
     *     // ... filter to delete one CustomerFormField
     *   }
     * })
     * 
     */
    delete<T extends CustomerFormFieldDeleteArgs>(args: SelectSubset<T, CustomerFormFieldDeleteArgs<ExtArgs>>): Prisma__CustomerFormFieldClient<$Result.GetResult<Prisma.$CustomerFormFieldPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CustomerFormField.
     * @param {CustomerFormFieldUpdateArgs} args - Arguments to update one CustomerFormField.
     * @example
     * // Update one CustomerFormField
     * const customerFormField = await prisma.customerFormField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerFormFieldUpdateArgs>(args: SelectSubset<T, CustomerFormFieldUpdateArgs<ExtArgs>>): Prisma__CustomerFormFieldClient<$Result.GetResult<Prisma.$CustomerFormFieldPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CustomerFormFields.
     * @param {CustomerFormFieldDeleteManyArgs} args - Arguments to filter CustomerFormFields to delete.
     * @example
     * // Delete a few CustomerFormFields
     * const { count } = await prisma.customerFormField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerFormFieldDeleteManyArgs>(args?: SelectSubset<T, CustomerFormFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerFormFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFormFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerFormFields
     * const customerFormField = await prisma.customerFormField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerFormFieldUpdateManyArgs>(args: SelectSubset<T, CustomerFormFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerFormField.
     * @param {CustomerFormFieldUpsertArgs} args - Arguments to update or create a CustomerFormField.
     * @example
     * // Update or create a CustomerFormField
     * const customerFormField = await prisma.customerFormField.upsert({
     *   create: {
     *     // ... data to create a CustomerFormField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerFormField we want to update
     *   }
     * })
     */
    upsert<T extends CustomerFormFieldUpsertArgs>(args: SelectSubset<T, CustomerFormFieldUpsertArgs<ExtArgs>>): Prisma__CustomerFormFieldClient<$Result.GetResult<Prisma.$CustomerFormFieldPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CustomerFormFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFormFieldCountArgs} args - Arguments to filter CustomerFormFields to count.
     * @example
     * // Count the number of CustomerFormFields
     * const count = await prisma.customerFormField.count({
     *   where: {
     *     // ... the filter for the CustomerFormFields we want to count
     *   }
     * })
    **/
    count<T extends CustomerFormFieldCountArgs>(
      args?: Subset<T, CustomerFormFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerFormFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerFormField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFormFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerFormFieldAggregateArgs>(args: Subset<T, CustomerFormFieldAggregateArgs>): Prisma.PrismaPromise<GetCustomerFormFieldAggregateType<T>>

    /**
     * Group by CustomerFormField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFormFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerFormFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerFormFieldGroupByArgs['orderBy'] }
        : { orderBy?: CustomerFormFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerFormFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerFormFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerFormField model
   */
  readonly fields: CustomerFormFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerFormField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerFormFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    responses<T extends CustomerFormField$responsesArgs<ExtArgs> = {}>(args?: Subset<T, CustomerFormField$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerResponsePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerFormField model
   */ 
  interface CustomerFormFieldFieldRefs {
    readonly id: FieldRef<"CustomerFormField", 'Int'>
    readonly label: FieldRef<"CustomerFormField", 'String'>
    readonly fieldKey: FieldRef<"CustomerFormField", 'String'>
    readonly type: FieldRef<"CustomerFormField", 'FieldType'>
    readonly options: FieldRef<"CustomerFormField", 'Json'>
    readonly isRequired: FieldRef<"CustomerFormField", 'Boolean'>
    readonly isActive: FieldRef<"CustomerFormField", 'Boolean'>
    readonly createdAt: FieldRef<"CustomerFormField", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerFormField", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerFormField findUnique
   */
  export type CustomerFormFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFormField
     */
    select?: CustomerFormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFormField
     */
    omit?: CustomerFormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFormFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomerFormField to fetch.
     */
    where: CustomerFormFieldWhereUniqueInput
  }

  /**
   * CustomerFormField findUniqueOrThrow
   */
  export type CustomerFormFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFormField
     */
    select?: CustomerFormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFormField
     */
    omit?: CustomerFormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFormFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomerFormField to fetch.
     */
    where: CustomerFormFieldWhereUniqueInput
  }

  /**
   * CustomerFormField findFirst
   */
  export type CustomerFormFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFormField
     */
    select?: CustomerFormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFormField
     */
    omit?: CustomerFormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFormFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomerFormField to fetch.
     */
    where?: CustomerFormFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerFormFields to fetch.
     */
    orderBy?: CustomerFormFieldOrderByWithRelationInput | CustomerFormFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerFormFields.
     */
    cursor?: CustomerFormFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerFormFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerFormFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerFormFields.
     */
    distinct?: CustomerFormFieldScalarFieldEnum | CustomerFormFieldScalarFieldEnum[]
  }

  /**
   * CustomerFormField findFirstOrThrow
   */
  export type CustomerFormFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFormField
     */
    select?: CustomerFormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFormField
     */
    omit?: CustomerFormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFormFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomerFormField to fetch.
     */
    where?: CustomerFormFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerFormFields to fetch.
     */
    orderBy?: CustomerFormFieldOrderByWithRelationInput | CustomerFormFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerFormFields.
     */
    cursor?: CustomerFormFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerFormFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerFormFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerFormFields.
     */
    distinct?: CustomerFormFieldScalarFieldEnum | CustomerFormFieldScalarFieldEnum[]
  }

  /**
   * CustomerFormField findMany
   */
  export type CustomerFormFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFormField
     */
    select?: CustomerFormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFormField
     */
    omit?: CustomerFormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFormFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomerFormFields to fetch.
     */
    where?: CustomerFormFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerFormFields to fetch.
     */
    orderBy?: CustomerFormFieldOrderByWithRelationInput | CustomerFormFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerFormFields.
     */
    cursor?: CustomerFormFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerFormFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerFormFields.
     */
    skip?: number
    distinct?: CustomerFormFieldScalarFieldEnum | CustomerFormFieldScalarFieldEnum[]
  }

  /**
   * CustomerFormField create
   */
  export type CustomerFormFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFormField
     */
    select?: CustomerFormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFormField
     */
    omit?: CustomerFormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFormFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerFormField.
     */
    data: XOR<CustomerFormFieldCreateInput, CustomerFormFieldUncheckedCreateInput>
  }

  /**
   * CustomerFormField createMany
   */
  export type CustomerFormFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerFormFields.
     */
    data: CustomerFormFieldCreateManyInput | CustomerFormFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerFormField update
   */
  export type CustomerFormFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFormField
     */
    select?: CustomerFormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFormField
     */
    omit?: CustomerFormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFormFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerFormField.
     */
    data: XOR<CustomerFormFieldUpdateInput, CustomerFormFieldUncheckedUpdateInput>
    /**
     * Choose, which CustomerFormField to update.
     */
    where: CustomerFormFieldWhereUniqueInput
  }

  /**
   * CustomerFormField updateMany
   */
  export type CustomerFormFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerFormFields.
     */
    data: XOR<CustomerFormFieldUpdateManyMutationInput, CustomerFormFieldUncheckedUpdateManyInput>
    /**
     * Filter which CustomerFormFields to update
     */
    where?: CustomerFormFieldWhereInput
  }

  /**
   * CustomerFormField upsert
   */
  export type CustomerFormFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFormField
     */
    select?: CustomerFormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFormField
     */
    omit?: CustomerFormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFormFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerFormField to update in case it exists.
     */
    where: CustomerFormFieldWhereUniqueInput
    /**
     * In case the CustomerFormField found by the `where` argument doesn't exist, create a new CustomerFormField with this data.
     */
    create: XOR<CustomerFormFieldCreateInput, CustomerFormFieldUncheckedCreateInput>
    /**
     * In case the CustomerFormField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerFormFieldUpdateInput, CustomerFormFieldUncheckedUpdateInput>
  }

  /**
   * CustomerFormField delete
   */
  export type CustomerFormFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFormField
     */
    select?: CustomerFormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFormField
     */
    omit?: CustomerFormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFormFieldInclude<ExtArgs> | null
    /**
     * Filter which CustomerFormField to delete.
     */
    where: CustomerFormFieldWhereUniqueInput
  }

  /**
   * CustomerFormField deleteMany
   */
  export type CustomerFormFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerFormFields to delete
     */
    where?: CustomerFormFieldWhereInput
  }

  /**
   * CustomerFormField.responses
   */
  export type CustomerFormField$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerResponse
     */
    select?: CustomerResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerResponse
     */
    omit?: CustomerResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerResponseInclude<ExtArgs> | null
    where?: CustomerResponseWhereInput
    orderBy?: CustomerResponseOrderByWithRelationInput | CustomerResponseOrderByWithRelationInput[]
    cursor?: CustomerResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerResponseScalarFieldEnum | CustomerResponseScalarFieldEnum[]
  }

  /**
   * CustomerFormField without action
   */
  export type CustomerFormFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFormField
     */
    select?: CustomerFormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFormField
     */
    omit?: CustomerFormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFormFieldInclude<ExtArgs> | null
  }


  /**
   * Model CustomerResponse
   */

  export type AggregateCustomerResponse = {
    _count: CustomerResponseCountAggregateOutputType | null
    _avg: CustomerResponseAvgAggregateOutputType | null
    _sum: CustomerResponseSumAggregateOutputType | null
    _min: CustomerResponseMinAggregateOutputType | null
    _max: CustomerResponseMaxAggregateOutputType | null
  }

  export type CustomerResponseAvgAggregateOutputType = {
    id: number | null
    userCustomerId: number | null
    fieldId: number | null
  }

  export type CustomerResponseSumAggregateOutputType = {
    id: number | null
    userCustomerId: number | null
    fieldId: number | null
  }

  export type CustomerResponseMinAggregateOutputType = {
    id: number | null
    userCustomerId: number | null
    fieldId: number | null
    answer: string | null
    createdAt: Date | null
  }

  export type CustomerResponseMaxAggregateOutputType = {
    id: number | null
    userCustomerId: number | null
    fieldId: number | null
    answer: string | null
    createdAt: Date | null
  }

  export type CustomerResponseCountAggregateOutputType = {
    id: number
    userCustomerId: number
    fieldId: number
    answer: number
    createdAt: number
    _all: number
  }


  export type CustomerResponseAvgAggregateInputType = {
    id?: true
    userCustomerId?: true
    fieldId?: true
  }

  export type CustomerResponseSumAggregateInputType = {
    id?: true
    userCustomerId?: true
    fieldId?: true
  }

  export type CustomerResponseMinAggregateInputType = {
    id?: true
    userCustomerId?: true
    fieldId?: true
    answer?: true
    createdAt?: true
  }

  export type CustomerResponseMaxAggregateInputType = {
    id?: true
    userCustomerId?: true
    fieldId?: true
    answer?: true
    createdAt?: true
  }

  export type CustomerResponseCountAggregateInputType = {
    id?: true
    userCustomerId?: true
    fieldId?: true
    answer?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerResponse to aggregate.
     */
    where?: CustomerResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerResponses to fetch.
     */
    orderBy?: CustomerResponseOrderByWithRelationInput | CustomerResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerResponses
    **/
    _count?: true | CustomerResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerResponseMaxAggregateInputType
  }

  export type GetCustomerResponseAggregateType<T extends CustomerResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerResponse[P]>
      : GetScalarType<T[P], AggregateCustomerResponse[P]>
  }




  export type CustomerResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerResponseWhereInput
    orderBy?: CustomerResponseOrderByWithAggregationInput | CustomerResponseOrderByWithAggregationInput[]
    by: CustomerResponseScalarFieldEnum[] | CustomerResponseScalarFieldEnum
    having?: CustomerResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerResponseCountAggregateInputType | true
    _avg?: CustomerResponseAvgAggregateInputType
    _sum?: CustomerResponseSumAggregateInputType
    _min?: CustomerResponseMinAggregateInputType
    _max?: CustomerResponseMaxAggregateInputType
  }

  export type CustomerResponseGroupByOutputType = {
    id: number
    userCustomerId: number
    fieldId: number
    answer: string
    createdAt: Date
    _count: CustomerResponseCountAggregateOutputType | null
    _avg: CustomerResponseAvgAggregateOutputType | null
    _sum: CustomerResponseSumAggregateOutputType | null
    _min: CustomerResponseMinAggregateOutputType | null
    _max: CustomerResponseMaxAggregateOutputType | null
  }

  type GetCustomerResponseGroupByPayload<T extends CustomerResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerResponseGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerResponseGroupByOutputType[P]>
        }
      >
    >


  export type CustomerResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userCustomerId?: boolean
    fieldId?: boolean
    answer?: boolean
    createdAt?: boolean
    customer?: boolean | UserCustomerDefaultArgs<ExtArgs>
    field?: boolean | CustomerFormFieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerResponse"]>



  export type CustomerResponseSelectScalar = {
    id?: boolean
    userCustomerId?: boolean
    fieldId?: boolean
    answer?: boolean
    createdAt?: boolean
  }

  export type CustomerResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userCustomerId" | "fieldId" | "answer" | "createdAt", ExtArgs["result"]["customerResponse"]>
  export type CustomerResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserCustomerDefaultArgs<ExtArgs>
    field?: boolean | CustomerFormFieldDefaultArgs<ExtArgs>
  }

  export type $CustomerResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerResponse"
    objects: {
      customer: Prisma.$UserCustomerPayload<ExtArgs>
      field: Prisma.$CustomerFormFieldPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userCustomerId: number
      fieldId: number
      answer: string
      createdAt: Date
    }, ExtArgs["result"]["customerResponse"]>
    composites: {}
  }

  type CustomerResponseGetPayload<S extends boolean | null | undefined | CustomerResponseDefaultArgs> = $Result.GetResult<Prisma.$CustomerResponsePayload, S>

  type CustomerResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerResponseCountAggregateInputType | true
    }

  export interface CustomerResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerResponse'], meta: { name: 'CustomerResponse' } }
    /**
     * Find zero or one CustomerResponse that matches the filter.
     * @param {CustomerResponseFindUniqueArgs} args - Arguments to find a CustomerResponse
     * @example
     * // Get one CustomerResponse
     * const customerResponse = await prisma.customerResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerResponseFindUniqueArgs>(args: SelectSubset<T, CustomerResponseFindUniqueArgs<ExtArgs>>): Prisma__CustomerResponseClient<$Result.GetResult<Prisma.$CustomerResponsePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CustomerResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerResponseFindUniqueOrThrowArgs} args - Arguments to find a CustomerResponse
     * @example
     * // Get one CustomerResponse
     * const customerResponse = await prisma.customerResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerResponseClient<$Result.GetResult<Prisma.$CustomerResponsePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CustomerResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerResponseFindFirstArgs} args - Arguments to find a CustomerResponse
     * @example
     * // Get one CustomerResponse
     * const customerResponse = await prisma.customerResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerResponseFindFirstArgs>(args?: SelectSubset<T, CustomerResponseFindFirstArgs<ExtArgs>>): Prisma__CustomerResponseClient<$Result.GetResult<Prisma.$CustomerResponsePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CustomerResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerResponseFindFirstOrThrowArgs} args - Arguments to find a CustomerResponse
     * @example
     * // Get one CustomerResponse
     * const customerResponse = await prisma.customerResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerResponseClient<$Result.GetResult<Prisma.$CustomerResponsePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CustomerResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerResponses
     * const customerResponses = await prisma.customerResponse.findMany()
     * 
     * // Get first 10 CustomerResponses
     * const customerResponses = await prisma.customerResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerResponseWithIdOnly = await prisma.customerResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerResponseFindManyArgs>(args?: SelectSubset<T, CustomerResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerResponsePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CustomerResponse.
     * @param {CustomerResponseCreateArgs} args - Arguments to create a CustomerResponse.
     * @example
     * // Create one CustomerResponse
     * const CustomerResponse = await prisma.customerResponse.create({
     *   data: {
     *     // ... data to create a CustomerResponse
     *   }
     * })
     * 
     */
    create<T extends CustomerResponseCreateArgs>(args: SelectSubset<T, CustomerResponseCreateArgs<ExtArgs>>): Prisma__CustomerResponseClient<$Result.GetResult<Prisma.$CustomerResponsePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CustomerResponses.
     * @param {CustomerResponseCreateManyArgs} args - Arguments to create many CustomerResponses.
     * @example
     * // Create many CustomerResponses
     * const customerResponse = await prisma.customerResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerResponseCreateManyArgs>(args?: SelectSubset<T, CustomerResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerResponse.
     * @param {CustomerResponseDeleteArgs} args - Arguments to delete one CustomerResponse.
     * @example
     * // Delete one CustomerResponse
     * const CustomerResponse = await prisma.customerResponse.delete({
     *   where: {
     *     // ... filter to delete one CustomerResponse
     *   }
     * })
     * 
     */
    delete<T extends CustomerResponseDeleteArgs>(args: SelectSubset<T, CustomerResponseDeleteArgs<ExtArgs>>): Prisma__CustomerResponseClient<$Result.GetResult<Prisma.$CustomerResponsePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CustomerResponse.
     * @param {CustomerResponseUpdateArgs} args - Arguments to update one CustomerResponse.
     * @example
     * // Update one CustomerResponse
     * const customerResponse = await prisma.customerResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerResponseUpdateArgs>(args: SelectSubset<T, CustomerResponseUpdateArgs<ExtArgs>>): Prisma__CustomerResponseClient<$Result.GetResult<Prisma.$CustomerResponsePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CustomerResponses.
     * @param {CustomerResponseDeleteManyArgs} args - Arguments to filter CustomerResponses to delete.
     * @example
     * // Delete a few CustomerResponses
     * const { count } = await prisma.customerResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerResponseDeleteManyArgs>(args?: SelectSubset<T, CustomerResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerResponses
     * const customerResponse = await prisma.customerResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerResponseUpdateManyArgs>(args: SelectSubset<T, CustomerResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerResponse.
     * @param {CustomerResponseUpsertArgs} args - Arguments to update or create a CustomerResponse.
     * @example
     * // Update or create a CustomerResponse
     * const customerResponse = await prisma.customerResponse.upsert({
     *   create: {
     *     // ... data to create a CustomerResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerResponse we want to update
     *   }
     * })
     */
    upsert<T extends CustomerResponseUpsertArgs>(args: SelectSubset<T, CustomerResponseUpsertArgs<ExtArgs>>): Prisma__CustomerResponseClient<$Result.GetResult<Prisma.$CustomerResponsePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CustomerResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerResponseCountArgs} args - Arguments to filter CustomerResponses to count.
     * @example
     * // Count the number of CustomerResponses
     * const count = await prisma.customerResponse.count({
     *   where: {
     *     // ... the filter for the CustomerResponses we want to count
     *   }
     * })
    **/
    count<T extends CustomerResponseCountArgs>(
      args?: Subset<T, CustomerResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerResponseAggregateArgs>(args: Subset<T, CustomerResponseAggregateArgs>): Prisma.PrismaPromise<GetCustomerResponseAggregateType<T>>

    /**
     * Group by CustomerResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerResponseGroupByArgs['orderBy'] }
        : { orderBy?: CustomerResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerResponse model
   */
  readonly fields: CustomerResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserCustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserCustomerDefaultArgs<ExtArgs>>): Prisma__UserCustomerClient<$Result.GetResult<Prisma.$UserCustomerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    field<T extends CustomerFormFieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerFormFieldDefaultArgs<ExtArgs>>): Prisma__CustomerFormFieldClient<$Result.GetResult<Prisma.$CustomerFormFieldPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerResponse model
   */ 
  interface CustomerResponseFieldRefs {
    readonly id: FieldRef<"CustomerResponse", 'Int'>
    readonly userCustomerId: FieldRef<"CustomerResponse", 'Int'>
    readonly fieldId: FieldRef<"CustomerResponse", 'Int'>
    readonly answer: FieldRef<"CustomerResponse", 'String'>
    readonly createdAt: FieldRef<"CustomerResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerResponse findUnique
   */
  export type CustomerResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerResponse
     */
    select?: CustomerResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerResponse
     */
    omit?: CustomerResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerResponseInclude<ExtArgs> | null
    /**
     * Filter, which CustomerResponse to fetch.
     */
    where: CustomerResponseWhereUniqueInput
  }

  /**
   * CustomerResponse findUniqueOrThrow
   */
  export type CustomerResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerResponse
     */
    select?: CustomerResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerResponse
     */
    omit?: CustomerResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerResponseInclude<ExtArgs> | null
    /**
     * Filter, which CustomerResponse to fetch.
     */
    where: CustomerResponseWhereUniqueInput
  }

  /**
   * CustomerResponse findFirst
   */
  export type CustomerResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerResponse
     */
    select?: CustomerResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerResponse
     */
    omit?: CustomerResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerResponseInclude<ExtArgs> | null
    /**
     * Filter, which CustomerResponse to fetch.
     */
    where?: CustomerResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerResponses to fetch.
     */
    orderBy?: CustomerResponseOrderByWithRelationInput | CustomerResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerResponses.
     */
    cursor?: CustomerResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerResponses.
     */
    distinct?: CustomerResponseScalarFieldEnum | CustomerResponseScalarFieldEnum[]
  }

  /**
   * CustomerResponse findFirstOrThrow
   */
  export type CustomerResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerResponse
     */
    select?: CustomerResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerResponse
     */
    omit?: CustomerResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerResponseInclude<ExtArgs> | null
    /**
     * Filter, which CustomerResponse to fetch.
     */
    where?: CustomerResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerResponses to fetch.
     */
    orderBy?: CustomerResponseOrderByWithRelationInput | CustomerResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerResponses.
     */
    cursor?: CustomerResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerResponses.
     */
    distinct?: CustomerResponseScalarFieldEnum | CustomerResponseScalarFieldEnum[]
  }

  /**
   * CustomerResponse findMany
   */
  export type CustomerResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerResponse
     */
    select?: CustomerResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerResponse
     */
    omit?: CustomerResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerResponseInclude<ExtArgs> | null
    /**
     * Filter, which CustomerResponses to fetch.
     */
    where?: CustomerResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerResponses to fetch.
     */
    orderBy?: CustomerResponseOrderByWithRelationInput | CustomerResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerResponses.
     */
    cursor?: CustomerResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerResponses.
     */
    skip?: number
    distinct?: CustomerResponseScalarFieldEnum | CustomerResponseScalarFieldEnum[]
  }

  /**
   * CustomerResponse create
   */
  export type CustomerResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerResponse
     */
    select?: CustomerResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerResponse
     */
    omit?: CustomerResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerResponse.
     */
    data: XOR<CustomerResponseCreateInput, CustomerResponseUncheckedCreateInput>
  }

  /**
   * CustomerResponse createMany
   */
  export type CustomerResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerResponses.
     */
    data: CustomerResponseCreateManyInput | CustomerResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerResponse update
   */
  export type CustomerResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerResponse
     */
    select?: CustomerResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerResponse
     */
    omit?: CustomerResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerResponse.
     */
    data: XOR<CustomerResponseUpdateInput, CustomerResponseUncheckedUpdateInput>
    /**
     * Choose, which CustomerResponse to update.
     */
    where: CustomerResponseWhereUniqueInput
  }

  /**
   * CustomerResponse updateMany
   */
  export type CustomerResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerResponses.
     */
    data: XOR<CustomerResponseUpdateManyMutationInput, CustomerResponseUncheckedUpdateManyInput>
    /**
     * Filter which CustomerResponses to update
     */
    where?: CustomerResponseWhereInput
  }

  /**
   * CustomerResponse upsert
   */
  export type CustomerResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerResponse
     */
    select?: CustomerResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerResponse
     */
    omit?: CustomerResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerResponse to update in case it exists.
     */
    where: CustomerResponseWhereUniqueInput
    /**
     * In case the CustomerResponse found by the `where` argument doesn't exist, create a new CustomerResponse with this data.
     */
    create: XOR<CustomerResponseCreateInput, CustomerResponseUncheckedCreateInput>
    /**
     * In case the CustomerResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerResponseUpdateInput, CustomerResponseUncheckedUpdateInput>
  }

  /**
   * CustomerResponse delete
   */
  export type CustomerResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerResponse
     */
    select?: CustomerResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerResponse
     */
    omit?: CustomerResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerResponseInclude<ExtArgs> | null
    /**
     * Filter which CustomerResponse to delete.
     */
    where: CustomerResponseWhereUniqueInput
  }

  /**
   * CustomerResponse deleteMany
   */
  export type CustomerResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerResponses to delete
     */
    where?: CustomerResponseWhereInput
  }

  /**
   * CustomerResponse without action
   */
  export type CustomerResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerResponse
     */
    select?: CustomerResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerResponse
     */
    omit?: CustomerResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerResponseInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    id: number | null
    itemTypeId: number | null
    itemCategoryId: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
  }

  export type ItemSumAggregateOutputType = {
    id: bigint | null
    itemTypeId: number | null
    itemCategoryId: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: bigint | null
    itemTypeId: number | null
    itemCategoryId: number | null
    name: string | null
    slug: string | null
    description: string | null
    shortDescription: string | null
    tags: string | null
    metaTitle: string | null
    metaDescription: string | null
    status: $Enums.ItemStatus | null
    isPinned: boolean | null
    isFavorite: boolean | null
    isDeleted: boolean | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    id: bigint | null
    itemTypeId: number | null
    itemCategoryId: number | null
    name: string | null
    slug: string | null
    description: string | null
    shortDescription: string | null
    tags: string | null
    metaTitle: string | null
    metaDescription: string | null
    status: $Enums.ItemStatus | null
    isPinned: boolean | null
    isFavorite: boolean | null
    isDeleted: boolean | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    itemTypeId: number
    itemCategoryId: number
    name: number
    slug: number
    description: number
    shortDescription: number
    tags: number
    attributes: number
    metaTitle: number
    metaDescription: number
    status: number
    isPinned: number
    isFavorite: number
    isDeleted: number
    createdBy: number
    updatedBy: number
    deletedBy: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    id?: true
    itemTypeId?: true
    itemCategoryId?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
  }

  export type ItemSumAggregateInputType = {
    id?: true
    itemTypeId?: true
    itemCategoryId?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    itemTypeId?: true
    itemCategoryId?: true
    name?: true
    slug?: true
    description?: true
    shortDescription?: true
    tags?: true
    metaTitle?: true
    metaDescription?: true
    status?: true
    isPinned?: true
    isFavorite?: true
    isDeleted?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    itemTypeId?: true
    itemCategoryId?: true
    name?: true
    slug?: true
    description?: true
    shortDescription?: true
    tags?: true
    metaTitle?: true
    metaDescription?: true
    status?: true
    isPinned?: true
    isFavorite?: true
    isDeleted?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    itemTypeId?: true
    itemCategoryId?: true
    name?: true
    slug?: true
    description?: true
    shortDescription?: true
    tags?: true
    attributes?: true
    metaTitle?: true
    metaDescription?: true
    status?: true
    isPinned?: true
    isFavorite?: true
    isDeleted?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: bigint
    itemTypeId: number
    itemCategoryId: number
    name: string
    slug: string
    description: string | null
    shortDescription: string | null
    tags: string | null
    attributes: JsonValue | null
    metaTitle: string | null
    metaDescription: string | null
    status: $Enums.ItemStatus
    isPinned: boolean
    isFavorite: boolean
    isDeleted: boolean
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemTypeId?: boolean
    itemCategoryId?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    shortDescription?: boolean
    tags?: boolean
    attributes?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    status?: boolean
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
    variants?: boolean | Item$variantsArgs<ExtArgs>
    images?: boolean | Item$imagesArgs<ExtArgs>
    videos?: boolean | Item$videosArgs<ExtArgs>
    updateHistories?: boolean | Item$updateHistoriesArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>



  export type ItemSelectScalar = {
    id?: boolean
    itemTypeId?: boolean
    itemCategoryId?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    shortDescription?: boolean
    tags?: boolean
    attributes?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    status?: boolean
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemTypeId" | "itemCategoryId" | "name" | "slug" | "description" | "shortDescription" | "tags" | "attributes" | "metaTitle" | "metaDescription" | "status" | "isPinned" | "isFavorite" | "isDeleted" | "createdBy" | "updatedBy" | "deletedBy" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["item"]>
  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
    variants?: boolean | Item$variantsArgs<ExtArgs>
    images?: boolean | Item$imagesArgs<ExtArgs>
    videos?: boolean | Item$videosArgs<ExtArgs>
    updateHistories?: boolean | Item$updateHistoriesArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      itemType: Prisma.$ItemTypePayload<ExtArgs>
      category: Prisma.$ItemCategoryPayload<ExtArgs>
      variants: Prisma.$ItemVariantPayload<ExtArgs>[]
      images: Prisma.$ItemImagePayload<ExtArgs>[]
      videos: Prisma.$ItemVideoPayload<ExtArgs>[]
      updateHistories: Prisma.$ItemUpdateHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      itemTypeId: number
      itemCategoryId: number
      name: string
      slug: string
      description: string | null
      shortDescription: string | null
      tags: string | null
      attributes: Prisma.JsonValue | null
      metaTitle: string | null
      metaDescription: string | null
      status: $Enums.ItemStatus
      isPinned: boolean
      isFavorite: boolean
      isDeleted: boolean
      createdBy: number | null
      updatedBy: number | null
      deletedBy: number | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itemType<T extends ItemTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemTypeDefaultArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    category<T extends ItemCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategoryDefaultArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    variants<T extends Item$variantsArgs<ExtArgs> = {}>(args?: Subset<T, Item$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemVariantPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    images<T extends Item$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Item$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemImagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    videos<T extends Item$videosArgs<ExtArgs> = {}>(args?: Subset<T, Item$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemVideoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    updateHistories<T extends Item$updateHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Item$updateHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemUpdateHistoryPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */ 
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'BigInt'>
    readonly itemTypeId: FieldRef<"Item", 'Int'>
    readonly itemCategoryId: FieldRef<"Item", 'Int'>
    readonly name: FieldRef<"Item", 'String'>
    readonly slug: FieldRef<"Item", 'String'>
    readonly description: FieldRef<"Item", 'String'>
    readonly shortDescription: FieldRef<"Item", 'String'>
    readonly tags: FieldRef<"Item", 'String'>
    readonly attributes: FieldRef<"Item", 'Json'>
    readonly metaTitle: FieldRef<"Item", 'String'>
    readonly metaDescription: FieldRef<"Item", 'String'>
    readonly status: FieldRef<"Item", 'ItemStatus'>
    readonly isPinned: FieldRef<"Item", 'Boolean'>
    readonly isFavorite: FieldRef<"Item", 'Boolean'>
    readonly isDeleted: FieldRef<"Item", 'Boolean'>
    readonly createdBy: FieldRef<"Item", 'Int'>
    readonly updatedBy: FieldRef<"Item", 'Int'>
    readonly deletedBy: FieldRef<"Item", 'Int'>
    readonly createdAt: FieldRef<"Item", 'DateTime'>
    readonly updatedAt: FieldRef<"Item", 'DateTime'>
    readonly deletedAt: FieldRef<"Item", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
  }

  /**
   * Item.variants
   */
  export type Item$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVariant
     */
    select?: ItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVariant
     */
    omit?: ItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVariantInclude<ExtArgs> | null
    where?: ItemVariantWhereInput
    orderBy?: ItemVariantOrderByWithRelationInput | ItemVariantOrderByWithRelationInput[]
    cursor?: ItemVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemVariantScalarFieldEnum | ItemVariantScalarFieldEnum[]
  }

  /**
   * Item.images
   */
  export type Item$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemImage
     */
    select?: ItemImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemImage
     */
    omit?: ItemImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemImageInclude<ExtArgs> | null
    where?: ItemImageWhereInput
    orderBy?: ItemImageOrderByWithRelationInput | ItemImageOrderByWithRelationInput[]
    cursor?: ItemImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemImageScalarFieldEnum | ItemImageScalarFieldEnum[]
  }

  /**
   * Item.videos
   */
  export type Item$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVideo
     */
    select?: ItemVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVideo
     */
    omit?: ItemVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVideoInclude<ExtArgs> | null
    where?: ItemVideoWhereInput
    orderBy?: ItemVideoOrderByWithRelationInput | ItemVideoOrderByWithRelationInput[]
    cursor?: ItemVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemVideoScalarFieldEnum | ItemVideoScalarFieldEnum[]
  }

  /**
   * Item.updateHistories
   */
  export type Item$updateHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemUpdateHistory
     */
    select?: ItemUpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemUpdateHistory
     */
    omit?: ItemUpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemUpdateHistoryInclude<ExtArgs> | null
    where?: ItemUpdateHistoryWhereInput
    orderBy?: ItemUpdateHistoryOrderByWithRelationInput | ItemUpdateHistoryOrderByWithRelationInput[]
    cursor?: ItemUpdateHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemUpdateHistoryScalarFieldEnum | ItemUpdateHistoryScalarFieldEnum[]
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model ItemAttributeTemplate
   */

  export type AggregateItemAttributeTemplate = {
    _count: ItemAttributeTemplateCountAggregateOutputType | null
    _avg: ItemAttributeTemplateAvgAggregateOutputType | null
    _sum: ItemAttributeTemplateSumAggregateOutputType | null
    _min: ItemAttributeTemplateMinAggregateOutputType | null
    _max: ItemAttributeTemplateMaxAggregateOutputType | null
  }

  export type ItemAttributeTemplateAvgAggregateOutputType = {
    id: number | null
    itemCategoryId: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
  }

  export type ItemAttributeTemplateSumAggregateOutputType = {
    id: number | null
    itemCategoryId: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
  }

  export type ItemAttributeTemplateMinAggregateOutputType = {
    id: number | null
    itemCategoryId: number | null
    name: string | null
    type: $Enums.AttributeType | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ItemAttributeTemplateMaxAggregateOutputType = {
    id: number | null
    itemCategoryId: number | null
    name: string | null
    type: $Enums.AttributeType | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ItemAttributeTemplateCountAggregateOutputType = {
    id: number
    itemCategoryId: number
    name: number
    type: number
    createdBy: number
    updatedBy: number
    deletedBy: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ItemAttributeTemplateAvgAggregateInputType = {
    id?: true
    itemCategoryId?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
  }

  export type ItemAttributeTemplateSumAggregateInputType = {
    id?: true
    itemCategoryId?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
  }

  export type ItemAttributeTemplateMinAggregateInputType = {
    id?: true
    itemCategoryId?: true
    name?: true
    type?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ItemAttributeTemplateMaxAggregateInputType = {
    id?: true
    itemCategoryId?: true
    name?: true
    type?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ItemAttributeTemplateCountAggregateInputType = {
    id?: true
    itemCategoryId?: true
    name?: true
    type?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ItemAttributeTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemAttributeTemplate to aggregate.
     */
    where?: ItemAttributeTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemAttributeTemplates to fetch.
     */
    orderBy?: ItemAttributeTemplateOrderByWithRelationInput | ItemAttributeTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemAttributeTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemAttributeTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemAttributeTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemAttributeTemplates
    **/
    _count?: true | ItemAttributeTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAttributeTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemAttributeTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemAttributeTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemAttributeTemplateMaxAggregateInputType
  }

  export type GetItemAttributeTemplateAggregateType<T extends ItemAttributeTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateItemAttributeTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemAttributeTemplate[P]>
      : GetScalarType<T[P], AggregateItemAttributeTemplate[P]>
  }




  export type ItemAttributeTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemAttributeTemplateWhereInput
    orderBy?: ItemAttributeTemplateOrderByWithAggregationInput | ItemAttributeTemplateOrderByWithAggregationInput[]
    by: ItemAttributeTemplateScalarFieldEnum[] | ItemAttributeTemplateScalarFieldEnum
    having?: ItemAttributeTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemAttributeTemplateCountAggregateInputType | true
    _avg?: ItemAttributeTemplateAvgAggregateInputType
    _sum?: ItemAttributeTemplateSumAggregateInputType
    _min?: ItemAttributeTemplateMinAggregateInputType
    _max?: ItemAttributeTemplateMaxAggregateInputType
  }

  export type ItemAttributeTemplateGroupByOutputType = {
    id: number
    itemCategoryId: number
    name: string
    type: $Enums.AttributeType
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ItemAttributeTemplateCountAggregateOutputType | null
    _avg: ItemAttributeTemplateAvgAggregateOutputType | null
    _sum: ItemAttributeTemplateSumAggregateOutputType | null
    _min: ItemAttributeTemplateMinAggregateOutputType | null
    _max: ItemAttributeTemplateMaxAggregateOutputType | null
  }

  type GetItemAttributeTemplateGroupByPayload<T extends ItemAttributeTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemAttributeTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemAttributeTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemAttributeTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ItemAttributeTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ItemAttributeTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemCategoryId?: boolean
    name?: boolean
    type?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemAttributeTemplate"]>



  export type ItemAttributeTemplateSelectScalar = {
    id?: boolean
    itemCategoryId?: boolean
    name?: boolean
    type?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ItemAttributeTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemCategoryId" | "name" | "type" | "createdBy" | "updatedBy" | "deletedBy" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["itemAttributeTemplate"]>
  export type ItemAttributeTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }

  export type $ItemAttributeTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemAttributeTemplate"
    objects: {
      category: Prisma.$ItemCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemCategoryId: number
      name: string
      type: $Enums.AttributeType
      createdBy: number | null
      updatedBy: number | null
      deletedBy: number | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["itemAttributeTemplate"]>
    composites: {}
  }

  type ItemAttributeTemplateGetPayload<S extends boolean | null | undefined | ItemAttributeTemplateDefaultArgs> = $Result.GetResult<Prisma.$ItemAttributeTemplatePayload, S>

  type ItemAttributeTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemAttributeTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemAttributeTemplateCountAggregateInputType | true
    }

  export interface ItemAttributeTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemAttributeTemplate'], meta: { name: 'ItemAttributeTemplate' } }
    /**
     * Find zero or one ItemAttributeTemplate that matches the filter.
     * @param {ItemAttributeTemplateFindUniqueArgs} args - Arguments to find a ItemAttributeTemplate
     * @example
     * // Get one ItemAttributeTemplate
     * const itemAttributeTemplate = await prisma.itemAttributeTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemAttributeTemplateFindUniqueArgs>(args: SelectSubset<T, ItemAttributeTemplateFindUniqueArgs<ExtArgs>>): Prisma__ItemAttributeTemplateClient<$Result.GetResult<Prisma.$ItemAttributeTemplatePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ItemAttributeTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemAttributeTemplateFindUniqueOrThrowArgs} args - Arguments to find a ItemAttributeTemplate
     * @example
     * // Get one ItemAttributeTemplate
     * const itemAttributeTemplate = await prisma.itemAttributeTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemAttributeTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemAttributeTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemAttributeTemplateClient<$Result.GetResult<Prisma.$ItemAttributeTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ItemAttributeTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAttributeTemplateFindFirstArgs} args - Arguments to find a ItemAttributeTemplate
     * @example
     * // Get one ItemAttributeTemplate
     * const itemAttributeTemplate = await prisma.itemAttributeTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemAttributeTemplateFindFirstArgs>(args?: SelectSubset<T, ItemAttributeTemplateFindFirstArgs<ExtArgs>>): Prisma__ItemAttributeTemplateClient<$Result.GetResult<Prisma.$ItemAttributeTemplatePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ItemAttributeTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAttributeTemplateFindFirstOrThrowArgs} args - Arguments to find a ItemAttributeTemplate
     * @example
     * // Get one ItemAttributeTemplate
     * const itemAttributeTemplate = await prisma.itemAttributeTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemAttributeTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemAttributeTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemAttributeTemplateClient<$Result.GetResult<Prisma.$ItemAttributeTemplatePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ItemAttributeTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAttributeTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemAttributeTemplates
     * const itemAttributeTemplates = await prisma.itemAttributeTemplate.findMany()
     * 
     * // Get first 10 ItemAttributeTemplates
     * const itemAttributeTemplates = await prisma.itemAttributeTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemAttributeTemplateWithIdOnly = await prisma.itemAttributeTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemAttributeTemplateFindManyArgs>(args?: SelectSubset<T, ItemAttributeTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemAttributeTemplatePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ItemAttributeTemplate.
     * @param {ItemAttributeTemplateCreateArgs} args - Arguments to create a ItemAttributeTemplate.
     * @example
     * // Create one ItemAttributeTemplate
     * const ItemAttributeTemplate = await prisma.itemAttributeTemplate.create({
     *   data: {
     *     // ... data to create a ItemAttributeTemplate
     *   }
     * })
     * 
     */
    create<T extends ItemAttributeTemplateCreateArgs>(args: SelectSubset<T, ItemAttributeTemplateCreateArgs<ExtArgs>>): Prisma__ItemAttributeTemplateClient<$Result.GetResult<Prisma.$ItemAttributeTemplatePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ItemAttributeTemplates.
     * @param {ItemAttributeTemplateCreateManyArgs} args - Arguments to create many ItemAttributeTemplates.
     * @example
     * // Create many ItemAttributeTemplates
     * const itemAttributeTemplate = await prisma.itemAttributeTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemAttributeTemplateCreateManyArgs>(args?: SelectSubset<T, ItemAttributeTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemAttributeTemplate.
     * @param {ItemAttributeTemplateDeleteArgs} args - Arguments to delete one ItemAttributeTemplate.
     * @example
     * // Delete one ItemAttributeTemplate
     * const ItemAttributeTemplate = await prisma.itemAttributeTemplate.delete({
     *   where: {
     *     // ... filter to delete one ItemAttributeTemplate
     *   }
     * })
     * 
     */
    delete<T extends ItemAttributeTemplateDeleteArgs>(args: SelectSubset<T, ItemAttributeTemplateDeleteArgs<ExtArgs>>): Prisma__ItemAttributeTemplateClient<$Result.GetResult<Prisma.$ItemAttributeTemplatePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ItemAttributeTemplate.
     * @param {ItemAttributeTemplateUpdateArgs} args - Arguments to update one ItemAttributeTemplate.
     * @example
     * // Update one ItemAttributeTemplate
     * const itemAttributeTemplate = await prisma.itemAttributeTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemAttributeTemplateUpdateArgs>(args: SelectSubset<T, ItemAttributeTemplateUpdateArgs<ExtArgs>>): Prisma__ItemAttributeTemplateClient<$Result.GetResult<Prisma.$ItemAttributeTemplatePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ItemAttributeTemplates.
     * @param {ItemAttributeTemplateDeleteManyArgs} args - Arguments to filter ItemAttributeTemplates to delete.
     * @example
     * // Delete a few ItemAttributeTemplates
     * const { count } = await prisma.itemAttributeTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemAttributeTemplateDeleteManyArgs>(args?: SelectSubset<T, ItemAttributeTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemAttributeTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAttributeTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemAttributeTemplates
     * const itemAttributeTemplate = await prisma.itemAttributeTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemAttributeTemplateUpdateManyArgs>(args: SelectSubset<T, ItemAttributeTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemAttributeTemplate.
     * @param {ItemAttributeTemplateUpsertArgs} args - Arguments to update or create a ItemAttributeTemplate.
     * @example
     * // Update or create a ItemAttributeTemplate
     * const itemAttributeTemplate = await prisma.itemAttributeTemplate.upsert({
     *   create: {
     *     // ... data to create a ItemAttributeTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemAttributeTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ItemAttributeTemplateUpsertArgs>(args: SelectSubset<T, ItemAttributeTemplateUpsertArgs<ExtArgs>>): Prisma__ItemAttributeTemplateClient<$Result.GetResult<Prisma.$ItemAttributeTemplatePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ItemAttributeTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAttributeTemplateCountArgs} args - Arguments to filter ItemAttributeTemplates to count.
     * @example
     * // Count the number of ItemAttributeTemplates
     * const count = await prisma.itemAttributeTemplate.count({
     *   where: {
     *     // ... the filter for the ItemAttributeTemplates we want to count
     *   }
     * })
    **/
    count<T extends ItemAttributeTemplateCountArgs>(
      args?: Subset<T, ItemAttributeTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemAttributeTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemAttributeTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAttributeTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAttributeTemplateAggregateArgs>(args: Subset<T, ItemAttributeTemplateAggregateArgs>): Prisma.PrismaPromise<GetItemAttributeTemplateAggregateType<T>>

    /**
     * Group by ItemAttributeTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAttributeTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemAttributeTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemAttributeTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ItemAttributeTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemAttributeTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemAttributeTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemAttributeTemplate model
   */
  readonly fields: ItemAttributeTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemAttributeTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemAttributeTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends ItemCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategoryDefaultArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemAttributeTemplate model
   */ 
  interface ItemAttributeTemplateFieldRefs {
    readonly id: FieldRef<"ItemAttributeTemplate", 'Int'>
    readonly itemCategoryId: FieldRef<"ItemAttributeTemplate", 'Int'>
    readonly name: FieldRef<"ItemAttributeTemplate", 'String'>
    readonly type: FieldRef<"ItemAttributeTemplate", 'AttributeType'>
    readonly createdBy: FieldRef<"ItemAttributeTemplate", 'Int'>
    readonly updatedBy: FieldRef<"ItemAttributeTemplate", 'Int'>
    readonly deletedBy: FieldRef<"ItemAttributeTemplate", 'Int'>
    readonly createdAt: FieldRef<"ItemAttributeTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ItemAttributeTemplate", 'DateTime'>
    readonly deletedAt: FieldRef<"ItemAttributeTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemAttributeTemplate findUnique
   */
  export type ItemAttributeTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemAttributeTemplate
     */
    select?: ItemAttributeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemAttributeTemplate
     */
    omit?: ItemAttributeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemAttributeTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ItemAttributeTemplate to fetch.
     */
    where: ItemAttributeTemplateWhereUniqueInput
  }

  /**
   * ItemAttributeTemplate findUniqueOrThrow
   */
  export type ItemAttributeTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemAttributeTemplate
     */
    select?: ItemAttributeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemAttributeTemplate
     */
    omit?: ItemAttributeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemAttributeTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ItemAttributeTemplate to fetch.
     */
    where: ItemAttributeTemplateWhereUniqueInput
  }

  /**
   * ItemAttributeTemplate findFirst
   */
  export type ItemAttributeTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemAttributeTemplate
     */
    select?: ItemAttributeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemAttributeTemplate
     */
    omit?: ItemAttributeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemAttributeTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ItemAttributeTemplate to fetch.
     */
    where?: ItemAttributeTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemAttributeTemplates to fetch.
     */
    orderBy?: ItemAttributeTemplateOrderByWithRelationInput | ItemAttributeTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemAttributeTemplates.
     */
    cursor?: ItemAttributeTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemAttributeTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemAttributeTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemAttributeTemplates.
     */
    distinct?: ItemAttributeTemplateScalarFieldEnum | ItemAttributeTemplateScalarFieldEnum[]
  }

  /**
   * ItemAttributeTemplate findFirstOrThrow
   */
  export type ItemAttributeTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemAttributeTemplate
     */
    select?: ItemAttributeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemAttributeTemplate
     */
    omit?: ItemAttributeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemAttributeTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ItemAttributeTemplate to fetch.
     */
    where?: ItemAttributeTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemAttributeTemplates to fetch.
     */
    orderBy?: ItemAttributeTemplateOrderByWithRelationInput | ItemAttributeTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemAttributeTemplates.
     */
    cursor?: ItemAttributeTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemAttributeTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemAttributeTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemAttributeTemplates.
     */
    distinct?: ItemAttributeTemplateScalarFieldEnum | ItemAttributeTemplateScalarFieldEnum[]
  }

  /**
   * ItemAttributeTemplate findMany
   */
  export type ItemAttributeTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemAttributeTemplate
     */
    select?: ItemAttributeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemAttributeTemplate
     */
    omit?: ItemAttributeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemAttributeTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ItemAttributeTemplates to fetch.
     */
    where?: ItemAttributeTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemAttributeTemplates to fetch.
     */
    orderBy?: ItemAttributeTemplateOrderByWithRelationInput | ItemAttributeTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemAttributeTemplates.
     */
    cursor?: ItemAttributeTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemAttributeTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemAttributeTemplates.
     */
    skip?: number
    distinct?: ItemAttributeTemplateScalarFieldEnum | ItemAttributeTemplateScalarFieldEnum[]
  }

  /**
   * ItemAttributeTemplate create
   */
  export type ItemAttributeTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemAttributeTemplate
     */
    select?: ItemAttributeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemAttributeTemplate
     */
    omit?: ItemAttributeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemAttributeTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemAttributeTemplate.
     */
    data: XOR<ItemAttributeTemplateCreateInput, ItemAttributeTemplateUncheckedCreateInput>
  }

  /**
   * ItemAttributeTemplate createMany
   */
  export type ItemAttributeTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemAttributeTemplates.
     */
    data: ItemAttributeTemplateCreateManyInput | ItemAttributeTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemAttributeTemplate update
   */
  export type ItemAttributeTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemAttributeTemplate
     */
    select?: ItemAttributeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemAttributeTemplate
     */
    omit?: ItemAttributeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemAttributeTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemAttributeTemplate.
     */
    data: XOR<ItemAttributeTemplateUpdateInput, ItemAttributeTemplateUncheckedUpdateInput>
    /**
     * Choose, which ItemAttributeTemplate to update.
     */
    where: ItemAttributeTemplateWhereUniqueInput
  }

  /**
   * ItemAttributeTemplate updateMany
   */
  export type ItemAttributeTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemAttributeTemplates.
     */
    data: XOR<ItemAttributeTemplateUpdateManyMutationInput, ItemAttributeTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ItemAttributeTemplates to update
     */
    where?: ItemAttributeTemplateWhereInput
  }

  /**
   * ItemAttributeTemplate upsert
   */
  export type ItemAttributeTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemAttributeTemplate
     */
    select?: ItemAttributeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemAttributeTemplate
     */
    omit?: ItemAttributeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemAttributeTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemAttributeTemplate to update in case it exists.
     */
    where: ItemAttributeTemplateWhereUniqueInput
    /**
     * In case the ItemAttributeTemplate found by the `where` argument doesn't exist, create a new ItemAttributeTemplate with this data.
     */
    create: XOR<ItemAttributeTemplateCreateInput, ItemAttributeTemplateUncheckedCreateInput>
    /**
     * In case the ItemAttributeTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemAttributeTemplateUpdateInput, ItemAttributeTemplateUncheckedUpdateInput>
  }

  /**
   * ItemAttributeTemplate delete
   */
  export type ItemAttributeTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemAttributeTemplate
     */
    select?: ItemAttributeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemAttributeTemplate
     */
    omit?: ItemAttributeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemAttributeTemplateInclude<ExtArgs> | null
    /**
     * Filter which ItemAttributeTemplate to delete.
     */
    where: ItemAttributeTemplateWhereUniqueInput
  }

  /**
   * ItemAttributeTemplate deleteMany
   */
  export type ItemAttributeTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemAttributeTemplates to delete
     */
    where?: ItemAttributeTemplateWhereInput
  }

  /**
   * ItemAttributeTemplate without action
   */
  export type ItemAttributeTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemAttributeTemplate
     */
    select?: ItemAttributeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemAttributeTemplate
     */
    omit?: ItemAttributeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemAttributeTemplateInclude<ExtArgs> | null
  }


  /**
   * Model ItemCategory
   */

  export type AggregateItemCategory = {
    _count: ItemCategoryCountAggregateOutputType | null
    _avg: ItemCategoryAvgAggregateOutputType | null
    _sum: ItemCategorySumAggregateOutputType | null
    _min: ItemCategoryMinAggregateOutputType | null
    _max: ItemCategoryMaxAggregateOutputType | null
  }

  export type ItemCategoryAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
  }

  export type ItemCategorySumAggregateOutputType = {
    id: number | null
    parentId: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
  }

  export type ItemCategoryMinAggregateOutputType = {
    id: number | null
    parentId: number | null
    name: string | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ItemCategoryMaxAggregateOutputType = {
    id: number | null
    parentId: number | null
    name: string | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ItemCategoryCountAggregateOutputType = {
    id: number
    parentId: number
    name: number
    createdBy: number
    updatedBy: number
    deletedBy: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ItemCategoryAvgAggregateInputType = {
    id?: true
    parentId?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
  }

  export type ItemCategorySumAggregateInputType = {
    id?: true
    parentId?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
  }

  export type ItemCategoryMinAggregateInputType = {
    id?: true
    parentId?: true
    name?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ItemCategoryMaxAggregateInputType = {
    id?: true
    parentId?: true
    name?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ItemCategoryCountAggregateInputType = {
    id?: true
    parentId?: true
    name?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ItemCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCategory to aggregate.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemCategories
    **/
    _count?: true | ItemCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemCategoryMaxAggregateInputType
  }

  export type GetItemCategoryAggregateType<T extends ItemCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateItemCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemCategory[P]>
      : GetScalarType<T[P], AggregateItemCategory[P]>
  }




  export type ItemCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCategoryWhereInput
    orderBy?: ItemCategoryOrderByWithAggregationInput | ItemCategoryOrderByWithAggregationInput[]
    by: ItemCategoryScalarFieldEnum[] | ItemCategoryScalarFieldEnum
    having?: ItemCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCategoryCountAggregateInputType | true
    _avg?: ItemCategoryAvgAggregateInputType
    _sum?: ItemCategorySumAggregateInputType
    _min?: ItemCategoryMinAggregateInputType
    _max?: ItemCategoryMaxAggregateInputType
  }

  export type ItemCategoryGroupByOutputType = {
    id: number
    parentId: number | null
    name: string
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ItemCategoryCountAggregateOutputType | null
    _avg: ItemCategoryAvgAggregateOutputType | null
    _sum: ItemCategorySumAggregateOutputType | null
    _min: ItemCategoryMinAggregateOutputType | null
    _max: ItemCategoryMaxAggregateOutputType | null
  }

  type GetItemCategoryGroupByPayload<T extends ItemCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ItemCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ItemCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parentId?: boolean
    name?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    parent?: boolean | ItemCategory$parentArgs<ExtArgs>
    children?: boolean | ItemCategory$childrenArgs<ExtArgs>
    items?: boolean | ItemCategory$itemsArgs<ExtArgs>
    attributeTemplates?: boolean | ItemCategory$attributeTemplatesArgs<ExtArgs>
    _count?: boolean | ItemCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemCategory"]>



  export type ItemCategorySelectScalar = {
    id?: boolean
    parentId?: boolean
    name?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ItemCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "parentId" | "name" | "createdBy" | "updatedBy" | "deletedBy" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["itemCategory"]>
  export type ItemCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ItemCategory$parentArgs<ExtArgs>
    children?: boolean | ItemCategory$childrenArgs<ExtArgs>
    items?: boolean | ItemCategory$itemsArgs<ExtArgs>
    attributeTemplates?: boolean | ItemCategory$attributeTemplatesArgs<ExtArgs>
    _count?: boolean | ItemCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ItemCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemCategory"
    objects: {
      parent: Prisma.$ItemCategoryPayload<ExtArgs> | null
      children: Prisma.$ItemCategoryPayload<ExtArgs>[]
      items: Prisma.$ItemPayload<ExtArgs>[]
      attributeTemplates: Prisma.$ItemAttributeTemplatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      parentId: number | null
      name: string
      createdBy: number | null
      updatedBy: number | null
      deletedBy: number | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["itemCategory"]>
    composites: {}
  }

  type ItemCategoryGetPayload<S extends boolean | null | undefined | ItemCategoryDefaultArgs> = $Result.GetResult<Prisma.$ItemCategoryPayload, S>

  type ItemCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCategoryCountAggregateInputType | true
    }

  export interface ItemCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemCategory'], meta: { name: 'ItemCategory' } }
    /**
     * Find zero or one ItemCategory that matches the filter.
     * @param {ItemCategoryFindUniqueArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemCategoryFindUniqueArgs>(args: SelectSubset<T, ItemCategoryFindUniqueArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ItemCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemCategoryFindUniqueOrThrowArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ItemCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindFirstArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemCategoryFindFirstArgs>(args?: SelectSubset<T, ItemCategoryFindFirstArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ItemCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindFirstOrThrowArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ItemCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemCategories
     * const itemCategories = await prisma.itemCategory.findMany()
     * 
     * // Get first 10 ItemCategories
     * const itemCategories = await prisma.itemCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemCategoryWithIdOnly = await prisma.itemCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemCategoryFindManyArgs>(args?: SelectSubset<T, ItemCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ItemCategory.
     * @param {ItemCategoryCreateArgs} args - Arguments to create a ItemCategory.
     * @example
     * // Create one ItemCategory
     * const ItemCategory = await prisma.itemCategory.create({
     *   data: {
     *     // ... data to create a ItemCategory
     *   }
     * })
     * 
     */
    create<T extends ItemCategoryCreateArgs>(args: SelectSubset<T, ItemCategoryCreateArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ItemCategories.
     * @param {ItemCategoryCreateManyArgs} args - Arguments to create many ItemCategories.
     * @example
     * // Create many ItemCategories
     * const itemCategory = await prisma.itemCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCategoryCreateManyArgs>(args?: SelectSubset<T, ItemCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemCategory.
     * @param {ItemCategoryDeleteArgs} args - Arguments to delete one ItemCategory.
     * @example
     * // Delete one ItemCategory
     * const ItemCategory = await prisma.itemCategory.delete({
     *   where: {
     *     // ... filter to delete one ItemCategory
     *   }
     * })
     * 
     */
    delete<T extends ItemCategoryDeleteArgs>(args: SelectSubset<T, ItemCategoryDeleteArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ItemCategory.
     * @param {ItemCategoryUpdateArgs} args - Arguments to update one ItemCategory.
     * @example
     * // Update one ItemCategory
     * const itemCategory = await prisma.itemCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemCategoryUpdateArgs>(args: SelectSubset<T, ItemCategoryUpdateArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ItemCategories.
     * @param {ItemCategoryDeleteManyArgs} args - Arguments to filter ItemCategories to delete.
     * @example
     * // Delete a few ItemCategories
     * const { count } = await prisma.itemCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemCategoryDeleteManyArgs>(args?: SelectSubset<T, ItemCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemCategories
     * const itemCategory = await prisma.itemCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemCategoryUpdateManyArgs>(args: SelectSubset<T, ItemCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemCategory.
     * @param {ItemCategoryUpsertArgs} args - Arguments to update or create a ItemCategory.
     * @example
     * // Update or create a ItemCategory
     * const itemCategory = await prisma.itemCategory.upsert({
     *   create: {
     *     // ... data to create a ItemCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemCategory we want to update
     *   }
     * })
     */
    upsert<T extends ItemCategoryUpsertArgs>(args: SelectSubset<T, ItemCategoryUpsertArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ItemCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryCountArgs} args - Arguments to filter ItemCategories to count.
     * @example
     * // Count the number of ItemCategories
     * const count = await prisma.itemCategory.count({
     *   where: {
     *     // ... the filter for the ItemCategories we want to count
     *   }
     * })
    **/
    count<T extends ItemCategoryCountArgs>(
      args?: Subset<T, ItemCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemCategoryAggregateArgs>(args: Subset<T, ItemCategoryAggregateArgs>): Prisma.PrismaPromise<GetItemCategoryAggregateType<T>>

    /**
     * Group by ItemCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ItemCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemCategory model
   */
  readonly fields: ItemCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends ItemCategory$parentArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategory$parentArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    children<T extends ItemCategory$childrenArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategory$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    items<T extends ItemCategory$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategory$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    attributeTemplates<T extends ItemCategory$attributeTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategory$attributeTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemAttributeTemplatePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemCategory model
   */ 
  interface ItemCategoryFieldRefs {
    readonly id: FieldRef<"ItemCategory", 'Int'>
    readonly parentId: FieldRef<"ItemCategory", 'Int'>
    readonly name: FieldRef<"ItemCategory", 'String'>
    readonly createdBy: FieldRef<"ItemCategory", 'Int'>
    readonly updatedBy: FieldRef<"ItemCategory", 'Int'>
    readonly deletedBy: FieldRef<"ItemCategory", 'Int'>
    readonly createdAt: FieldRef<"ItemCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ItemCategory", 'DateTime'>
    readonly deletedAt: FieldRef<"ItemCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemCategory findUnique
   */
  export type ItemCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory findUniqueOrThrow
   */
  export type ItemCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory findFirst
   */
  export type ItemCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategories.
     */
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory findFirstOrThrow
   */
  export type ItemCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategories.
     */
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory findMany
   */
  export type ItemCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategories to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory create
   */
  export type ItemCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemCategory.
     */
    data: XOR<ItemCategoryCreateInput, ItemCategoryUncheckedCreateInput>
  }

  /**
   * ItemCategory createMany
   */
  export type ItemCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemCategories.
     */
    data: ItemCategoryCreateManyInput | ItemCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemCategory update
   */
  export type ItemCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemCategory.
     */
    data: XOR<ItemCategoryUpdateInput, ItemCategoryUncheckedUpdateInput>
    /**
     * Choose, which ItemCategory to update.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory updateMany
   */
  export type ItemCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemCategories.
     */
    data: XOR<ItemCategoryUpdateManyMutationInput, ItemCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ItemCategories to update
     */
    where?: ItemCategoryWhereInput
  }

  /**
   * ItemCategory upsert
   */
  export type ItemCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemCategory to update in case it exists.
     */
    where: ItemCategoryWhereUniqueInput
    /**
     * In case the ItemCategory found by the `where` argument doesn't exist, create a new ItemCategory with this data.
     */
    create: XOR<ItemCategoryCreateInput, ItemCategoryUncheckedCreateInput>
    /**
     * In case the ItemCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemCategoryUpdateInput, ItemCategoryUncheckedUpdateInput>
  }

  /**
   * ItemCategory delete
   */
  export type ItemCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter which ItemCategory to delete.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory deleteMany
   */
  export type ItemCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCategories to delete
     */
    where?: ItemCategoryWhereInput
  }

  /**
   * ItemCategory.parent
   */
  export type ItemCategory$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    where?: ItemCategoryWhereInput
  }

  /**
   * ItemCategory.children
   */
  export type ItemCategory$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    where?: ItemCategoryWhereInput
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    cursor?: ItemCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory.items
   */
  export type ItemCategory$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * ItemCategory.attributeTemplates
   */
  export type ItemCategory$attributeTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemAttributeTemplate
     */
    select?: ItemAttributeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemAttributeTemplate
     */
    omit?: ItemAttributeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemAttributeTemplateInclude<ExtArgs> | null
    where?: ItemAttributeTemplateWhereInput
    orderBy?: ItemAttributeTemplateOrderByWithRelationInput | ItemAttributeTemplateOrderByWithRelationInput[]
    cursor?: ItemAttributeTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemAttributeTemplateScalarFieldEnum | ItemAttributeTemplateScalarFieldEnum[]
  }

  /**
   * ItemCategory without action
   */
  export type ItemCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ItemImage
   */

  export type AggregateItemImage = {
    _count: ItemImageCountAggregateOutputType | null
    _avg: ItemImageAvgAggregateOutputType | null
    _sum: ItemImageSumAggregateOutputType | null
    _min: ItemImageMinAggregateOutputType | null
    _max: ItemImageMaxAggregateOutputType | null
  }

  export type ItemImageAvgAggregateOutputType = {
    id: number | null
    itemId: number | null
    sortOrder: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
  }

  export type ItemImageSumAggregateOutputType = {
    id: bigint | null
    itemId: bigint | null
    sortOrder: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
  }

  export type ItemImageMinAggregateOutputType = {
    id: bigint | null
    itemId: bigint | null
    url: string | null
    isPrimary: boolean | null
    sortOrder: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ItemImageMaxAggregateOutputType = {
    id: bigint | null
    itemId: bigint | null
    url: string | null
    isPrimary: boolean | null
    sortOrder: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ItemImageCountAggregateOutputType = {
    id: number
    itemId: number
    url: number
    isPrimary: number
    sortOrder: number
    createdBy: number
    updatedBy: number
    deletedBy: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ItemImageAvgAggregateInputType = {
    id?: true
    itemId?: true
    sortOrder?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
  }

  export type ItemImageSumAggregateInputType = {
    id?: true
    itemId?: true
    sortOrder?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
  }

  export type ItemImageMinAggregateInputType = {
    id?: true
    itemId?: true
    url?: true
    isPrimary?: true
    sortOrder?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ItemImageMaxAggregateInputType = {
    id?: true
    itemId?: true
    url?: true
    isPrimary?: true
    sortOrder?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ItemImageCountAggregateInputType = {
    id?: true
    itemId?: true
    url?: true
    isPrimary?: true
    sortOrder?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ItemImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemImage to aggregate.
     */
    where?: ItemImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemImages to fetch.
     */
    orderBy?: ItemImageOrderByWithRelationInput | ItemImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemImages
    **/
    _count?: true | ItemImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemImageMaxAggregateInputType
  }

  export type GetItemImageAggregateType<T extends ItemImageAggregateArgs> = {
        [P in keyof T & keyof AggregateItemImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemImage[P]>
      : GetScalarType<T[P], AggregateItemImage[P]>
  }




  export type ItemImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemImageWhereInput
    orderBy?: ItemImageOrderByWithAggregationInput | ItemImageOrderByWithAggregationInput[]
    by: ItemImageScalarFieldEnum[] | ItemImageScalarFieldEnum
    having?: ItemImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemImageCountAggregateInputType | true
    _avg?: ItemImageAvgAggregateInputType
    _sum?: ItemImageSumAggregateInputType
    _min?: ItemImageMinAggregateInputType
    _max?: ItemImageMaxAggregateInputType
  }

  export type ItemImageGroupByOutputType = {
    id: bigint
    itemId: bigint
    url: string
    isPrimary: boolean
    sortOrder: number
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ItemImageCountAggregateOutputType | null
    _avg: ItemImageAvgAggregateOutputType | null
    _sum: ItemImageSumAggregateOutputType | null
    _min: ItemImageMinAggregateOutputType | null
    _max: ItemImageMaxAggregateOutputType | null
  }

  type GetItemImageGroupByPayload<T extends ItemImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemImageGroupByOutputType[P]>
            : GetScalarType<T[P], ItemImageGroupByOutputType[P]>
        }
      >
    >


  export type ItemImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    url?: boolean
    isPrimary?: boolean
    sortOrder?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemImage"]>



  export type ItemImageSelectScalar = {
    id?: boolean
    itemId?: boolean
    url?: boolean
    isPrimary?: boolean
    sortOrder?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ItemImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemId" | "url" | "isPrimary" | "sortOrder" | "createdBy" | "updatedBy" | "deletedBy" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["itemImage"]>
  export type ItemImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $ItemImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemImage"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      itemId: bigint
      url: string
      isPrimary: boolean
      sortOrder: number
      createdBy: number | null
      updatedBy: number | null
      deletedBy: number | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["itemImage"]>
    composites: {}
  }

  type ItemImageGetPayload<S extends boolean | null | undefined | ItemImageDefaultArgs> = $Result.GetResult<Prisma.$ItemImagePayload, S>

  type ItemImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemImageCountAggregateInputType | true
    }

  export interface ItemImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemImage'], meta: { name: 'ItemImage' } }
    /**
     * Find zero or one ItemImage that matches the filter.
     * @param {ItemImageFindUniqueArgs} args - Arguments to find a ItemImage
     * @example
     * // Get one ItemImage
     * const itemImage = await prisma.itemImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemImageFindUniqueArgs>(args: SelectSubset<T, ItemImageFindUniqueArgs<ExtArgs>>): Prisma__ItemImageClient<$Result.GetResult<Prisma.$ItemImagePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ItemImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemImageFindUniqueOrThrowArgs} args - Arguments to find a ItemImage
     * @example
     * // Get one ItemImage
     * const itemImage = await prisma.itemImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemImageClient<$Result.GetResult<Prisma.$ItemImagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ItemImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemImageFindFirstArgs} args - Arguments to find a ItemImage
     * @example
     * // Get one ItemImage
     * const itemImage = await prisma.itemImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemImageFindFirstArgs>(args?: SelectSubset<T, ItemImageFindFirstArgs<ExtArgs>>): Prisma__ItemImageClient<$Result.GetResult<Prisma.$ItemImagePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ItemImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemImageFindFirstOrThrowArgs} args - Arguments to find a ItemImage
     * @example
     * // Get one ItemImage
     * const itemImage = await prisma.itemImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemImageClient<$Result.GetResult<Prisma.$ItemImagePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ItemImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemImages
     * const itemImages = await prisma.itemImage.findMany()
     * 
     * // Get first 10 ItemImages
     * const itemImages = await prisma.itemImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemImageWithIdOnly = await prisma.itemImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemImageFindManyArgs>(args?: SelectSubset<T, ItemImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemImagePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ItemImage.
     * @param {ItemImageCreateArgs} args - Arguments to create a ItemImage.
     * @example
     * // Create one ItemImage
     * const ItemImage = await prisma.itemImage.create({
     *   data: {
     *     // ... data to create a ItemImage
     *   }
     * })
     * 
     */
    create<T extends ItemImageCreateArgs>(args: SelectSubset<T, ItemImageCreateArgs<ExtArgs>>): Prisma__ItemImageClient<$Result.GetResult<Prisma.$ItemImagePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ItemImages.
     * @param {ItemImageCreateManyArgs} args - Arguments to create many ItemImages.
     * @example
     * // Create many ItemImages
     * const itemImage = await prisma.itemImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemImageCreateManyArgs>(args?: SelectSubset<T, ItemImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemImage.
     * @param {ItemImageDeleteArgs} args - Arguments to delete one ItemImage.
     * @example
     * // Delete one ItemImage
     * const ItemImage = await prisma.itemImage.delete({
     *   where: {
     *     // ... filter to delete one ItemImage
     *   }
     * })
     * 
     */
    delete<T extends ItemImageDeleteArgs>(args: SelectSubset<T, ItemImageDeleteArgs<ExtArgs>>): Prisma__ItemImageClient<$Result.GetResult<Prisma.$ItemImagePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ItemImage.
     * @param {ItemImageUpdateArgs} args - Arguments to update one ItemImage.
     * @example
     * // Update one ItemImage
     * const itemImage = await prisma.itemImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemImageUpdateArgs>(args: SelectSubset<T, ItemImageUpdateArgs<ExtArgs>>): Prisma__ItemImageClient<$Result.GetResult<Prisma.$ItemImagePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ItemImages.
     * @param {ItemImageDeleteManyArgs} args - Arguments to filter ItemImages to delete.
     * @example
     * // Delete a few ItemImages
     * const { count } = await prisma.itemImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemImageDeleteManyArgs>(args?: SelectSubset<T, ItemImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemImages
     * const itemImage = await prisma.itemImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemImageUpdateManyArgs>(args: SelectSubset<T, ItemImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemImage.
     * @param {ItemImageUpsertArgs} args - Arguments to update or create a ItemImage.
     * @example
     * // Update or create a ItemImage
     * const itemImage = await prisma.itemImage.upsert({
     *   create: {
     *     // ... data to create a ItemImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemImage we want to update
     *   }
     * })
     */
    upsert<T extends ItemImageUpsertArgs>(args: SelectSubset<T, ItemImageUpsertArgs<ExtArgs>>): Prisma__ItemImageClient<$Result.GetResult<Prisma.$ItemImagePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ItemImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemImageCountArgs} args - Arguments to filter ItemImages to count.
     * @example
     * // Count the number of ItemImages
     * const count = await prisma.itemImage.count({
     *   where: {
     *     // ... the filter for the ItemImages we want to count
     *   }
     * })
    **/
    count<T extends ItemImageCountArgs>(
      args?: Subset<T, ItemImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemImageAggregateArgs>(args: Subset<T, ItemImageAggregateArgs>): Prisma.PrismaPromise<GetItemImageAggregateType<T>>

    /**
     * Group by ItemImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemImageGroupByArgs['orderBy'] }
        : { orderBy?: ItemImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemImage model
   */
  readonly fields: ItemImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemImage model
   */ 
  interface ItemImageFieldRefs {
    readonly id: FieldRef<"ItemImage", 'BigInt'>
    readonly itemId: FieldRef<"ItemImage", 'BigInt'>
    readonly url: FieldRef<"ItemImage", 'String'>
    readonly isPrimary: FieldRef<"ItemImage", 'Boolean'>
    readonly sortOrder: FieldRef<"ItemImage", 'Int'>
    readonly createdBy: FieldRef<"ItemImage", 'Int'>
    readonly updatedBy: FieldRef<"ItemImage", 'Int'>
    readonly deletedBy: FieldRef<"ItemImage", 'Int'>
    readonly createdAt: FieldRef<"ItemImage", 'DateTime'>
    readonly updatedAt: FieldRef<"ItemImage", 'DateTime'>
    readonly deletedAt: FieldRef<"ItemImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemImage findUnique
   */
  export type ItemImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemImage
     */
    select?: ItemImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemImage
     */
    omit?: ItemImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemImageInclude<ExtArgs> | null
    /**
     * Filter, which ItemImage to fetch.
     */
    where: ItemImageWhereUniqueInput
  }

  /**
   * ItemImage findUniqueOrThrow
   */
  export type ItemImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemImage
     */
    select?: ItemImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemImage
     */
    omit?: ItemImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemImageInclude<ExtArgs> | null
    /**
     * Filter, which ItemImage to fetch.
     */
    where: ItemImageWhereUniqueInput
  }

  /**
   * ItemImage findFirst
   */
  export type ItemImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemImage
     */
    select?: ItemImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemImage
     */
    omit?: ItemImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemImageInclude<ExtArgs> | null
    /**
     * Filter, which ItemImage to fetch.
     */
    where?: ItemImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemImages to fetch.
     */
    orderBy?: ItemImageOrderByWithRelationInput | ItemImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemImages.
     */
    cursor?: ItemImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemImages.
     */
    distinct?: ItemImageScalarFieldEnum | ItemImageScalarFieldEnum[]
  }

  /**
   * ItemImage findFirstOrThrow
   */
  export type ItemImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemImage
     */
    select?: ItemImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemImage
     */
    omit?: ItemImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemImageInclude<ExtArgs> | null
    /**
     * Filter, which ItemImage to fetch.
     */
    where?: ItemImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemImages to fetch.
     */
    orderBy?: ItemImageOrderByWithRelationInput | ItemImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemImages.
     */
    cursor?: ItemImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemImages.
     */
    distinct?: ItemImageScalarFieldEnum | ItemImageScalarFieldEnum[]
  }

  /**
   * ItemImage findMany
   */
  export type ItemImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemImage
     */
    select?: ItemImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemImage
     */
    omit?: ItemImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemImageInclude<ExtArgs> | null
    /**
     * Filter, which ItemImages to fetch.
     */
    where?: ItemImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemImages to fetch.
     */
    orderBy?: ItemImageOrderByWithRelationInput | ItemImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemImages.
     */
    cursor?: ItemImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemImages.
     */
    skip?: number
    distinct?: ItemImageScalarFieldEnum | ItemImageScalarFieldEnum[]
  }

  /**
   * ItemImage create
   */
  export type ItemImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemImage
     */
    select?: ItemImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemImage
     */
    omit?: ItemImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemImageInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemImage.
     */
    data: XOR<ItemImageCreateInput, ItemImageUncheckedCreateInput>
  }

  /**
   * ItemImage createMany
   */
  export type ItemImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemImages.
     */
    data: ItemImageCreateManyInput | ItemImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemImage update
   */
  export type ItemImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemImage
     */
    select?: ItemImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemImage
     */
    omit?: ItemImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemImageInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemImage.
     */
    data: XOR<ItemImageUpdateInput, ItemImageUncheckedUpdateInput>
    /**
     * Choose, which ItemImage to update.
     */
    where: ItemImageWhereUniqueInput
  }

  /**
   * ItemImage updateMany
   */
  export type ItemImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemImages.
     */
    data: XOR<ItemImageUpdateManyMutationInput, ItemImageUncheckedUpdateManyInput>
    /**
     * Filter which ItemImages to update
     */
    where?: ItemImageWhereInput
  }

  /**
   * ItemImage upsert
   */
  export type ItemImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemImage
     */
    select?: ItemImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemImage
     */
    omit?: ItemImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemImageInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemImage to update in case it exists.
     */
    where: ItemImageWhereUniqueInput
    /**
     * In case the ItemImage found by the `where` argument doesn't exist, create a new ItemImage with this data.
     */
    create: XOR<ItemImageCreateInput, ItemImageUncheckedCreateInput>
    /**
     * In case the ItemImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemImageUpdateInput, ItemImageUncheckedUpdateInput>
  }

  /**
   * ItemImage delete
   */
  export type ItemImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemImage
     */
    select?: ItemImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemImage
     */
    omit?: ItemImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemImageInclude<ExtArgs> | null
    /**
     * Filter which ItemImage to delete.
     */
    where: ItemImageWhereUniqueInput
  }

  /**
   * ItemImage deleteMany
   */
  export type ItemImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemImages to delete
     */
    where?: ItemImageWhereInput
  }

  /**
   * ItemImage without action
   */
  export type ItemImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemImage
     */
    select?: ItemImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemImage
     */
    omit?: ItemImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemImageInclude<ExtArgs> | null
  }


  /**
   * Model ItemPrice
   */

  export type AggregateItemPrice = {
    _count: ItemPriceCountAggregateOutputType | null
    _avg: ItemPriceAvgAggregateOutputType | null
    _sum: ItemPriceSumAggregateOutputType | null
    _min: ItemPriceMinAggregateOutputType | null
    _max: ItemPriceMaxAggregateOutputType | null
  }

  export type ItemPriceAvgAggregateOutputType = {
    id: number | null
    itemVariantId: number | null
    price: Decimal | null
    dayOfWeek: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
  }

  export type ItemPriceSumAggregateOutputType = {
    id: bigint | null
    itemVariantId: bigint | null
    price: Decimal | null
    dayOfWeek: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
  }

  export type ItemPriceMinAggregateOutputType = {
    id: bigint | null
    itemVariantId: bigint | null
    price: Decimal | null
    priceType: $Enums.PriceType | null
    startDate: Date | null
    endDate: Date | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ItemPriceMaxAggregateOutputType = {
    id: bigint | null
    itemVariantId: bigint | null
    price: Decimal | null
    priceType: $Enums.PriceType | null
    startDate: Date | null
    endDate: Date | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ItemPriceCountAggregateOutputType = {
    id: number
    itemVariantId: number
    price: number
    priceType: number
    startDate: number
    endDate: number
    dayOfWeek: number
    startTime: number
    endTime: number
    createdBy: number
    updatedBy: number
    deletedBy: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ItemPriceAvgAggregateInputType = {
    id?: true
    itemVariantId?: true
    price?: true
    dayOfWeek?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
  }

  export type ItemPriceSumAggregateInputType = {
    id?: true
    itemVariantId?: true
    price?: true
    dayOfWeek?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
  }

  export type ItemPriceMinAggregateInputType = {
    id?: true
    itemVariantId?: true
    price?: true
    priceType?: true
    startDate?: true
    endDate?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ItemPriceMaxAggregateInputType = {
    id?: true
    itemVariantId?: true
    price?: true
    priceType?: true
    startDate?: true
    endDate?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ItemPriceCountAggregateInputType = {
    id?: true
    itemVariantId?: true
    price?: true
    priceType?: true
    startDate?: true
    endDate?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ItemPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemPrice to aggregate.
     */
    where?: ItemPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemPrices to fetch.
     */
    orderBy?: ItemPriceOrderByWithRelationInput | ItemPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemPrices
    **/
    _count?: true | ItemPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemPriceMaxAggregateInputType
  }

  export type GetItemPriceAggregateType<T extends ItemPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateItemPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemPrice[P]>
      : GetScalarType<T[P], AggregateItemPrice[P]>
  }




  export type ItemPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemPriceWhereInput
    orderBy?: ItemPriceOrderByWithAggregationInput | ItemPriceOrderByWithAggregationInput[]
    by: ItemPriceScalarFieldEnum[] | ItemPriceScalarFieldEnum
    having?: ItemPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemPriceCountAggregateInputType | true
    _avg?: ItemPriceAvgAggregateInputType
    _sum?: ItemPriceSumAggregateInputType
    _min?: ItemPriceMinAggregateInputType
    _max?: ItemPriceMaxAggregateInputType
  }

  export type ItemPriceGroupByOutputType = {
    id: bigint
    itemVariantId: bigint
    price: Decimal
    priceType: $Enums.PriceType
    startDate: Date | null
    endDate: Date | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ItemPriceCountAggregateOutputType | null
    _avg: ItemPriceAvgAggregateOutputType | null
    _sum: ItemPriceSumAggregateOutputType | null
    _min: ItemPriceMinAggregateOutputType | null
    _max: ItemPriceMaxAggregateOutputType | null
  }

  type GetItemPriceGroupByPayload<T extends ItemPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemPriceGroupByOutputType[P]>
            : GetScalarType<T[P], ItemPriceGroupByOutputType[P]>
        }
      >
    >


  export type ItemPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemVariantId?: boolean
    price?: boolean
    priceType?: boolean
    startDate?: boolean
    endDate?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    variant?: boolean | ItemVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemPrice"]>



  export type ItemPriceSelectScalar = {
    id?: boolean
    itemVariantId?: boolean
    price?: boolean
    priceType?: boolean
    startDate?: boolean
    endDate?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ItemPriceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemVariantId" | "price" | "priceType" | "startDate" | "endDate" | "dayOfWeek" | "startTime" | "endTime" | "createdBy" | "updatedBy" | "deletedBy" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["itemPrice"]>
  export type ItemPriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | ItemVariantDefaultArgs<ExtArgs>
  }

  export type $ItemPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemPrice"
    objects: {
      variant: Prisma.$ItemVariantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      itemVariantId: bigint
      price: Prisma.Decimal
      priceType: $Enums.PriceType
      startDate: Date | null
      endDate: Date | null
      dayOfWeek: number | null
      startTime: string | null
      endTime: string | null
      createdBy: number | null
      updatedBy: number | null
      deletedBy: number | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["itemPrice"]>
    composites: {}
  }

  type ItemPriceGetPayload<S extends boolean | null | undefined | ItemPriceDefaultArgs> = $Result.GetResult<Prisma.$ItemPricePayload, S>

  type ItemPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemPriceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemPriceCountAggregateInputType | true
    }

  export interface ItemPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemPrice'], meta: { name: 'ItemPrice' } }
    /**
     * Find zero or one ItemPrice that matches the filter.
     * @param {ItemPriceFindUniqueArgs} args - Arguments to find a ItemPrice
     * @example
     * // Get one ItemPrice
     * const itemPrice = await prisma.itemPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemPriceFindUniqueArgs>(args: SelectSubset<T, ItemPriceFindUniqueArgs<ExtArgs>>): Prisma__ItemPriceClient<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ItemPrice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemPriceFindUniqueOrThrowArgs} args - Arguments to find a ItemPrice
     * @example
     * // Get one ItemPrice
     * const itemPrice = await prisma.itemPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemPriceFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemPriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemPriceClient<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ItemPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPriceFindFirstArgs} args - Arguments to find a ItemPrice
     * @example
     * // Get one ItemPrice
     * const itemPrice = await prisma.itemPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemPriceFindFirstArgs>(args?: SelectSubset<T, ItemPriceFindFirstArgs<ExtArgs>>): Prisma__ItemPriceClient<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ItemPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPriceFindFirstOrThrowArgs} args - Arguments to find a ItemPrice
     * @example
     * // Get one ItemPrice
     * const itemPrice = await prisma.itemPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemPriceFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemPriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemPriceClient<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ItemPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemPrices
     * const itemPrices = await prisma.itemPrice.findMany()
     * 
     * // Get first 10 ItemPrices
     * const itemPrices = await prisma.itemPrice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemPriceWithIdOnly = await prisma.itemPrice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemPriceFindManyArgs>(args?: SelectSubset<T, ItemPriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ItemPrice.
     * @param {ItemPriceCreateArgs} args - Arguments to create a ItemPrice.
     * @example
     * // Create one ItemPrice
     * const ItemPrice = await prisma.itemPrice.create({
     *   data: {
     *     // ... data to create a ItemPrice
     *   }
     * })
     * 
     */
    create<T extends ItemPriceCreateArgs>(args: SelectSubset<T, ItemPriceCreateArgs<ExtArgs>>): Prisma__ItemPriceClient<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ItemPrices.
     * @param {ItemPriceCreateManyArgs} args - Arguments to create many ItemPrices.
     * @example
     * // Create many ItemPrices
     * const itemPrice = await prisma.itemPrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemPriceCreateManyArgs>(args?: SelectSubset<T, ItemPriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemPrice.
     * @param {ItemPriceDeleteArgs} args - Arguments to delete one ItemPrice.
     * @example
     * // Delete one ItemPrice
     * const ItemPrice = await prisma.itemPrice.delete({
     *   where: {
     *     // ... filter to delete one ItemPrice
     *   }
     * })
     * 
     */
    delete<T extends ItemPriceDeleteArgs>(args: SelectSubset<T, ItemPriceDeleteArgs<ExtArgs>>): Prisma__ItemPriceClient<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ItemPrice.
     * @param {ItemPriceUpdateArgs} args - Arguments to update one ItemPrice.
     * @example
     * // Update one ItemPrice
     * const itemPrice = await prisma.itemPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemPriceUpdateArgs>(args: SelectSubset<T, ItemPriceUpdateArgs<ExtArgs>>): Prisma__ItemPriceClient<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ItemPrices.
     * @param {ItemPriceDeleteManyArgs} args - Arguments to filter ItemPrices to delete.
     * @example
     * // Delete a few ItemPrices
     * const { count } = await prisma.itemPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemPriceDeleteManyArgs>(args?: SelectSubset<T, ItemPriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemPrices
     * const itemPrice = await prisma.itemPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemPriceUpdateManyArgs>(args: SelectSubset<T, ItemPriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemPrice.
     * @param {ItemPriceUpsertArgs} args - Arguments to update or create a ItemPrice.
     * @example
     * // Update or create a ItemPrice
     * const itemPrice = await prisma.itemPrice.upsert({
     *   create: {
     *     // ... data to create a ItemPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemPrice we want to update
     *   }
     * })
     */
    upsert<T extends ItemPriceUpsertArgs>(args: SelectSubset<T, ItemPriceUpsertArgs<ExtArgs>>): Prisma__ItemPriceClient<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ItemPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPriceCountArgs} args - Arguments to filter ItemPrices to count.
     * @example
     * // Count the number of ItemPrices
     * const count = await prisma.itemPrice.count({
     *   where: {
     *     // ... the filter for the ItemPrices we want to count
     *   }
     * })
    **/
    count<T extends ItemPriceCountArgs>(
      args?: Subset<T, ItemPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemPriceAggregateArgs>(args: Subset<T, ItemPriceAggregateArgs>): Prisma.PrismaPromise<GetItemPriceAggregateType<T>>

    /**
     * Group by ItemPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemPriceGroupByArgs['orderBy'] }
        : { orderBy?: ItemPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemPrice model
   */
  readonly fields: ItemPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variant<T extends ItemVariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemVariantDefaultArgs<ExtArgs>>): Prisma__ItemVariantClient<$Result.GetResult<Prisma.$ItemVariantPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemPrice model
   */ 
  interface ItemPriceFieldRefs {
    readonly id: FieldRef<"ItemPrice", 'BigInt'>
    readonly itemVariantId: FieldRef<"ItemPrice", 'BigInt'>
    readonly price: FieldRef<"ItemPrice", 'Decimal'>
    readonly priceType: FieldRef<"ItemPrice", 'PriceType'>
    readonly startDate: FieldRef<"ItemPrice", 'DateTime'>
    readonly endDate: FieldRef<"ItemPrice", 'DateTime'>
    readonly dayOfWeek: FieldRef<"ItemPrice", 'Int'>
    readonly startTime: FieldRef<"ItemPrice", 'String'>
    readonly endTime: FieldRef<"ItemPrice", 'String'>
    readonly createdBy: FieldRef<"ItemPrice", 'Int'>
    readonly updatedBy: FieldRef<"ItemPrice", 'Int'>
    readonly deletedBy: FieldRef<"ItemPrice", 'Int'>
    readonly createdAt: FieldRef<"ItemPrice", 'DateTime'>
    readonly updatedAt: FieldRef<"ItemPrice", 'DateTime'>
    readonly deletedAt: FieldRef<"ItemPrice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemPrice findUnique
   */
  export type ItemPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which ItemPrice to fetch.
     */
    where: ItemPriceWhereUniqueInput
  }

  /**
   * ItemPrice findUniqueOrThrow
   */
  export type ItemPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which ItemPrice to fetch.
     */
    where: ItemPriceWhereUniqueInput
  }

  /**
   * ItemPrice findFirst
   */
  export type ItemPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which ItemPrice to fetch.
     */
    where?: ItemPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemPrices to fetch.
     */
    orderBy?: ItemPriceOrderByWithRelationInput | ItemPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemPrices.
     */
    cursor?: ItemPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemPrices.
     */
    distinct?: ItemPriceScalarFieldEnum | ItemPriceScalarFieldEnum[]
  }

  /**
   * ItemPrice findFirstOrThrow
   */
  export type ItemPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which ItemPrice to fetch.
     */
    where?: ItemPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemPrices to fetch.
     */
    orderBy?: ItemPriceOrderByWithRelationInput | ItemPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemPrices.
     */
    cursor?: ItemPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemPrices.
     */
    distinct?: ItemPriceScalarFieldEnum | ItemPriceScalarFieldEnum[]
  }

  /**
   * ItemPrice findMany
   */
  export type ItemPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which ItemPrices to fetch.
     */
    where?: ItemPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemPrices to fetch.
     */
    orderBy?: ItemPriceOrderByWithRelationInput | ItemPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemPrices.
     */
    cursor?: ItemPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemPrices.
     */
    skip?: number
    distinct?: ItemPriceScalarFieldEnum | ItemPriceScalarFieldEnum[]
  }

  /**
   * ItemPrice create
   */
  export type ItemPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemPrice.
     */
    data: XOR<ItemPriceCreateInput, ItemPriceUncheckedCreateInput>
  }

  /**
   * ItemPrice createMany
   */
  export type ItemPriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemPrices.
     */
    data: ItemPriceCreateManyInput | ItemPriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemPrice update
   */
  export type ItemPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemPrice.
     */
    data: XOR<ItemPriceUpdateInput, ItemPriceUncheckedUpdateInput>
    /**
     * Choose, which ItemPrice to update.
     */
    where: ItemPriceWhereUniqueInput
  }

  /**
   * ItemPrice updateMany
   */
  export type ItemPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemPrices.
     */
    data: XOR<ItemPriceUpdateManyMutationInput, ItemPriceUncheckedUpdateManyInput>
    /**
     * Filter which ItemPrices to update
     */
    where?: ItemPriceWhereInput
  }

  /**
   * ItemPrice upsert
   */
  export type ItemPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemPrice to update in case it exists.
     */
    where: ItemPriceWhereUniqueInput
    /**
     * In case the ItemPrice found by the `where` argument doesn't exist, create a new ItemPrice with this data.
     */
    create: XOR<ItemPriceCreateInput, ItemPriceUncheckedCreateInput>
    /**
     * In case the ItemPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemPriceUpdateInput, ItemPriceUncheckedUpdateInput>
  }

  /**
   * ItemPrice delete
   */
  export type ItemPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    /**
     * Filter which ItemPrice to delete.
     */
    where: ItemPriceWhereUniqueInput
  }

  /**
   * ItemPrice deleteMany
   */
  export type ItemPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemPrices to delete
     */
    where?: ItemPriceWhereInput
  }

  /**
   * ItemPrice without action
   */
  export type ItemPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
  }


  /**
   * Model ItemType
   */

  export type AggregateItemType = {
    _count: ItemTypeCountAggregateOutputType | null
    _avg: ItemTypeAvgAggregateOutputType | null
    _sum: ItemTypeSumAggregateOutputType | null
    _min: ItemTypeMinAggregateOutputType | null
    _max: ItemTypeMaxAggregateOutputType | null
  }

  export type ItemTypeAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
  }

  export type ItemTypeSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
  }

  export type ItemTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ItemTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ItemTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdBy: number
    updatedBy: number
    deletedBy: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ItemTypeAvgAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
  }

  export type ItemTypeSumAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
  }

  export type ItemTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ItemTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ItemTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ItemTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemType to aggregate.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemTypes
    **/
    _count?: true | ItemTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemTypeMaxAggregateInputType
  }

  export type GetItemTypeAggregateType<T extends ItemTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateItemType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemType[P]>
      : GetScalarType<T[P], AggregateItemType[P]>
  }




  export type ItemTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemTypeWhereInput
    orderBy?: ItemTypeOrderByWithAggregationInput | ItemTypeOrderByWithAggregationInput[]
    by: ItemTypeScalarFieldEnum[] | ItemTypeScalarFieldEnum
    having?: ItemTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemTypeCountAggregateInputType | true
    _avg?: ItemTypeAvgAggregateInputType
    _sum?: ItemTypeSumAggregateInputType
    _min?: ItemTypeMinAggregateInputType
    _max?: ItemTypeMaxAggregateInputType
  }

  export type ItemTypeGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ItemTypeCountAggregateOutputType | null
    _avg: ItemTypeAvgAggregateOutputType | null
    _sum: ItemTypeSumAggregateOutputType | null
    _min: ItemTypeMinAggregateOutputType | null
    _max: ItemTypeMaxAggregateOutputType | null
  }

  type GetItemTypeGroupByPayload<T extends ItemTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ItemTypeGroupByOutputType[P]>
        }
      >
    >


  export type ItemTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    items?: boolean | ItemType$itemsArgs<ExtArgs>
    _count?: boolean | ItemTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemType"]>



  export type ItemTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ItemTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdBy" | "updatedBy" | "deletedBy" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["itemType"]>
  export type ItemTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ItemType$itemsArgs<ExtArgs>
    _count?: boolean | ItemTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ItemTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemType"
    objects: {
      items: Prisma.$ItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdBy: number | null
      updatedBy: number | null
      deletedBy: number | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["itemType"]>
    composites: {}
  }

  type ItemTypeGetPayload<S extends boolean | null | undefined | ItemTypeDefaultArgs> = $Result.GetResult<Prisma.$ItemTypePayload, S>

  type ItemTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemTypeCountAggregateInputType | true
    }

  export interface ItemTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemType'], meta: { name: 'ItemType' } }
    /**
     * Find zero or one ItemType that matches the filter.
     * @param {ItemTypeFindUniqueArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemTypeFindUniqueArgs>(args: SelectSubset<T, ItemTypeFindUniqueArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ItemType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemTypeFindUniqueOrThrowArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ItemType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindFirstArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemTypeFindFirstArgs>(args?: SelectSubset<T, ItemTypeFindFirstArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ItemType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindFirstOrThrowArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ItemTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemTypes
     * const itemTypes = await prisma.itemType.findMany()
     * 
     * // Get first 10 ItemTypes
     * const itemTypes = await prisma.itemType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemTypeWithIdOnly = await prisma.itemType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemTypeFindManyArgs>(args?: SelectSubset<T, ItemTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ItemType.
     * @param {ItemTypeCreateArgs} args - Arguments to create a ItemType.
     * @example
     * // Create one ItemType
     * const ItemType = await prisma.itemType.create({
     *   data: {
     *     // ... data to create a ItemType
     *   }
     * })
     * 
     */
    create<T extends ItemTypeCreateArgs>(args: SelectSubset<T, ItemTypeCreateArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ItemTypes.
     * @param {ItemTypeCreateManyArgs} args - Arguments to create many ItemTypes.
     * @example
     * // Create many ItemTypes
     * const itemType = await prisma.itemType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemTypeCreateManyArgs>(args?: SelectSubset<T, ItemTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemType.
     * @param {ItemTypeDeleteArgs} args - Arguments to delete one ItemType.
     * @example
     * // Delete one ItemType
     * const ItemType = await prisma.itemType.delete({
     *   where: {
     *     // ... filter to delete one ItemType
     *   }
     * })
     * 
     */
    delete<T extends ItemTypeDeleteArgs>(args: SelectSubset<T, ItemTypeDeleteArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ItemType.
     * @param {ItemTypeUpdateArgs} args - Arguments to update one ItemType.
     * @example
     * // Update one ItemType
     * const itemType = await prisma.itemType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemTypeUpdateArgs>(args: SelectSubset<T, ItemTypeUpdateArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ItemTypes.
     * @param {ItemTypeDeleteManyArgs} args - Arguments to filter ItemTypes to delete.
     * @example
     * // Delete a few ItemTypes
     * const { count } = await prisma.itemType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemTypeDeleteManyArgs>(args?: SelectSubset<T, ItemTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemTypes
     * const itemType = await prisma.itemType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemTypeUpdateManyArgs>(args: SelectSubset<T, ItemTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemType.
     * @param {ItemTypeUpsertArgs} args - Arguments to update or create a ItemType.
     * @example
     * // Update or create a ItemType
     * const itemType = await prisma.itemType.upsert({
     *   create: {
     *     // ... data to create a ItemType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemType we want to update
     *   }
     * })
     */
    upsert<T extends ItemTypeUpsertArgs>(args: SelectSubset<T, ItemTypeUpsertArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ItemTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeCountArgs} args - Arguments to filter ItemTypes to count.
     * @example
     * // Count the number of ItemTypes
     * const count = await prisma.itemType.count({
     *   where: {
     *     // ... the filter for the ItemTypes we want to count
     *   }
     * })
    **/
    count<T extends ItemTypeCountArgs>(
      args?: Subset<T, ItemTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemTypeAggregateArgs>(args: Subset<T, ItemTypeAggregateArgs>): Prisma.PrismaPromise<GetItemTypeAggregateType<T>>

    /**
     * Group by ItemType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemTypeGroupByArgs['orderBy'] }
        : { orderBy?: ItemTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemType model
   */
  readonly fields: ItemTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends ItemType$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemType$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemType model
   */ 
  interface ItemTypeFieldRefs {
    readonly id: FieldRef<"ItemType", 'Int'>
    readonly name: FieldRef<"ItemType", 'String'>
    readonly description: FieldRef<"ItemType", 'String'>
    readonly createdBy: FieldRef<"ItemType", 'Int'>
    readonly updatedBy: FieldRef<"ItemType", 'Int'>
    readonly deletedBy: FieldRef<"ItemType", 'Int'>
    readonly createdAt: FieldRef<"ItemType", 'DateTime'>
    readonly updatedAt: FieldRef<"ItemType", 'DateTime'>
    readonly deletedAt: FieldRef<"ItemType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemType findUnique
   */
  export type ItemTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where: ItemTypeWhereUniqueInput
  }

  /**
   * ItemType findUniqueOrThrow
   */
  export type ItemTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where: ItemTypeWhereUniqueInput
  }

  /**
   * ItemType findFirst
   */
  export type ItemTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTypes.
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTypes.
     */
    distinct?: ItemTypeScalarFieldEnum | ItemTypeScalarFieldEnum[]
  }

  /**
   * ItemType findFirstOrThrow
   */
  export type ItemTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTypes.
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTypes.
     */
    distinct?: ItemTypeScalarFieldEnum | ItemTypeScalarFieldEnum[]
  }

  /**
   * ItemType findMany
   */
  export type ItemTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemTypes to fetch.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemTypes.
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    distinct?: ItemTypeScalarFieldEnum | ItemTypeScalarFieldEnum[]
  }

  /**
   * ItemType create
   */
  export type ItemTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemType.
     */
    data: XOR<ItemTypeCreateInput, ItemTypeUncheckedCreateInput>
  }

  /**
   * ItemType createMany
   */
  export type ItemTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemTypes.
     */
    data: ItemTypeCreateManyInput | ItemTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemType update
   */
  export type ItemTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemType.
     */
    data: XOR<ItemTypeUpdateInput, ItemTypeUncheckedUpdateInput>
    /**
     * Choose, which ItemType to update.
     */
    where: ItemTypeWhereUniqueInput
  }

  /**
   * ItemType updateMany
   */
  export type ItemTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemTypes.
     */
    data: XOR<ItemTypeUpdateManyMutationInput, ItemTypeUncheckedUpdateManyInput>
    /**
     * Filter which ItemTypes to update
     */
    where?: ItemTypeWhereInput
  }

  /**
   * ItemType upsert
   */
  export type ItemTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemType to update in case it exists.
     */
    where: ItemTypeWhereUniqueInput
    /**
     * In case the ItemType found by the `where` argument doesn't exist, create a new ItemType with this data.
     */
    create: XOR<ItemTypeCreateInput, ItemTypeUncheckedCreateInput>
    /**
     * In case the ItemType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemTypeUpdateInput, ItemTypeUncheckedUpdateInput>
  }

  /**
   * ItemType delete
   */
  export type ItemTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter which ItemType to delete.
     */
    where: ItemTypeWhereUniqueInput
  }

  /**
   * ItemType deleteMany
   */
  export type ItemTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemTypes to delete
     */
    where?: ItemTypeWhereInput
  }

  /**
   * ItemType.items
   */
  export type ItemType$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * ItemType without action
   */
  export type ItemTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
  }


  /**
   * Model ItemUpdateHistory
   */

  export type AggregateItemUpdateHistory = {
    _count: ItemUpdateHistoryCountAggregateOutputType | null
    _avg: ItemUpdateHistoryAvgAggregateOutputType | null
    _sum: ItemUpdateHistorySumAggregateOutputType | null
    _min: ItemUpdateHistoryMinAggregateOutputType | null
    _max: ItemUpdateHistoryMaxAggregateOutputType | null
  }

  export type ItemUpdateHistoryAvgAggregateOutputType = {
    id: number | null
    itemId: number | null
    userId: number | null
  }

  export type ItemUpdateHistorySumAggregateOutputType = {
    id: bigint | null
    itemId: bigint | null
    userId: number | null
  }

  export type ItemUpdateHistoryMinAggregateOutputType = {
    id: bigint | null
    itemId: bigint | null
    itemName: string | null
    userId: number | null
    userName: string | null
    columnName: string | null
    createdAt: Date | null
  }

  export type ItemUpdateHistoryMaxAggregateOutputType = {
    id: bigint | null
    itemId: bigint | null
    itemName: string | null
    userId: number | null
    userName: string | null
    columnName: string | null
    createdAt: Date | null
  }

  export type ItemUpdateHistoryCountAggregateOutputType = {
    id: number
    itemId: number
    itemName: number
    userId: number
    userName: number
    columnName: number
    createdAt: number
    _all: number
  }


  export type ItemUpdateHistoryAvgAggregateInputType = {
    id?: true
    itemId?: true
    userId?: true
  }

  export type ItemUpdateHistorySumAggregateInputType = {
    id?: true
    itemId?: true
    userId?: true
  }

  export type ItemUpdateHistoryMinAggregateInputType = {
    id?: true
    itemId?: true
    itemName?: true
    userId?: true
    userName?: true
    columnName?: true
    createdAt?: true
  }

  export type ItemUpdateHistoryMaxAggregateInputType = {
    id?: true
    itemId?: true
    itemName?: true
    userId?: true
    userName?: true
    columnName?: true
    createdAt?: true
  }

  export type ItemUpdateHistoryCountAggregateInputType = {
    id?: true
    itemId?: true
    itemName?: true
    userId?: true
    userName?: true
    columnName?: true
    createdAt?: true
    _all?: true
  }

  export type ItemUpdateHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemUpdateHistory to aggregate.
     */
    where?: ItemUpdateHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemUpdateHistories to fetch.
     */
    orderBy?: ItemUpdateHistoryOrderByWithRelationInput | ItemUpdateHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemUpdateHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemUpdateHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemUpdateHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemUpdateHistories
    **/
    _count?: true | ItemUpdateHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemUpdateHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemUpdateHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemUpdateHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemUpdateHistoryMaxAggregateInputType
  }

  export type GetItemUpdateHistoryAggregateType<T extends ItemUpdateHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateItemUpdateHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemUpdateHistory[P]>
      : GetScalarType<T[P], AggregateItemUpdateHistory[P]>
  }




  export type ItemUpdateHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemUpdateHistoryWhereInput
    orderBy?: ItemUpdateHistoryOrderByWithAggregationInput | ItemUpdateHistoryOrderByWithAggregationInput[]
    by: ItemUpdateHistoryScalarFieldEnum[] | ItemUpdateHistoryScalarFieldEnum
    having?: ItemUpdateHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemUpdateHistoryCountAggregateInputType | true
    _avg?: ItemUpdateHistoryAvgAggregateInputType
    _sum?: ItemUpdateHistorySumAggregateInputType
    _min?: ItemUpdateHistoryMinAggregateInputType
    _max?: ItemUpdateHistoryMaxAggregateInputType
  }

  export type ItemUpdateHistoryGroupByOutputType = {
    id: bigint
    itemId: bigint
    itemName: string
    userId: number
    userName: string
    columnName: string
    createdAt: Date
    _count: ItemUpdateHistoryCountAggregateOutputType | null
    _avg: ItemUpdateHistoryAvgAggregateOutputType | null
    _sum: ItemUpdateHistorySumAggregateOutputType | null
    _min: ItemUpdateHistoryMinAggregateOutputType | null
    _max: ItemUpdateHistoryMaxAggregateOutputType | null
  }

  type GetItemUpdateHistoryGroupByPayload<T extends ItemUpdateHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemUpdateHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemUpdateHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemUpdateHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ItemUpdateHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ItemUpdateHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    itemName?: boolean
    userId?: boolean
    userName?: boolean
    columnName?: boolean
    createdAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemUpdateHistory"]>



  export type ItemUpdateHistorySelectScalar = {
    id?: boolean
    itemId?: boolean
    itemName?: boolean
    userId?: boolean
    userName?: boolean
    columnName?: boolean
    createdAt?: boolean
  }

  export type ItemUpdateHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemId" | "itemName" | "userId" | "userName" | "columnName" | "createdAt", ExtArgs["result"]["itemUpdateHistory"]>
  export type ItemUpdateHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $ItemUpdateHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemUpdateHistory"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      itemId: bigint
      itemName: string
      userId: number
      userName: string
      columnName: string
      createdAt: Date
    }, ExtArgs["result"]["itemUpdateHistory"]>
    composites: {}
  }

  type ItemUpdateHistoryGetPayload<S extends boolean | null | undefined | ItemUpdateHistoryDefaultArgs> = $Result.GetResult<Prisma.$ItemUpdateHistoryPayload, S>

  type ItemUpdateHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemUpdateHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemUpdateHistoryCountAggregateInputType | true
    }

  export interface ItemUpdateHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemUpdateHistory'], meta: { name: 'ItemUpdateHistory' } }
    /**
     * Find zero or one ItemUpdateHistory that matches the filter.
     * @param {ItemUpdateHistoryFindUniqueArgs} args - Arguments to find a ItemUpdateHistory
     * @example
     * // Get one ItemUpdateHistory
     * const itemUpdateHistory = await prisma.itemUpdateHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemUpdateHistoryFindUniqueArgs>(args: SelectSubset<T, ItemUpdateHistoryFindUniqueArgs<ExtArgs>>): Prisma__ItemUpdateHistoryClient<$Result.GetResult<Prisma.$ItemUpdateHistoryPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ItemUpdateHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemUpdateHistoryFindUniqueOrThrowArgs} args - Arguments to find a ItemUpdateHistory
     * @example
     * // Get one ItemUpdateHistory
     * const itemUpdateHistory = await prisma.itemUpdateHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemUpdateHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemUpdateHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemUpdateHistoryClient<$Result.GetResult<Prisma.$ItemUpdateHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ItemUpdateHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateHistoryFindFirstArgs} args - Arguments to find a ItemUpdateHistory
     * @example
     * // Get one ItemUpdateHistory
     * const itemUpdateHistory = await prisma.itemUpdateHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemUpdateHistoryFindFirstArgs>(args?: SelectSubset<T, ItemUpdateHistoryFindFirstArgs<ExtArgs>>): Prisma__ItemUpdateHistoryClient<$Result.GetResult<Prisma.$ItemUpdateHistoryPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ItemUpdateHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateHistoryFindFirstOrThrowArgs} args - Arguments to find a ItemUpdateHistory
     * @example
     * // Get one ItemUpdateHistory
     * const itemUpdateHistory = await prisma.itemUpdateHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemUpdateHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemUpdateHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemUpdateHistoryClient<$Result.GetResult<Prisma.$ItemUpdateHistoryPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ItemUpdateHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemUpdateHistories
     * const itemUpdateHistories = await prisma.itemUpdateHistory.findMany()
     * 
     * // Get first 10 ItemUpdateHistories
     * const itemUpdateHistories = await prisma.itemUpdateHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemUpdateHistoryWithIdOnly = await prisma.itemUpdateHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemUpdateHistoryFindManyArgs>(args?: SelectSubset<T, ItemUpdateHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemUpdateHistoryPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ItemUpdateHistory.
     * @param {ItemUpdateHistoryCreateArgs} args - Arguments to create a ItemUpdateHistory.
     * @example
     * // Create one ItemUpdateHistory
     * const ItemUpdateHistory = await prisma.itemUpdateHistory.create({
     *   data: {
     *     // ... data to create a ItemUpdateHistory
     *   }
     * })
     * 
     */
    create<T extends ItemUpdateHistoryCreateArgs>(args: SelectSubset<T, ItemUpdateHistoryCreateArgs<ExtArgs>>): Prisma__ItemUpdateHistoryClient<$Result.GetResult<Prisma.$ItemUpdateHistoryPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ItemUpdateHistories.
     * @param {ItemUpdateHistoryCreateManyArgs} args - Arguments to create many ItemUpdateHistories.
     * @example
     * // Create many ItemUpdateHistories
     * const itemUpdateHistory = await prisma.itemUpdateHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemUpdateHistoryCreateManyArgs>(args?: SelectSubset<T, ItemUpdateHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemUpdateHistory.
     * @param {ItemUpdateHistoryDeleteArgs} args - Arguments to delete one ItemUpdateHistory.
     * @example
     * // Delete one ItemUpdateHistory
     * const ItemUpdateHistory = await prisma.itemUpdateHistory.delete({
     *   where: {
     *     // ... filter to delete one ItemUpdateHistory
     *   }
     * })
     * 
     */
    delete<T extends ItemUpdateHistoryDeleteArgs>(args: SelectSubset<T, ItemUpdateHistoryDeleteArgs<ExtArgs>>): Prisma__ItemUpdateHistoryClient<$Result.GetResult<Prisma.$ItemUpdateHistoryPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ItemUpdateHistory.
     * @param {ItemUpdateHistoryUpdateArgs} args - Arguments to update one ItemUpdateHistory.
     * @example
     * // Update one ItemUpdateHistory
     * const itemUpdateHistory = await prisma.itemUpdateHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateHistoryUpdateArgs>(args: SelectSubset<T, ItemUpdateHistoryUpdateArgs<ExtArgs>>): Prisma__ItemUpdateHistoryClient<$Result.GetResult<Prisma.$ItemUpdateHistoryPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ItemUpdateHistories.
     * @param {ItemUpdateHistoryDeleteManyArgs} args - Arguments to filter ItemUpdateHistories to delete.
     * @example
     * // Delete a few ItemUpdateHistories
     * const { count } = await prisma.itemUpdateHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemUpdateHistoryDeleteManyArgs>(args?: SelectSubset<T, ItemUpdateHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemUpdateHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemUpdateHistories
     * const itemUpdateHistory = await prisma.itemUpdateHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateHistoryUpdateManyArgs>(args: SelectSubset<T, ItemUpdateHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemUpdateHistory.
     * @param {ItemUpdateHistoryUpsertArgs} args - Arguments to update or create a ItemUpdateHistory.
     * @example
     * // Update or create a ItemUpdateHistory
     * const itemUpdateHistory = await prisma.itemUpdateHistory.upsert({
     *   create: {
     *     // ... data to create a ItemUpdateHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemUpdateHistory we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpdateHistoryUpsertArgs>(args: SelectSubset<T, ItemUpdateHistoryUpsertArgs<ExtArgs>>): Prisma__ItemUpdateHistoryClient<$Result.GetResult<Prisma.$ItemUpdateHistoryPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ItemUpdateHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateHistoryCountArgs} args - Arguments to filter ItemUpdateHistories to count.
     * @example
     * // Count the number of ItemUpdateHistories
     * const count = await prisma.itemUpdateHistory.count({
     *   where: {
     *     // ... the filter for the ItemUpdateHistories we want to count
     *   }
     * })
    **/
    count<T extends ItemUpdateHistoryCountArgs>(
      args?: Subset<T, ItemUpdateHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemUpdateHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemUpdateHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemUpdateHistoryAggregateArgs>(args: Subset<T, ItemUpdateHistoryAggregateArgs>): Prisma.PrismaPromise<GetItemUpdateHistoryAggregateType<T>>

    /**
     * Group by ItemUpdateHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemUpdateHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemUpdateHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ItemUpdateHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemUpdateHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemUpdateHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemUpdateHistory model
   */
  readonly fields: ItemUpdateHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemUpdateHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemUpdateHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemUpdateHistory model
   */ 
  interface ItemUpdateHistoryFieldRefs {
    readonly id: FieldRef<"ItemUpdateHistory", 'BigInt'>
    readonly itemId: FieldRef<"ItemUpdateHistory", 'BigInt'>
    readonly itemName: FieldRef<"ItemUpdateHistory", 'String'>
    readonly userId: FieldRef<"ItemUpdateHistory", 'Int'>
    readonly userName: FieldRef<"ItemUpdateHistory", 'String'>
    readonly columnName: FieldRef<"ItemUpdateHistory", 'String'>
    readonly createdAt: FieldRef<"ItemUpdateHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemUpdateHistory findUnique
   */
  export type ItemUpdateHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemUpdateHistory
     */
    select?: ItemUpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemUpdateHistory
     */
    omit?: ItemUpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemUpdateHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemUpdateHistory to fetch.
     */
    where: ItemUpdateHistoryWhereUniqueInput
  }

  /**
   * ItemUpdateHistory findUniqueOrThrow
   */
  export type ItemUpdateHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemUpdateHistory
     */
    select?: ItemUpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemUpdateHistory
     */
    omit?: ItemUpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemUpdateHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemUpdateHistory to fetch.
     */
    where: ItemUpdateHistoryWhereUniqueInput
  }

  /**
   * ItemUpdateHistory findFirst
   */
  export type ItemUpdateHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemUpdateHistory
     */
    select?: ItemUpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemUpdateHistory
     */
    omit?: ItemUpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemUpdateHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemUpdateHistory to fetch.
     */
    where?: ItemUpdateHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemUpdateHistories to fetch.
     */
    orderBy?: ItemUpdateHistoryOrderByWithRelationInput | ItemUpdateHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemUpdateHistories.
     */
    cursor?: ItemUpdateHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemUpdateHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemUpdateHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemUpdateHistories.
     */
    distinct?: ItemUpdateHistoryScalarFieldEnum | ItemUpdateHistoryScalarFieldEnum[]
  }

  /**
   * ItemUpdateHistory findFirstOrThrow
   */
  export type ItemUpdateHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemUpdateHistory
     */
    select?: ItemUpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemUpdateHistory
     */
    omit?: ItemUpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemUpdateHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemUpdateHistory to fetch.
     */
    where?: ItemUpdateHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemUpdateHistories to fetch.
     */
    orderBy?: ItemUpdateHistoryOrderByWithRelationInput | ItemUpdateHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemUpdateHistories.
     */
    cursor?: ItemUpdateHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemUpdateHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemUpdateHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemUpdateHistories.
     */
    distinct?: ItemUpdateHistoryScalarFieldEnum | ItemUpdateHistoryScalarFieldEnum[]
  }

  /**
   * ItemUpdateHistory findMany
   */
  export type ItemUpdateHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemUpdateHistory
     */
    select?: ItemUpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemUpdateHistory
     */
    omit?: ItemUpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemUpdateHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemUpdateHistories to fetch.
     */
    where?: ItemUpdateHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemUpdateHistories to fetch.
     */
    orderBy?: ItemUpdateHistoryOrderByWithRelationInput | ItemUpdateHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemUpdateHistories.
     */
    cursor?: ItemUpdateHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemUpdateHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemUpdateHistories.
     */
    skip?: number
    distinct?: ItemUpdateHistoryScalarFieldEnum | ItemUpdateHistoryScalarFieldEnum[]
  }

  /**
   * ItemUpdateHistory create
   */
  export type ItemUpdateHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemUpdateHistory
     */
    select?: ItemUpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemUpdateHistory
     */
    omit?: ItemUpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemUpdateHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemUpdateHistory.
     */
    data: XOR<ItemUpdateHistoryCreateInput, ItemUpdateHistoryUncheckedCreateInput>
  }

  /**
   * ItemUpdateHistory createMany
   */
  export type ItemUpdateHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemUpdateHistories.
     */
    data: ItemUpdateHistoryCreateManyInput | ItemUpdateHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemUpdateHistory update
   */
  export type ItemUpdateHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemUpdateHistory
     */
    select?: ItemUpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemUpdateHistory
     */
    omit?: ItemUpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemUpdateHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemUpdateHistory.
     */
    data: XOR<ItemUpdateHistoryUpdateInput, ItemUpdateHistoryUncheckedUpdateInput>
    /**
     * Choose, which ItemUpdateHistory to update.
     */
    where: ItemUpdateHistoryWhereUniqueInput
  }

  /**
   * ItemUpdateHistory updateMany
   */
  export type ItemUpdateHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemUpdateHistories.
     */
    data: XOR<ItemUpdateHistoryUpdateManyMutationInput, ItemUpdateHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ItemUpdateHistories to update
     */
    where?: ItemUpdateHistoryWhereInput
  }

  /**
   * ItemUpdateHistory upsert
   */
  export type ItemUpdateHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemUpdateHistory
     */
    select?: ItemUpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemUpdateHistory
     */
    omit?: ItemUpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemUpdateHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemUpdateHistory to update in case it exists.
     */
    where: ItemUpdateHistoryWhereUniqueInput
    /**
     * In case the ItemUpdateHistory found by the `where` argument doesn't exist, create a new ItemUpdateHistory with this data.
     */
    create: XOR<ItemUpdateHistoryCreateInput, ItemUpdateHistoryUncheckedCreateInput>
    /**
     * In case the ItemUpdateHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateHistoryUpdateInput, ItemUpdateHistoryUncheckedUpdateInput>
  }

  /**
   * ItemUpdateHistory delete
   */
  export type ItemUpdateHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemUpdateHistory
     */
    select?: ItemUpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemUpdateHistory
     */
    omit?: ItemUpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemUpdateHistoryInclude<ExtArgs> | null
    /**
     * Filter which ItemUpdateHistory to delete.
     */
    where: ItemUpdateHistoryWhereUniqueInput
  }

  /**
   * ItemUpdateHistory deleteMany
   */
  export type ItemUpdateHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemUpdateHistories to delete
     */
    where?: ItemUpdateHistoryWhereInput
  }

  /**
   * ItemUpdateHistory without action
   */
  export type ItemUpdateHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemUpdateHistory
     */
    select?: ItemUpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemUpdateHistory
     */
    omit?: ItemUpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemUpdateHistoryInclude<ExtArgs> | null
  }


  /**
   * Model ItemVariant
   */

  export type AggregateItemVariant = {
    _count: ItemVariantCountAggregateOutputType | null
    _avg: ItemVariantAvgAggregateOutputType | null
    _sum: ItemVariantSumAggregateOutputType | null
    _min: ItemVariantMinAggregateOutputType | null
    _max: ItemVariantMaxAggregateOutputType | null
  }

  export type ItemVariantAvgAggregateOutputType = {
    id: number | null
    itemId: number | null
    price: Decimal | null
    quantity: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
  }

  export type ItemVariantSumAggregateOutputType = {
    id: bigint | null
    itemId: bigint | null
    price: Decimal | null
    quantity: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
  }

  export type ItemVariantMinAggregateOutputType = {
    id: bigint | null
    itemId: bigint | null
    code: string | null
    name: string | null
    imageUrl: string | null
    price: Decimal | null
    quantity: number | null
    isActive: boolean | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ItemVariantMaxAggregateOutputType = {
    id: bigint | null
    itemId: bigint | null
    code: string | null
    name: string | null
    imageUrl: string | null
    price: Decimal | null
    quantity: number | null
    isActive: boolean | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ItemVariantCountAggregateOutputType = {
    id: number
    itemId: number
    code: number
    name: number
    imageUrl: number
    price: number
    quantity: number
    options: number
    isActive: number
    createdBy: number
    updatedBy: number
    deletedBy: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ItemVariantAvgAggregateInputType = {
    id?: true
    itemId?: true
    price?: true
    quantity?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
  }

  export type ItemVariantSumAggregateInputType = {
    id?: true
    itemId?: true
    price?: true
    quantity?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
  }

  export type ItemVariantMinAggregateInputType = {
    id?: true
    itemId?: true
    code?: true
    name?: true
    imageUrl?: true
    price?: true
    quantity?: true
    isActive?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ItemVariantMaxAggregateInputType = {
    id?: true
    itemId?: true
    code?: true
    name?: true
    imageUrl?: true
    price?: true
    quantity?: true
    isActive?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ItemVariantCountAggregateInputType = {
    id?: true
    itemId?: true
    code?: true
    name?: true
    imageUrl?: true
    price?: true
    quantity?: true
    options?: true
    isActive?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ItemVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemVariant to aggregate.
     */
    where?: ItemVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemVariants to fetch.
     */
    orderBy?: ItemVariantOrderByWithRelationInput | ItemVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemVariants
    **/
    _count?: true | ItemVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemVariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemVariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemVariantMaxAggregateInputType
  }

  export type GetItemVariantAggregateType<T extends ItemVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateItemVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemVariant[P]>
      : GetScalarType<T[P], AggregateItemVariant[P]>
  }




  export type ItemVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemVariantWhereInput
    orderBy?: ItemVariantOrderByWithAggregationInput | ItemVariantOrderByWithAggregationInput[]
    by: ItemVariantScalarFieldEnum[] | ItemVariantScalarFieldEnum
    having?: ItemVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemVariantCountAggregateInputType | true
    _avg?: ItemVariantAvgAggregateInputType
    _sum?: ItemVariantSumAggregateInputType
    _min?: ItemVariantMinAggregateInputType
    _max?: ItemVariantMaxAggregateInputType
  }

  export type ItemVariantGroupByOutputType = {
    id: bigint
    itemId: bigint
    code: string
    name: string | null
    imageUrl: string | null
    price: Decimal
    quantity: number
    options: JsonValue | null
    isActive: boolean
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ItemVariantCountAggregateOutputType | null
    _avg: ItemVariantAvgAggregateOutputType | null
    _sum: ItemVariantSumAggregateOutputType | null
    _min: ItemVariantMinAggregateOutputType | null
    _max: ItemVariantMaxAggregateOutputType | null
  }

  type GetItemVariantGroupByPayload<T extends ItemVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemVariantGroupByOutputType[P]>
            : GetScalarType<T[P], ItemVariantGroupByOutputType[P]>
        }
      >
    >


  export type ItemVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    code?: boolean
    name?: boolean
    imageUrl?: boolean
    price?: boolean
    quantity?: boolean
    options?: boolean
    isActive?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    prices?: boolean | ItemVariant$pricesArgs<ExtArgs>
    _count?: boolean | ItemVariantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemVariant"]>



  export type ItemVariantSelectScalar = {
    id?: boolean
    itemId?: boolean
    code?: boolean
    name?: boolean
    imageUrl?: boolean
    price?: boolean
    quantity?: boolean
    options?: boolean
    isActive?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ItemVariantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemId" | "code" | "name" | "imageUrl" | "price" | "quantity" | "options" | "isActive" | "createdBy" | "updatedBy" | "deletedBy" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["itemVariant"]>
  export type ItemVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    prices?: boolean | ItemVariant$pricesArgs<ExtArgs>
    _count?: boolean | ItemVariantCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ItemVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemVariant"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      prices: Prisma.$ItemPricePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      itemId: bigint
      code: string
      name: string | null
      imageUrl: string | null
      price: Prisma.Decimal
      quantity: number
      options: Prisma.JsonValue | null
      isActive: boolean
      createdBy: number | null
      updatedBy: number | null
      deletedBy: number | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["itemVariant"]>
    composites: {}
  }

  type ItemVariantGetPayload<S extends boolean | null | undefined | ItemVariantDefaultArgs> = $Result.GetResult<Prisma.$ItemVariantPayload, S>

  type ItemVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemVariantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemVariantCountAggregateInputType | true
    }

  export interface ItemVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemVariant'], meta: { name: 'ItemVariant' } }
    /**
     * Find zero or one ItemVariant that matches the filter.
     * @param {ItemVariantFindUniqueArgs} args - Arguments to find a ItemVariant
     * @example
     * // Get one ItemVariant
     * const itemVariant = await prisma.itemVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemVariantFindUniqueArgs>(args: SelectSubset<T, ItemVariantFindUniqueArgs<ExtArgs>>): Prisma__ItemVariantClient<$Result.GetResult<Prisma.$ItemVariantPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ItemVariant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemVariantFindUniqueOrThrowArgs} args - Arguments to find a ItemVariant
     * @example
     * // Get one ItemVariant
     * const itemVariant = await prisma.itemVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemVariantFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemVariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemVariantClient<$Result.GetResult<Prisma.$ItemVariantPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ItemVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemVariantFindFirstArgs} args - Arguments to find a ItemVariant
     * @example
     * // Get one ItemVariant
     * const itemVariant = await prisma.itemVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemVariantFindFirstArgs>(args?: SelectSubset<T, ItemVariantFindFirstArgs<ExtArgs>>): Prisma__ItemVariantClient<$Result.GetResult<Prisma.$ItemVariantPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ItemVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemVariantFindFirstOrThrowArgs} args - Arguments to find a ItemVariant
     * @example
     * // Get one ItemVariant
     * const itemVariant = await prisma.itemVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemVariantFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemVariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemVariantClient<$Result.GetResult<Prisma.$ItemVariantPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ItemVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemVariants
     * const itemVariants = await prisma.itemVariant.findMany()
     * 
     * // Get first 10 ItemVariants
     * const itemVariants = await prisma.itemVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemVariantWithIdOnly = await prisma.itemVariant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemVariantFindManyArgs>(args?: SelectSubset<T, ItemVariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemVariantPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ItemVariant.
     * @param {ItemVariantCreateArgs} args - Arguments to create a ItemVariant.
     * @example
     * // Create one ItemVariant
     * const ItemVariant = await prisma.itemVariant.create({
     *   data: {
     *     // ... data to create a ItemVariant
     *   }
     * })
     * 
     */
    create<T extends ItemVariantCreateArgs>(args: SelectSubset<T, ItemVariantCreateArgs<ExtArgs>>): Prisma__ItemVariantClient<$Result.GetResult<Prisma.$ItemVariantPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ItemVariants.
     * @param {ItemVariantCreateManyArgs} args - Arguments to create many ItemVariants.
     * @example
     * // Create many ItemVariants
     * const itemVariant = await prisma.itemVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemVariantCreateManyArgs>(args?: SelectSubset<T, ItemVariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemVariant.
     * @param {ItemVariantDeleteArgs} args - Arguments to delete one ItemVariant.
     * @example
     * // Delete one ItemVariant
     * const ItemVariant = await prisma.itemVariant.delete({
     *   where: {
     *     // ... filter to delete one ItemVariant
     *   }
     * })
     * 
     */
    delete<T extends ItemVariantDeleteArgs>(args: SelectSubset<T, ItemVariantDeleteArgs<ExtArgs>>): Prisma__ItemVariantClient<$Result.GetResult<Prisma.$ItemVariantPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ItemVariant.
     * @param {ItemVariantUpdateArgs} args - Arguments to update one ItemVariant.
     * @example
     * // Update one ItemVariant
     * const itemVariant = await prisma.itemVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemVariantUpdateArgs>(args: SelectSubset<T, ItemVariantUpdateArgs<ExtArgs>>): Prisma__ItemVariantClient<$Result.GetResult<Prisma.$ItemVariantPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ItemVariants.
     * @param {ItemVariantDeleteManyArgs} args - Arguments to filter ItemVariants to delete.
     * @example
     * // Delete a few ItemVariants
     * const { count } = await prisma.itemVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemVariantDeleteManyArgs>(args?: SelectSubset<T, ItemVariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemVariants
     * const itemVariant = await prisma.itemVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemVariantUpdateManyArgs>(args: SelectSubset<T, ItemVariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemVariant.
     * @param {ItemVariantUpsertArgs} args - Arguments to update or create a ItemVariant.
     * @example
     * // Update or create a ItemVariant
     * const itemVariant = await prisma.itemVariant.upsert({
     *   create: {
     *     // ... data to create a ItemVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemVariant we want to update
     *   }
     * })
     */
    upsert<T extends ItemVariantUpsertArgs>(args: SelectSubset<T, ItemVariantUpsertArgs<ExtArgs>>): Prisma__ItemVariantClient<$Result.GetResult<Prisma.$ItemVariantPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ItemVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemVariantCountArgs} args - Arguments to filter ItemVariants to count.
     * @example
     * // Count the number of ItemVariants
     * const count = await prisma.itemVariant.count({
     *   where: {
     *     // ... the filter for the ItemVariants we want to count
     *   }
     * })
    **/
    count<T extends ItemVariantCountArgs>(
      args?: Subset<T, ItemVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemVariantAggregateArgs>(args: Subset<T, ItemVariantAggregateArgs>): Prisma.PrismaPromise<GetItemVariantAggregateType<T>>

    /**
     * Group by ItemVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemVariantGroupByArgs['orderBy'] }
        : { orderBy?: ItemVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemVariant model
   */
  readonly fields: ItemVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    prices<T extends ItemVariant$pricesArgs<ExtArgs> = {}>(args?: Subset<T, ItemVariant$pricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemVariant model
   */ 
  interface ItemVariantFieldRefs {
    readonly id: FieldRef<"ItemVariant", 'BigInt'>
    readonly itemId: FieldRef<"ItemVariant", 'BigInt'>
    readonly code: FieldRef<"ItemVariant", 'String'>
    readonly name: FieldRef<"ItemVariant", 'String'>
    readonly imageUrl: FieldRef<"ItemVariant", 'String'>
    readonly price: FieldRef<"ItemVariant", 'Decimal'>
    readonly quantity: FieldRef<"ItemVariant", 'Int'>
    readonly options: FieldRef<"ItemVariant", 'Json'>
    readonly isActive: FieldRef<"ItemVariant", 'Boolean'>
    readonly createdBy: FieldRef<"ItemVariant", 'Int'>
    readonly updatedBy: FieldRef<"ItemVariant", 'Int'>
    readonly deletedBy: FieldRef<"ItemVariant", 'Int'>
    readonly createdAt: FieldRef<"ItemVariant", 'DateTime'>
    readonly updatedAt: FieldRef<"ItemVariant", 'DateTime'>
    readonly deletedAt: FieldRef<"ItemVariant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemVariant findUnique
   */
  export type ItemVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVariant
     */
    select?: ItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVariant
     */
    omit?: ItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVariantInclude<ExtArgs> | null
    /**
     * Filter, which ItemVariant to fetch.
     */
    where: ItemVariantWhereUniqueInput
  }

  /**
   * ItemVariant findUniqueOrThrow
   */
  export type ItemVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVariant
     */
    select?: ItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVariant
     */
    omit?: ItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVariantInclude<ExtArgs> | null
    /**
     * Filter, which ItemVariant to fetch.
     */
    where: ItemVariantWhereUniqueInput
  }

  /**
   * ItemVariant findFirst
   */
  export type ItemVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVariant
     */
    select?: ItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVariant
     */
    omit?: ItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVariantInclude<ExtArgs> | null
    /**
     * Filter, which ItemVariant to fetch.
     */
    where?: ItemVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemVariants to fetch.
     */
    orderBy?: ItemVariantOrderByWithRelationInput | ItemVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemVariants.
     */
    cursor?: ItemVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemVariants.
     */
    distinct?: ItemVariantScalarFieldEnum | ItemVariantScalarFieldEnum[]
  }

  /**
   * ItemVariant findFirstOrThrow
   */
  export type ItemVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVariant
     */
    select?: ItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVariant
     */
    omit?: ItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVariantInclude<ExtArgs> | null
    /**
     * Filter, which ItemVariant to fetch.
     */
    where?: ItemVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemVariants to fetch.
     */
    orderBy?: ItemVariantOrderByWithRelationInput | ItemVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemVariants.
     */
    cursor?: ItemVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemVariants.
     */
    distinct?: ItemVariantScalarFieldEnum | ItemVariantScalarFieldEnum[]
  }

  /**
   * ItemVariant findMany
   */
  export type ItemVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVariant
     */
    select?: ItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVariant
     */
    omit?: ItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVariantInclude<ExtArgs> | null
    /**
     * Filter, which ItemVariants to fetch.
     */
    where?: ItemVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemVariants to fetch.
     */
    orderBy?: ItemVariantOrderByWithRelationInput | ItemVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemVariants.
     */
    cursor?: ItemVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemVariants.
     */
    skip?: number
    distinct?: ItemVariantScalarFieldEnum | ItemVariantScalarFieldEnum[]
  }

  /**
   * ItemVariant create
   */
  export type ItemVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVariant
     */
    select?: ItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVariant
     */
    omit?: ItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemVariant.
     */
    data: XOR<ItemVariantCreateInput, ItemVariantUncheckedCreateInput>
  }

  /**
   * ItemVariant createMany
   */
  export type ItemVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemVariants.
     */
    data: ItemVariantCreateManyInput | ItemVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemVariant update
   */
  export type ItemVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVariant
     */
    select?: ItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVariant
     */
    omit?: ItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemVariant.
     */
    data: XOR<ItemVariantUpdateInput, ItemVariantUncheckedUpdateInput>
    /**
     * Choose, which ItemVariant to update.
     */
    where: ItemVariantWhereUniqueInput
  }

  /**
   * ItemVariant updateMany
   */
  export type ItemVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemVariants.
     */
    data: XOR<ItemVariantUpdateManyMutationInput, ItemVariantUncheckedUpdateManyInput>
    /**
     * Filter which ItemVariants to update
     */
    where?: ItemVariantWhereInput
  }

  /**
   * ItemVariant upsert
   */
  export type ItemVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVariant
     */
    select?: ItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVariant
     */
    omit?: ItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemVariant to update in case it exists.
     */
    where: ItemVariantWhereUniqueInput
    /**
     * In case the ItemVariant found by the `where` argument doesn't exist, create a new ItemVariant with this data.
     */
    create: XOR<ItemVariantCreateInput, ItemVariantUncheckedCreateInput>
    /**
     * In case the ItemVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemVariantUpdateInput, ItemVariantUncheckedUpdateInput>
  }

  /**
   * ItemVariant delete
   */
  export type ItemVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVariant
     */
    select?: ItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVariant
     */
    omit?: ItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVariantInclude<ExtArgs> | null
    /**
     * Filter which ItemVariant to delete.
     */
    where: ItemVariantWhereUniqueInput
  }

  /**
   * ItemVariant deleteMany
   */
  export type ItemVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemVariants to delete
     */
    where?: ItemVariantWhereInput
  }

  /**
   * ItemVariant.prices
   */
  export type ItemVariant$pricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    where?: ItemPriceWhereInput
    orderBy?: ItemPriceOrderByWithRelationInput | ItemPriceOrderByWithRelationInput[]
    cursor?: ItemPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemPriceScalarFieldEnum | ItemPriceScalarFieldEnum[]
  }

  /**
   * ItemVariant without action
   */
  export type ItemVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVariant
     */
    select?: ItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVariant
     */
    omit?: ItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVariantInclude<ExtArgs> | null
  }


  /**
   * Model ItemVideo
   */

  export type AggregateItemVideo = {
    _count: ItemVideoCountAggregateOutputType | null
    _avg: ItemVideoAvgAggregateOutputType | null
    _sum: ItemVideoSumAggregateOutputType | null
    _min: ItemVideoMinAggregateOutputType | null
    _max: ItemVideoMaxAggregateOutputType | null
  }

  export type ItemVideoAvgAggregateOutputType = {
    id: number | null
    itemId: number | null
    sortOrder: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
  }

  export type ItemVideoSumAggregateOutputType = {
    id: bigint | null
    itemId: bigint | null
    sortOrder: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
  }

  export type ItemVideoMinAggregateOutputType = {
    id: bigint | null
    itemId: bigint | null
    url: string | null
    provider: string | null
    isPrimary: boolean | null
    sortOrder: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ItemVideoMaxAggregateOutputType = {
    id: bigint | null
    itemId: bigint | null
    url: string | null
    provider: string | null
    isPrimary: boolean | null
    sortOrder: number | null
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ItemVideoCountAggregateOutputType = {
    id: number
    itemId: number
    url: number
    provider: number
    isPrimary: number
    sortOrder: number
    createdBy: number
    updatedBy: number
    deletedBy: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ItemVideoAvgAggregateInputType = {
    id?: true
    itemId?: true
    sortOrder?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
  }

  export type ItemVideoSumAggregateInputType = {
    id?: true
    itemId?: true
    sortOrder?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
  }

  export type ItemVideoMinAggregateInputType = {
    id?: true
    itemId?: true
    url?: true
    provider?: true
    isPrimary?: true
    sortOrder?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ItemVideoMaxAggregateInputType = {
    id?: true
    itemId?: true
    url?: true
    provider?: true
    isPrimary?: true
    sortOrder?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ItemVideoCountAggregateInputType = {
    id?: true
    itemId?: true
    url?: true
    provider?: true
    isPrimary?: true
    sortOrder?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ItemVideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemVideo to aggregate.
     */
    where?: ItemVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemVideos to fetch.
     */
    orderBy?: ItemVideoOrderByWithRelationInput | ItemVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemVideos
    **/
    _count?: true | ItemVideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemVideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemVideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemVideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemVideoMaxAggregateInputType
  }

  export type GetItemVideoAggregateType<T extends ItemVideoAggregateArgs> = {
        [P in keyof T & keyof AggregateItemVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemVideo[P]>
      : GetScalarType<T[P], AggregateItemVideo[P]>
  }




  export type ItemVideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemVideoWhereInput
    orderBy?: ItemVideoOrderByWithAggregationInput | ItemVideoOrderByWithAggregationInput[]
    by: ItemVideoScalarFieldEnum[] | ItemVideoScalarFieldEnum
    having?: ItemVideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemVideoCountAggregateInputType | true
    _avg?: ItemVideoAvgAggregateInputType
    _sum?: ItemVideoSumAggregateInputType
    _min?: ItemVideoMinAggregateInputType
    _max?: ItemVideoMaxAggregateInputType
  }

  export type ItemVideoGroupByOutputType = {
    id: bigint
    itemId: bigint
    url: string
    provider: string | null
    isPrimary: boolean
    sortOrder: number
    createdBy: number | null
    updatedBy: number | null
    deletedBy: number | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ItemVideoCountAggregateOutputType | null
    _avg: ItemVideoAvgAggregateOutputType | null
    _sum: ItemVideoSumAggregateOutputType | null
    _min: ItemVideoMinAggregateOutputType | null
    _max: ItemVideoMaxAggregateOutputType | null
  }

  type GetItemVideoGroupByPayload<T extends ItemVideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemVideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemVideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemVideoGroupByOutputType[P]>
            : GetScalarType<T[P], ItemVideoGroupByOutputType[P]>
        }
      >
    >


  export type ItemVideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    url?: boolean
    provider?: boolean
    isPrimary?: boolean
    sortOrder?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemVideo"]>



  export type ItemVideoSelectScalar = {
    id?: boolean
    itemId?: boolean
    url?: boolean
    provider?: boolean
    isPrimary?: boolean
    sortOrder?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ItemVideoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemId" | "url" | "provider" | "isPrimary" | "sortOrder" | "createdBy" | "updatedBy" | "deletedBy" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["itemVideo"]>
  export type ItemVideoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $ItemVideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemVideo"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      itemId: bigint
      url: string
      provider: string | null
      isPrimary: boolean
      sortOrder: number
      createdBy: number | null
      updatedBy: number | null
      deletedBy: number | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["itemVideo"]>
    composites: {}
  }

  type ItemVideoGetPayload<S extends boolean | null | undefined | ItemVideoDefaultArgs> = $Result.GetResult<Prisma.$ItemVideoPayload, S>

  type ItemVideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemVideoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemVideoCountAggregateInputType | true
    }

  export interface ItemVideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemVideo'], meta: { name: 'ItemVideo' } }
    /**
     * Find zero or one ItemVideo that matches the filter.
     * @param {ItemVideoFindUniqueArgs} args - Arguments to find a ItemVideo
     * @example
     * // Get one ItemVideo
     * const itemVideo = await prisma.itemVideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemVideoFindUniqueArgs>(args: SelectSubset<T, ItemVideoFindUniqueArgs<ExtArgs>>): Prisma__ItemVideoClient<$Result.GetResult<Prisma.$ItemVideoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ItemVideo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemVideoFindUniqueOrThrowArgs} args - Arguments to find a ItemVideo
     * @example
     * // Get one ItemVideo
     * const itemVideo = await prisma.itemVideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemVideoFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemVideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemVideoClient<$Result.GetResult<Prisma.$ItemVideoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ItemVideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemVideoFindFirstArgs} args - Arguments to find a ItemVideo
     * @example
     * // Get one ItemVideo
     * const itemVideo = await prisma.itemVideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemVideoFindFirstArgs>(args?: SelectSubset<T, ItemVideoFindFirstArgs<ExtArgs>>): Prisma__ItemVideoClient<$Result.GetResult<Prisma.$ItemVideoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ItemVideo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemVideoFindFirstOrThrowArgs} args - Arguments to find a ItemVideo
     * @example
     * // Get one ItemVideo
     * const itemVideo = await prisma.itemVideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemVideoFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemVideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemVideoClient<$Result.GetResult<Prisma.$ItemVideoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ItemVideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemVideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemVideos
     * const itemVideos = await prisma.itemVideo.findMany()
     * 
     * // Get first 10 ItemVideos
     * const itemVideos = await prisma.itemVideo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemVideoWithIdOnly = await prisma.itemVideo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemVideoFindManyArgs>(args?: SelectSubset<T, ItemVideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemVideoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ItemVideo.
     * @param {ItemVideoCreateArgs} args - Arguments to create a ItemVideo.
     * @example
     * // Create one ItemVideo
     * const ItemVideo = await prisma.itemVideo.create({
     *   data: {
     *     // ... data to create a ItemVideo
     *   }
     * })
     * 
     */
    create<T extends ItemVideoCreateArgs>(args: SelectSubset<T, ItemVideoCreateArgs<ExtArgs>>): Prisma__ItemVideoClient<$Result.GetResult<Prisma.$ItemVideoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ItemVideos.
     * @param {ItemVideoCreateManyArgs} args - Arguments to create many ItemVideos.
     * @example
     * // Create many ItemVideos
     * const itemVideo = await prisma.itemVideo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemVideoCreateManyArgs>(args?: SelectSubset<T, ItemVideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemVideo.
     * @param {ItemVideoDeleteArgs} args - Arguments to delete one ItemVideo.
     * @example
     * // Delete one ItemVideo
     * const ItemVideo = await prisma.itemVideo.delete({
     *   where: {
     *     // ... filter to delete one ItemVideo
     *   }
     * })
     * 
     */
    delete<T extends ItemVideoDeleteArgs>(args: SelectSubset<T, ItemVideoDeleteArgs<ExtArgs>>): Prisma__ItemVideoClient<$Result.GetResult<Prisma.$ItemVideoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ItemVideo.
     * @param {ItemVideoUpdateArgs} args - Arguments to update one ItemVideo.
     * @example
     * // Update one ItemVideo
     * const itemVideo = await prisma.itemVideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemVideoUpdateArgs>(args: SelectSubset<T, ItemVideoUpdateArgs<ExtArgs>>): Prisma__ItemVideoClient<$Result.GetResult<Prisma.$ItemVideoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ItemVideos.
     * @param {ItemVideoDeleteManyArgs} args - Arguments to filter ItemVideos to delete.
     * @example
     * // Delete a few ItemVideos
     * const { count } = await prisma.itemVideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemVideoDeleteManyArgs>(args?: SelectSubset<T, ItemVideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemVideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemVideos
     * const itemVideo = await prisma.itemVideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemVideoUpdateManyArgs>(args: SelectSubset<T, ItemVideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemVideo.
     * @param {ItemVideoUpsertArgs} args - Arguments to update or create a ItemVideo.
     * @example
     * // Update or create a ItemVideo
     * const itemVideo = await prisma.itemVideo.upsert({
     *   create: {
     *     // ... data to create a ItemVideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemVideo we want to update
     *   }
     * })
     */
    upsert<T extends ItemVideoUpsertArgs>(args: SelectSubset<T, ItemVideoUpsertArgs<ExtArgs>>): Prisma__ItemVideoClient<$Result.GetResult<Prisma.$ItemVideoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ItemVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemVideoCountArgs} args - Arguments to filter ItemVideos to count.
     * @example
     * // Count the number of ItemVideos
     * const count = await prisma.itemVideo.count({
     *   where: {
     *     // ... the filter for the ItemVideos we want to count
     *   }
     * })
    **/
    count<T extends ItemVideoCountArgs>(
      args?: Subset<T, ItemVideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemVideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemVideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemVideoAggregateArgs>(args: Subset<T, ItemVideoAggregateArgs>): Prisma.PrismaPromise<GetItemVideoAggregateType<T>>

    /**
     * Group by ItemVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemVideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemVideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemVideoGroupByArgs['orderBy'] }
        : { orderBy?: ItemVideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemVideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemVideo model
   */
  readonly fields: ItemVideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemVideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemVideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemVideo model
   */ 
  interface ItemVideoFieldRefs {
    readonly id: FieldRef<"ItemVideo", 'BigInt'>
    readonly itemId: FieldRef<"ItemVideo", 'BigInt'>
    readonly url: FieldRef<"ItemVideo", 'String'>
    readonly provider: FieldRef<"ItemVideo", 'String'>
    readonly isPrimary: FieldRef<"ItemVideo", 'Boolean'>
    readonly sortOrder: FieldRef<"ItemVideo", 'Int'>
    readonly createdBy: FieldRef<"ItemVideo", 'Int'>
    readonly updatedBy: FieldRef<"ItemVideo", 'Int'>
    readonly deletedBy: FieldRef<"ItemVideo", 'Int'>
    readonly createdAt: FieldRef<"ItemVideo", 'DateTime'>
    readonly updatedAt: FieldRef<"ItemVideo", 'DateTime'>
    readonly deletedAt: FieldRef<"ItemVideo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemVideo findUnique
   */
  export type ItemVideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVideo
     */
    select?: ItemVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVideo
     */
    omit?: ItemVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVideoInclude<ExtArgs> | null
    /**
     * Filter, which ItemVideo to fetch.
     */
    where: ItemVideoWhereUniqueInput
  }

  /**
   * ItemVideo findUniqueOrThrow
   */
  export type ItemVideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVideo
     */
    select?: ItemVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVideo
     */
    omit?: ItemVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVideoInclude<ExtArgs> | null
    /**
     * Filter, which ItemVideo to fetch.
     */
    where: ItemVideoWhereUniqueInput
  }

  /**
   * ItemVideo findFirst
   */
  export type ItemVideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVideo
     */
    select?: ItemVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVideo
     */
    omit?: ItemVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVideoInclude<ExtArgs> | null
    /**
     * Filter, which ItemVideo to fetch.
     */
    where?: ItemVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemVideos to fetch.
     */
    orderBy?: ItemVideoOrderByWithRelationInput | ItemVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemVideos.
     */
    cursor?: ItemVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemVideos.
     */
    distinct?: ItemVideoScalarFieldEnum | ItemVideoScalarFieldEnum[]
  }

  /**
   * ItemVideo findFirstOrThrow
   */
  export type ItemVideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVideo
     */
    select?: ItemVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVideo
     */
    omit?: ItemVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVideoInclude<ExtArgs> | null
    /**
     * Filter, which ItemVideo to fetch.
     */
    where?: ItemVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemVideos to fetch.
     */
    orderBy?: ItemVideoOrderByWithRelationInput | ItemVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemVideos.
     */
    cursor?: ItemVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemVideos.
     */
    distinct?: ItemVideoScalarFieldEnum | ItemVideoScalarFieldEnum[]
  }

  /**
   * ItemVideo findMany
   */
  export type ItemVideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVideo
     */
    select?: ItemVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVideo
     */
    omit?: ItemVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVideoInclude<ExtArgs> | null
    /**
     * Filter, which ItemVideos to fetch.
     */
    where?: ItemVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemVideos to fetch.
     */
    orderBy?: ItemVideoOrderByWithRelationInput | ItemVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemVideos.
     */
    cursor?: ItemVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemVideos.
     */
    skip?: number
    distinct?: ItemVideoScalarFieldEnum | ItemVideoScalarFieldEnum[]
  }

  /**
   * ItemVideo create
   */
  export type ItemVideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVideo
     */
    select?: ItemVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVideo
     */
    omit?: ItemVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVideoInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemVideo.
     */
    data: XOR<ItemVideoCreateInput, ItemVideoUncheckedCreateInput>
  }

  /**
   * ItemVideo createMany
   */
  export type ItemVideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemVideos.
     */
    data: ItemVideoCreateManyInput | ItemVideoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemVideo update
   */
  export type ItemVideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVideo
     */
    select?: ItemVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVideo
     */
    omit?: ItemVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVideoInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemVideo.
     */
    data: XOR<ItemVideoUpdateInput, ItemVideoUncheckedUpdateInput>
    /**
     * Choose, which ItemVideo to update.
     */
    where: ItemVideoWhereUniqueInput
  }

  /**
   * ItemVideo updateMany
   */
  export type ItemVideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemVideos.
     */
    data: XOR<ItemVideoUpdateManyMutationInput, ItemVideoUncheckedUpdateManyInput>
    /**
     * Filter which ItemVideos to update
     */
    where?: ItemVideoWhereInput
  }

  /**
   * ItemVideo upsert
   */
  export type ItemVideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVideo
     */
    select?: ItemVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVideo
     */
    omit?: ItemVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVideoInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemVideo to update in case it exists.
     */
    where: ItemVideoWhereUniqueInput
    /**
     * In case the ItemVideo found by the `where` argument doesn't exist, create a new ItemVideo with this data.
     */
    create: XOR<ItemVideoCreateInput, ItemVideoUncheckedCreateInput>
    /**
     * In case the ItemVideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemVideoUpdateInput, ItemVideoUncheckedUpdateInput>
  }

  /**
   * ItemVideo delete
   */
  export type ItemVideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVideo
     */
    select?: ItemVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVideo
     */
    omit?: ItemVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVideoInclude<ExtArgs> | null
    /**
     * Filter which ItemVideo to delete.
     */
    where: ItemVideoWhereUniqueInput
  }

  /**
   * ItemVideo deleteMany
   */
  export type ItemVideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemVideos to delete
     */
    where?: ItemVideoWhereInput
  }

  /**
   * ItemVideo without action
   */
  export type ItemVideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemVideo
     */
    select?: ItemVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemVideo
     */
    omit?: ItemVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemVideoInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    role: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    email: string
    password: string
    role: $Enums.UserRole
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    adminProfile?: boolean | User$adminProfileArgs<ExtArgs>
    customerProfile?: boolean | User$customerProfileArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password" | "role" | "isActive" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminProfile?: boolean | User$adminProfileArgs<ExtArgs>
    customerProfile?: boolean | User$customerProfileArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      adminProfile: Prisma.$UserAdminPayload<ExtArgs> | null
      customerProfile: Prisma.$UserCustomerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      email: string
      password: string
      role: $Enums.UserRole
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adminProfile<T extends User$adminProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$adminProfileArgs<ExtArgs>>): Prisma__UserAdminClient<$Result.GetResult<Prisma.$UserAdminPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    customerProfile<T extends User$customerProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$customerProfileArgs<ExtArgs>>): Prisma__UserCustomerClient<$Result.GetResult<Prisma.$UserCustomerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.adminProfile
   */
  export type User$adminProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdmin
     */
    select?: UserAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdmin
     */
    omit?: UserAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdminInclude<ExtArgs> | null
    where?: UserAdminWhereInput
  }

  /**
   * User.customerProfile
   */
  export type User$customerProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomer
     */
    select?: UserCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomer
     */
    omit?: UserCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerInclude<ExtArgs> | null
    where?: UserCustomerWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserAdmin
   */

  export type AggregateUserAdmin = {
    _count: UserAdminCountAggregateOutputType | null
    _avg: UserAdminAvgAggregateOutputType | null
    _sum: UserAdminSumAggregateOutputType | null
    _min: UserAdminMinAggregateOutputType | null
    _max: UserAdminMaxAggregateOutputType | null
  }

  export type UserAdminAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    accessLevel: number | null
  }

  export type UserAdminSumAggregateOutputType = {
    id: number | null
    userId: number | null
    accessLevel: number | null
  }

  export type UserAdminMinAggregateOutputType = {
    id: number | null
    userId: number | null
    fullName: string | null
    employeeId: string | null
    department: string | null
    phoneNumber: string | null
    accessLevel: number | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
  }

  export type UserAdminMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    fullName: string | null
    employeeId: string | null
    department: string | null
    phoneNumber: string | null
    accessLevel: number | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
  }

  export type UserAdminCountAggregateOutputType = {
    id: number
    userId: number
    fullName: number
    employeeId: number
    department: number
    phoneNumber: number
    accessLevel: number
    lastLoginAt: number
    lastLoginIp: number
    _all: number
  }


  export type UserAdminAvgAggregateInputType = {
    id?: true
    userId?: true
    accessLevel?: true
  }

  export type UserAdminSumAggregateInputType = {
    id?: true
    userId?: true
    accessLevel?: true
  }

  export type UserAdminMinAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    employeeId?: true
    department?: true
    phoneNumber?: true
    accessLevel?: true
    lastLoginAt?: true
    lastLoginIp?: true
  }

  export type UserAdminMaxAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    employeeId?: true
    department?: true
    phoneNumber?: true
    accessLevel?: true
    lastLoginAt?: true
    lastLoginIp?: true
  }

  export type UserAdminCountAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    employeeId?: true
    department?: true
    phoneNumber?: true
    accessLevel?: true
    lastLoginAt?: true
    lastLoginIp?: true
    _all?: true
  }

  export type UserAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAdmin to aggregate.
     */
    where?: UserAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAdmins to fetch.
     */
    orderBy?: UserAdminOrderByWithRelationInput | UserAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAdmins
    **/
    _count?: true | UserAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAdminMaxAggregateInputType
  }

  export type GetUserAdminAggregateType<T extends UserAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAdmin[P]>
      : GetScalarType<T[P], AggregateUserAdmin[P]>
  }




  export type UserAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAdminWhereInput
    orderBy?: UserAdminOrderByWithAggregationInput | UserAdminOrderByWithAggregationInput[]
    by: UserAdminScalarFieldEnum[] | UserAdminScalarFieldEnum
    having?: UserAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAdminCountAggregateInputType | true
    _avg?: UserAdminAvgAggregateInputType
    _sum?: UserAdminSumAggregateInputType
    _min?: UserAdminMinAggregateInputType
    _max?: UserAdminMaxAggregateInputType
  }

  export type UserAdminGroupByOutputType = {
    id: number
    userId: number
    fullName: string
    employeeId: string | null
    department: string | null
    phoneNumber: string | null
    accessLevel: number
    lastLoginAt: Date | null
    lastLoginIp: string | null
    _count: UserAdminCountAggregateOutputType | null
    _avg: UserAdminAvgAggregateOutputType | null
    _sum: UserAdminSumAggregateOutputType | null
    _min: UserAdminMinAggregateOutputType | null
    _max: UserAdminMaxAggregateOutputType | null
  }

  type GetUserAdminGroupByPayload<T extends UserAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAdminGroupByOutputType[P]>
            : GetScalarType<T[P], UserAdminGroupByOutputType[P]>
        }
      >
    >


  export type UserAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    employeeId?: boolean
    department?: boolean
    phoneNumber?: boolean
    accessLevel?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAdmin"]>



  export type UserAdminSelectScalar = {
    id?: boolean
    userId?: boolean
    fullName?: boolean
    employeeId?: boolean
    department?: boolean
    phoneNumber?: boolean
    accessLevel?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
  }

  export type UserAdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "fullName" | "employeeId" | "department" | "phoneNumber" | "accessLevel" | "lastLoginAt" | "lastLoginIp", ExtArgs["result"]["userAdmin"]>
  export type UserAdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAdmin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      fullName: string
      employeeId: string | null
      department: string | null
      phoneNumber: string | null
      accessLevel: number
      lastLoginAt: Date | null
      lastLoginIp: string | null
    }, ExtArgs["result"]["userAdmin"]>
    composites: {}
  }

  type UserAdminGetPayload<S extends boolean | null | undefined | UserAdminDefaultArgs> = $Result.GetResult<Prisma.$UserAdminPayload, S>

  type UserAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAdminCountAggregateInputType | true
    }

  export interface UserAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAdmin'], meta: { name: 'UserAdmin' } }
    /**
     * Find zero or one UserAdmin that matches the filter.
     * @param {UserAdminFindUniqueArgs} args - Arguments to find a UserAdmin
     * @example
     * // Get one UserAdmin
     * const userAdmin = await prisma.userAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAdminFindUniqueArgs>(args: SelectSubset<T, UserAdminFindUniqueArgs<ExtArgs>>): Prisma__UserAdminClient<$Result.GetResult<Prisma.$UserAdminPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserAdmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAdminFindUniqueOrThrowArgs} args - Arguments to find a UserAdmin
     * @example
     * // Get one UserAdmin
     * const userAdmin = await prisma.userAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAdminClient<$Result.GetResult<Prisma.$UserAdminPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdminFindFirstArgs} args - Arguments to find a UserAdmin
     * @example
     * // Get one UserAdmin
     * const userAdmin = await prisma.userAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAdminFindFirstArgs>(args?: SelectSubset<T, UserAdminFindFirstArgs<ExtArgs>>): Prisma__UserAdminClient<$Result.GetResult<Prisma.$UserAdminPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdminFindFirstOrThrowArgs} args - Arguments to find a UserAdmin
     * @example
     * // Get one UserAdmin
     * const userAdmin = await prisma.userAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAdminClient<$Result.GetResult<Prisma.$UserAdminPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAdmins
     * const userAdmins = await prisma.userAdmin.findMany()
     * 
     * // Get first 10 UserAdmins
     * const userAdmins = await prisma.userAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAdminWithIdOnly = await prisma.userAdmin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAdminFindManyArgs>(args?: SelectSubset<T, UserAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAdminPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserAdmin.
     * @param {UserAdminCreateArgs} args - Arguments to create a UserAdmin.
     * @example
     * // Create one UserAdmin
     * const UserAdmin = await prisma.userAdmin.create({
     *   data: {
     *     // ... data to create a UserAdmin
     *   }
     * })
     * 
     */
    create<T extends UserAdminCreateArgs>(args: SelectSubset<T, UserAdminCreateArgs<ExtArgs>>): Prisma__UserAdminClient<$Result.GetResult<Prisma.$UserAdminPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserAdmins.
     * @param {UserAdminCreateManyArgs} args - Arguments to create many UserAdmins.
     * @example
     * // Create many UserAdmins
     * const userAdmin = await prisma.userAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAdminCreateManyArgs>(args?: SelectSubset<T, UserAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserAdmin.
     * @param {UserAdminDeleteArgs} args - Arguments to delete one UserAdmin.
     * @example
     * // Delete one UserAdmin
     * const UserAdmin = await prisma.userAdmin.delete({
     *   where: {
     *     // ... filter to delete one UserAdmin
     *   }
     * })
     * 
     */
    delete<T extends UserAdminDeleteArgs>(args: SelectSubset<T, UserAdminDeleteArgs<ExtArgs>>): Prisma__UserAdminClient<$Result.GetResult<Prisma.$UserAdminPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserAdmin.
     * @param {UserAdminUpdateArgs} args - Arguments to update one UserAdmin.
     * @example
     * // Update one UserAdmin
     * const userAdmin = await prisma.userAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAdminUpdateArgs>(args: SelectSubset<T, UserAdminUpdateArgs<ExtArgs>>): Prisma__UserAdminClient<$Result.GetResult<Prisma.$UserAdminPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserAdmins.
     * @param {UserAdminDeleteManyArgs} args - Arguments to filter UserAdmins to delete.
     * @example
     * // Delete a few UserAdmins
     * const { count } = await prisma.userAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAdminDeleteManyArgs>(args?: SelectSubset<T, UserAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAdmins
     * const userAdmin = await prisma.userAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAdminUpdateManyArgs>(args: SelectSubset<T, UserAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAdmin.
     * @param {UserAdminUpsertArgs} args - Arguments to update or create a UserAdmin.
     * @example
     * // Update or create a UserAdmin
     * const userAdmin = await prisma.userAdmin.upsert({
     *   create: {
     *     // ... data to create a UserAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAdmin we want to update
     *   }
     * })
     */
    upsert<T extends UserAdminUpsertArgs>(args: SelectSubset<T, UserAdminUpsertArgs<ExtArgs>>): Prisma__UserAdminClient<$Result.GetResult<Prisma.$UserAdminPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdminCountArgs} args - Arguments to filter UserAdmins to count.
     * @example
     * // Count the number of UserAdmins
     * const count = await prisma.userAdmin.count({
     *   where: {
     *     // ... the filter for the UserAdmins we want to count
     *   }
     * })
    **/
    count<T extends UserAdminCountArgs>(
      args?: Subset<T, UserAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAdminAggregateArgs>(args: Subset<T, UserAdminAggregateArgs>): Prisma.PrismaPromise<GetUserAdminAggregateType<T>>

    /**
     * Group by UserAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAdminGroupByArgs['orderBy'] }
        : { orderBy?: UserAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAdmin model
   */
  readonly fields: UserAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAdmin model
   */ 
  interface UserAdminFieldRefs {
    readonly id: FieldRef<"UserAdmin", 'Int'>
    readonly userId: FieldRef<"UserAdmin", 'Int'>
    readonly fullName: FieldRef<"UserAdmin", 'String'>
    readonly employeeId: FieldRef<"UserAdmin", 'String'>
    readonly department: FieldRef<"UserAdmin", 'String'>
    readonly phoneNumber: FieldRef<"UserAdmin", 'String'>
    readonly accessLevel: FieldRef<"UserAdmin", 'Int'>
    readonly lastLoginAt: FieldRef<"UserAdmin", 'DateTime'>
    readonly lastLoginIp: FieldRef<"UserAdmin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserAdmin findUnique
   */
  export type UserAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdmin
     */
    select?: UserAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdmin
     */
    omit?: UserAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdminInclude<ExtArgs> | null
    /**
     * Filter, which UserAdmin to fetch.
     */
    where: UserAdminWhereUniqueInput
  }

  /**
   * UserAdmin findUniqueOrThrow
   */
  export type UserAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdmin
     */
    select?: UserAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdmin
     */
    omit?: UserAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdminInclude<ExtArgs> | null
    /**
     * Filter, which UserAdmin to fetch.
     */
    where: UserAdminWhereUniqueInput
  }

  /**
   * UserAdmin findFirst
   */
  export type UserAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdmin
     */
    select?: UserAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdmin
     */
    omit?: UserAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdminInclude<ExtArgs> | null
    /**
     * Filter, which UserAdmin to fetch.
     */
    where?: UserAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAdmins to fetch.
     */
    orderBy?: UserAdminOrderByWithRelationInput | UserAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAdmins.
     */
    cursor?: UserAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAdmins.
     */
    distinct?: UserAdminScalarFieldEnum | UserAdminScalarFieldEnum[]
  }

  /**
   * UserAdmin findFirstOrThrow
   */
  export type UserAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdmin
     */
    select?: UserAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdmin
     */
    omit?: UserAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdminInclude<ExtArgs> | null
    /**
     * Filter, which UserAdmin to fetch.
     */
    where?: UserAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAdmins to fetch.
     */
    orderBy?: UserAdminOrderByWithRelationInput | UserAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAdmins.
     */
    cursor?: UserAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAdmins.
     */
    distinct?: UserAdminScalarFieldEnum | UserAdminScalarFieldEnum[]
  }

  /**
   * UserAdmin findMany
   */
  export type UserAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdmin
     */
    select?: UserAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdmin
     */
    omit?: UserAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdminInclude<ExtArgs> | null
    /**
     * Filter, which UserAdmins to fetch.
     */
    where?: UserAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAdmins to fetch.
     */
    orderBy?: UserAdminOrderByWithRelationInput | UserAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAdmins.
     */
    cursor?: UserAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAdmins.
     */
    skip?: number
    distinct?: UserAdminScalarFieldEnum | UserAdminScalarFieldEnum[]
  }

  /**
   * UserAdmin create
   */
  export type UserAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdmin
     */
    select?: UserAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdmin
     */
    omit?: UserAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdminInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAdmin.
     */
    data: XOR<UserAdminCreateInput, UserAdminUncheckedCreateInput>
  }

  /**
   * UserAdmin createMany
   */
  export type UserAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAdmins.
     */
    data: UserAdminCreateManyInput | UserAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAdmin update
   */
  export type UserAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdmin
     */
    select?: UserAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdmin
     */
    omit?: UserAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdminInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAdmin.
     */
    data: XOR<UserAdminUpdateInput, UserAdminUncheckedUpdateInput>
    /**
     * Choose, which UserAdmin to update.
     */
    where: UserAdminWhereUniqueInput
  }

  /**
   * UserAdmin updateMany
   */
  export type UserAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAdmins.
     */
    data: XOR<UserAdminUpdateManyMutationInput, UserAdminUncheckedUpdateManyInput>
    /**
     * Filter which UserAdmins to update
     */
    where?: UserAdminWhereInput
  }

  /**
   * UserAdmin upsert
   */
  export type UserAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdmin
     */
    select?: UserAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdmin
     */
    omit?: UserAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdminInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAdmin to update in case it exists.
     */
    where: UserAdminWhereUniqueInput
    /**
     * In case the UserAdmin found by the `where` argument doesn't exist, create a new UserAdmin with this data.
     */
    create: XOR<UserAdminCreateInput, UserAdminUncheckedCreateInput>
    /**
     * In case the UserAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAdminUpdateInput, UserAdminUncheckedUpdateInput>
  }

  /**
   * UserAdmin delete
   */
  export type UserAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdmin
     */
    select?: UserAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdmin
     */
    omit?: UserAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdminInclude<ExtArgs> | null
    /**
     * Filter which UserAdmin to delete.
     */
    where: UserAdminWhereUniqueInput
  }

  /**
   * UserAdmin deleteMany
   */
  export type UserAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAdmins to delete
     */
    where?: UserAdminWhereInput
  }

  /**
   * UserAdmin without action
   */
  export type UserAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdmin
     */
    select?: UserAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdmin
     */
    omit?: UserAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdminInclude<ExtArgs> | null
  }


  /**
   * Model UserCustomer
   */

  export type AggregateUserCustomer = {
    _count: UserCustomerCountAggregateOutputType | null
    _avg: UserCustomerAvgAggregateOutputType | null
    _sum: UserCustomerSumAggregateOutputType | null
    _min: UserCustomerMinAggregateOutputType | null
    _max: UserCustomerMaxAggregateOutputType | null
  }

  export type UserCustomerAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    loyaltyPoint: number | null
  }

  export type UserCustomerSumAggregateOutputType = {
    id: number | null
    userId: number | null
    loyaltyPoint: number | null
  }

  export type UserCustomerMinAggregateOutputType = {
    id: number | null
    userId: number | null
    fullName: string | null
    phoneNumber: string | null
    birthDate: Date | null
    loyaltyPoint: number | null
    referralCode: string | null
    isVerified: boolean | null
    verifiedAt: Date | null
  }

  export type UserCustomerMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    fullName: string | null
    phoneNumber: string | null
    birthDate: Date | null
    loyaltyPoint: number | null
    referralCode: string | null
    isVerified: boolean | null
    verifiedAt: Date | null
  }

  export type UserCustomerCountAggregateOutputType = {
    id: number
    userId: number
    fullName: number
    phoneNumber: number
    birthDate: number
    loyaltyPoint: number
    referralCode: number
    isVerified: number
    verifiedAt: number
    _all: number
  }


  export type UserCustomerAvgAggregateInputType = {
    id?: true
    userId?: true
    loyaltyPoint?: true
  }

  export type UserCustomerSumAggregateInputType = {
    id?: true
    userId?: true
    loyaltyPoint?: true
  }

  export type UserCustomerMinAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    phoneNumber?: true
    birthDate?: true
    loyaltyPoint?: true
    referralCode?: true
    isVerified?: true
    verifiedAt?: true
  }

  export type UserCustomerMaxAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    phoneNumber?: true
    birthDate?: true
    loyaltyPoint?: true
    referralCode?: true
    isVerified?: true
    verifiedAt?: true
  }

  export type UserCustomerCountAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    phoneNumber?: true
    birthDate?: true
    loyaltyPoint?: true
    referralCode?: true
    isVerified?: true
    verifiedAt?: true
    _all?: true
  }

  export type UserCustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCustomer to aggregate.
     */
    where?: UserCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCustomers to fetch.
     */
    orderBy?: UserCustomerOrderByWithRelationInput | UserCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCustomers
    **/
    _count?: true | UserCustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserCustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserCustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCustomerMaxAggregateInputType
  }

  export type GetUserCustomerAggregateType<T extends UserCustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCustomer[P]>
      : GetScalarType<T[P], AggregateUserCustomer[P]>
  }




  export type UserCustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCustomerWhereInput
    orderBy?: UserCustomerOrderByWithAggregationInput | UserCustomerOrderByWithAggregationInput[]
    by: UserCustomerScalarFieldEnum[] | UserCustomerScalarFieldEnum
    having?: UserCustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCustomerCountAggregateInputType | true
    _avg?: UserCustomerAvgAggregateInputType
    _sum?: UserCustomerSumAggregateInputType
    _min?: UserCustomerMinAggregateInputType
    _max?: UserCustomerMaxAggregateInputType
  }

  export type UserCustomerGroupByOutputType = {
    id: number
    userId: number
    fullName: string
    phoneNumber: string | null
    birthDate: Date | null
    loyaltyPoint: number
    referralCode: string | null
    isVerified: boolean
    verifiedAt: Date | null
    _count: UserCustomerCountAggregateOutputType | null
    _avg: UserCustomerAvgAggregateOutputType | null
    _sum: UserCustomerSumAggregateOutputType | null
    _min: UserCustomerMinAggregateOutputType | null
    _max: UserCustomerMaxAggregateOutputType | null
  }

  type GetUserCustomerGroupByPayload<T extends UserCustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCustomerGroupByOutputType[P]>
            : GetScalarType<T[P], UserCustomerGroupByOutputType[P]>
        }
      >
    >


  export type UserCustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    phoneNumber?: boolean
    birthDate?: boolean
    loyaltyPoint?: boolean
    referralCode?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    addresses?: boolean | UserCustomer$addressesArgs<ExtArgs>
    member?: boolean | UserCustomer$memberArgs<ExtArgs>
    responses?: boolean | UserCustomer$responsesArgs<ExtArgs>
    _count?: boolean | UserCustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCustomer"]>



  export type UserCustomerSelectScalar = {
    id?: boolean
    userId?: boolean
    fullName?: boolean
    phoneNumber?: boolean
    birthDate?: boolean
    loyaltyPoint?: boolean
    referralCode?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
  }

  export type UserCustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "fullName" | "phoneNumber" | "birthDate" | "loyaltyPoint" | "referralCode" | "isVerified" | "verifiedAt", ExtArgs["result"]["userCustomer"]>
  export type UserCustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    addresses?: boolean | UserCustomer$addressesArgs<ExtArgs>
    member?: boolean | UserCustomer$memberArgs<ExtArgs>
    responses?: boolean | UserCustomer$responsesArgs<ExtArgs>
    _count?: boolean | UserCustomerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserCustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCustomer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      addresses: Prisma.$UserCustomerAddressPayload<ExtArgs>[]
      member: Prisma.$UserMemberPayload<ExtArgs> | null
      responses: Prisma.$CustomerResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      fullName: string
      phoneNumber: string | null
      birthDate: Date | null
      loyaltyPoint: number
      referralCode: string | null
      isVerified: boolean
      verifiedAt: Date | null
    }, ExtArgs["result"]["userCustomer"]>
    composites: {}
  }

  type UserCustomerGetPayload<S extends boolean | null | undefined | UserCustomerDefaultArgs> = $Result.GetResult<Prisma.$UserCustomerPayload, S>

  type UserCustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserCustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCustomerCountAggregateInputType | true
    }

  export interface UserCustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCustomer'], meta: { name: 'UserCustomer' } }
    /**
     * Find zero or one UserCustomer that matches the filter.
     * @param {UserCustomerFindUniqueArgs} args - Arguments to find a UserCustomer
     * @example
     * // Get one UserCustomer
     * const userCustomer = await prisma.userCustomer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCustomerFindUniqueArgs>(args: SelectSubset<T, UserCustomerFindUniqueArgs<ExtArgs>>): Prisma__UserCustomerClient<$Result.GetResult<Prisma.$UserCustomerPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserCustomer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCustomerFindUniqueOrThrowArgs} args - Arguments to find a UserCustomer
     * @example
     * // Get one UserCustomer
     * const userCustomer = await prisma.userCustomer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCustomerClient<$Result.GetResult<Prisma.$UserCustomerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserCustomer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomerFindFirstArgs} args - Arguments to find a UserCustomer
     * @example
     * // Get one UserCustomer
     * const userCustomer = await prisma.userCustomer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCustomerFindFirstArgs>(args?: SelectSubset<T, UserCustomerFindFirstArgs<ExtArgs>>): Prisma__UserCustomerClient<$Result.GetResult<Prisma.$UserCustomerPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserCustomer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomerFindFirstOrThrowArgs} args - Arguments to find a UserCustomer
     * @example
     * // Get one UserCustomer
     * const userCustomer = await prisma.userCustomer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCustomerClient<$Result.GetResult<Prisma.$UserCustomerPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserCustomers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCustomers
     * const userCustomers = await prisma.userCustomer.findMany()
     * 
     * // Get first 10 UserCustomers
     * const userCustomers = await prisma.userCustomer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCustomerWithIdOnly = await prisma.userCustomer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserCustomerFindManyArgs>(args?: SelectSubset<T, UserCustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCustomerPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserCustomer.
     * @param {UserCustomerCreateArgs} args - Arguments to create a UserCustomer.
     * @example
     * // Create one UserCustomer
     * const UserCustomer = await prisma.userCustomer.create({
     *   data: {
     *     // ... data to create a UserCustomer
     *   }
     * })
     * 
     */
    create<T extends UserCustomerCreateArgs>(args: SelectSubset<T, UserCustomerCreateArgs<ExtArgs>>): Prisma__UserCustomerClient<$Result.GetResult<Prisma.$UserCustomerPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserCustomers.
     * @param {UserCustomerCreateManyArgs} args - Arguments to create many UserCustomers.
     * @example
     * // Create many UserCustomers
     * const userCustomer = await prisma.userCustomer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCustomerCreateManyArgs>(args?: SelectSubset<T, UserCustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserCustomer.
     * @param {UserCustomerDeleteArgs} args - Arguments to delete one UserCustomer.
     * @example
     * // Delete one UserCustomer
     * const UserCustomer = await prisma.userCustomer.delete({
     *   where: {
     *     // ... filter to delete one UserCustomer
     *   }
     * })
     * 
     */
    delete<T extends UserCustomerDeleteArgs>(args: SelectSubset<T, UserCustomerDeleteArgs<ExtArgs>>): Prisma__UserCustomerClient<$Result.GetResult<Prisma.$UserCustomerPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserCustomer.
     * @param {UserCustomerUpdateArgs} args - Arguments to update one UserCustomer.
     * @example
     * // Update one UserCustomer
     * const userCustomer = await prisma.userCustomer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCustomerUpdateArgs>(args: SelectSubset<T, UserCustomerUpdateArgs<ExtArgs>>): Prisma__UserCustomerClient<$Result.GetResult<Prisma.$UserCustomerPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserCustomers.
     * @param {UserCustomerDeleteManyArgs} args - Arguments to filter UserCustomers to delete.
     * @example
     * // Delete a few UserCustomers
     * const { count } = await prisma.userCustomer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCustomerDeleteManyArgs>(args?: SelectSubset<T, UserCustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCustomers
     * const userCustomer = await prisma.userCustomer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCustomerUpdateManyArgs>(args: SelectSubset<T, UserCustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserCustomer.
     * @param {UserCustomerUpsertArgs} args - Arguments to update or create a UserCustomer.
     * @example
     * // Update or create a UserCustomer
     * const userCustomer = await prisma.userCustomer.upsert({
     *   create: {
     *     // ... data to create a UserCustomer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCustomer we want to update
     *   }
     * })
     */
    upsert<T extends UserCustomerUpsertArgs>(args: SelectSubset<T, UserCustomerUpsertArgs<ExtArgs>>): Prisma__UserCustomerClient<$Result.GetResult<Prisma.$UserCustomerPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomerCountArgs} args - Arguments to filter UserCustomers to count.
     * @example
     * // Count the number of UserCustomers
     * const count = await prisma.userCustomer.count({
     *   where: {
     *     // ... the filter for the UserCustomers we want to count
     *   }
     * })
    **/
    count<T extends UserCustomerCountArgs>(
      args?: Subset<T, UserCustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCustomer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCustomerAggregateArgs>(args: Subset<T, UserCustomerAggregateArgs>): Prisma.PrismaPromise<GetUserCustomerAggregateType<T>>

    /**
     * Group by UserCustomer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCustomerGroupByArgs['orderBy'] }
        : { orderBy?: UserCustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCustomer model
   */
  readonly fields: UserCustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCustomer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    addresses<T extends UserCustomer$addressesArgs<ExtArgs> = {}>(args?: Subset<T, UserCustomer$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCustomerAddressPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    member<T extends UserCustomer$memberArgs<ExtArgs> = {}>(args?: Subset<T, UserCustomer$memberArgs<ExtArgs>>): Prisma__UserMemberClient<$Result.GetResult<Prisma.$UserMemberPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    responses<T extends UserCustomer$responsesArgs<ExtArgs> = {}>(args?: Subset<T, UserCustomer$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerResponsePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCustomer model
   */ 
  interface UserCustomerFieldRefs {
    readonly id: FieldRef<"UserCustomer", 'Int'>
    readonly userId: FieldRef<"UserCustomer", 'Int'>
    readonly fullName: FieldRef<"UserCustomer", 'String'>
    readonly phoneNumber: FieldRef<"UserCustomer", 'String'>
    readonly birthDate: FieldRef<"UserCustomer", 'DateTime'>
    readonly loyaltyPoint: FieldRef<"UserCustomer", 'Int'>
    readonly referralCode: FieldRef<"UserCustomer", 'String'>
    readonly isVerified: FieldRef<"UserCustomer", 'Boolean'>
    readonly verifiedAt: FieldRef<"UserCustomer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserCustomer findUnique
   */
  export type UserCustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomer
     */
    select?: UserCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomer
     */
    omit?: UserCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerInclude<ExtArgs> | null
    /**
     * Filter, which UserCustomer to fetch.
     */
    where: UserCustomerWhereUniqueInput
  }

  /**
   * UserCustomer findUniqueOrThrow
   */
  export type UserCustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomer
     */
    select?: UserCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomer
     */
    omit?: UserCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerInclude<ExtArgs> | null
    /**
     * Filter, which UserCustomer to fetch.
     */
    where: UserCustomerWhereUniqueInput
  }

  /**
   * UserCustomer findFirst
   */
  export type UserCustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomer
     */
    select?: UserCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomer
     */
    omit?: UserCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerInclude<ExtArgs> | null
    /**
     * Filter, which UserCustomer to fetch.
     */
    where?: UserCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCustomers to fetch.
     */
    orderBy?: UserCustomerOrderByWithRelationInput | UserCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCustomers.
     */
    cursor?: UserCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCustomers.
     */
    distinct?: UserCustomerScalarFieldEnum | UserCustomerScalarFieldEnum[]
  }

  /**
   * UserCustomer findFirstOrThrow
   */
  export type UserCustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomer
     */
    select?: UserCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomer
     */
    omit?: UserCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerInclude<ExtArgs> | null
    /**
     * Filter, which UserCustomer to fetch.
     */
    where?: UserCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCustomers to fetch.
     */
    orderBy?: UserCustomerOrderByWithRelationInput | UserCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCustomers.
     */
    cursor?: UserCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCustomers.
     */
    distinct?: UserCustomerScalarFieldEnum | UserCustomerScalarFieldEnum[]
  }

  /**
   * UserCustomer findMany
   */
  export type UserCustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomer
     */
    select?: UserCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomer
     */
    omit?: UserCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerInclude<ExtArgs> | null
    /**
     * Filter, which UserCustomers to fetch.
     */
    where?: UserCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCustomers to fetch.
     */
    orderBy?: UserCustomerOrderByWithRelationInput | UserCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCustomers.
     */
    cursor?: UserCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCustomers.
     */
    skip?: number
    distinct?: UserCustomerScalarFieldEnum | UserCustomerScalarFieldEnum[]
  }

  /**
   * UserCustomer create
   */
  export type UserCustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomer
     */
    select?: UserCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomer
     */
    omit?: UserCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCustomer.
     */
    data: XOR<UserCustomerCreateInput, UserCustomerUncheckedCreateInput>
  }

  /**
   * UserCustomer createMany
   */
  export type UserCustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCustomers.
     */
    data: UserCustomerCreateManyInput | UserCustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCustomer update
   */
  export type UserCustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomer
     */
    select?: UserCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomer
     */
    omit?: UserCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCustomer.
     */
    data: XOR<UserCustomerUpdateInput, UserCustomerUncheckedUpdateInput>
    /**
     * Choose, which UserCustomer to update.
     */
    where: UserCustomerWhereUniqueInput
  }

  /**
   * UserCustomer updateMany
   */
  export type UserCustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCustomers.
     */
    data: XOR<UserCustomerUpdateManyMutationInput, UserCustomerUncheckedUpdateManyInput>
    /**
     * Filter which UserCustomers to update
     */
    where?: UserCustomerWhereInput
  }

  /**
   * UserCustomer upsert
   */
  export type UserCustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomer
     */
    select?: UserCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomer
     */
    omit?: UserCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCustomer to update in case it exists.
     */
    where: UserCustomerWhereUniqueInput
    /**
     * In case the UserCustomer found by the `where` argument doesn't exist, create a new UserCustomer with this data.
     */
    create: XOR<UserCustomerCreateInput, UserCustomerUncheckedCreateInput>
    /**
     * In case the UserCustomer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCustomerUpdateInput, UserCustomerUncheckedUpdateInput>
  }

  /**
   * UserCustomer delete
   */
  export type UserCustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomer
     */
    select?: UserCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomer
     */
    omit?: UserCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerInclude<ExtArgs> | null
    /**
     * Filter which UserCustomer to delete.
     */
    where: UserCustomerWhereUniqueInput
  }

  /**
   * UserCustomer deleteMany
   */
  export type UserCustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCustomers to delete
     */
    where?: UserCustomerWhereInput
  }

  /**
   * UserCustomer.addresses
   */
  export type UserCustomer$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomerAddress
     */
    select?: UserCustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomerAddress
     */
    omit?: UserCustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerAddressInclude<ExtArgs> | null
    where?: UserCustomerAddressWhereInput
    orderBy?: UserCustomerAddressOrderByWithRelationInput | UserCustomerAddressOrderByWithRelationInput[]
    cursor?: UserCustomerAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCustomerAddressScalarFieldEnum | UserCustomerAddressScalarFieldEnum[]
  }

  /**
   * UserCustomer.member
   */
  export type UserCustomer$memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMember
     */
    select?: UserMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMember
     */
    omit?: UserMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMemberInclude<ExtArgs> | null
    where?: UserMemberWhereInput
  }

  /**
   * UserCustomer.responses
   */
  export type UserCustomer$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerResponse
     */
    select?: CustomerResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerResponse
     */
    omit?: CustomerResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerResponseInclude<ExtArgs> | null
    where?: CustomerResponseWhereInput
    orderBy?: CustomerResponseOrderByWithRelationInput | CustomerResponseOrderByWithRelationInput[]
    cursor?: CustomerResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerResponseScalarFieldEnum | CustomerResponseScalarFieldEnum[]
  }

  /**
   * UserCustomer without action
   */
  export type UserCustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomer
     */
    select?: UserCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomer
     */
    omit?: UserCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerInclude<ExtArgs> | null
  }


  /**
   * Model UserCustomerAddress
   */

  export type AggregateUserCustomerAddress = {
    _count: UserCustomerAddressCountAggregateOutputType | null
    _avg: UserCustomerAddressAvgAggregateOutputType | null
    _sum: UserCustomerAddressSumAggregateOutputType | null
    _min: UserCustomerAddressMinAggregateOutputType | null
    _max: UserCustomerAddressMaxAggregateOutputType | null
  }

  export type UserCustomerAddressAvgAggregateOutputType = {
    id: number | null
    userCustomerId: number | null
  }

  export type UserCustomerAddressSumAggregateOutputType = {
    id: number | null
    userCustomerId: number | null
  }

  export type UserCustomerAddressMinAggregateOutputType = {
    id: number | null
    userCustomerId: number | null
    label: string | null
    recipientName: string | null
    recipientPhone: string | null
    fullAddress: string | null
    note: string | null
    isPrimary: boolean | null
  }

  export type UserCustomerAddressMaxAggregateOutputType = {
    id: number | null
    userCustomerId: number | null
    label: string | null
    recipientName: string | null
    recipientPhone: string | null
    fullAddress: string | null
    note: string | null
    isPrimary: boolean | null
  }

  export type UserCustomerAddressCountAggregateOutputType = {
    id: number
    userCustomerId: number
    label: number
    recipientName: number
    recipientPhone: number
    fullAddress: number
    note: number
    isPrimary: number
    _all: number
  }


  export type UserCustomerAddressAvgAggregateInputType = {
    id?: true
    userCustomerId?: true
  }

  export type UserCustomerAddressSumAggregateInputType = {
    id?: true
    userCustomerId?: true
  }

  export type UserCustomerAddressMinAggregateInputType = {
    id?: true
    userCustomerId?: true
    label?: true
    recipientName?: true
    recipientPhone?: true
    fullAddress?: true
    note?: true
    isPrimary?: true
  }

  export type UserCustomerAddressMaxAggregateInputType = {
    id?: true
    userCustomerId?: true
    label?: true
    recipientName?: true
    recipientPhone?: true
    fullAddress?: true
    note?: true
    isPrimary?: true
  }

  export type UserCustomerAddressCountAggregateInputType = {
    id?: true
    userCustomerId?: true
    label?: true
    recipientName?: true
    recipientPhone?: true
    fullAddress?: true
    note?: true
    isPrimary?: true
    _all?: true
  }

  export type UserCustomerAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCustomerAddress to aggregate.
     */
    where?: UserCustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCustomerAddresses to fetch.
     */
    orderBy?: UserCustomerAddressOrderByWithRelationInput | UserCustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCustomerAddresses
    **/
    _count?: true | UserCustomerAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserCustomerAddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserCustomerAddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCustomerAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCustomerAddressMaxAggregateInputType
  }

  export type GetUserCustomerAddressAggregateType<T extends UserCustomerAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCustomerAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCustomerAddress[P]>
      : GetScalarType<T[P], AggregateUserCustomerAddress[P]>
  }




  export type UserCustomerAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCustomerAddressWhereInput
    orderBy?: UserCustomerAddressOrderByWithAggregationInput | UserCustomerAddressOrderByWithAggregationInput[]
    by: UserCustomerAddressScalarFieldEnum[] | UserCustomerAddressScalarFieldEnum
    having?: UserCustomerAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCustomerAddressCountAggregateInputType | true
    _avg?: UserCustomerAddressAvgAggregateInputType
    _sum?: UserCustomerAddressSumAggregateInputType
    _min?: UserCustomerAddressMinAggregateInputType
    _max?: UserCustomerAddressMaxAggregateInputType
  }

  export type UserCustomerAddressGroupByOutputType = {
    id: number
    userCustomerId: number
    label: string
    recipientName: string
    recipientPhone: string
    fullAddress: string
    note: string | null
    isPrimary: boolean
    _count: UserCustomerAddressCountAggregateOutputType | null
    _avg: UserCustomerAddressAvgAggregateOutputType | null
    _sum: UserCustomerAddressSumAggregateOutputType | null
    _min: UserCustomerAddressMinAggregateOutputType | null
    _max: UserCustomerAddressMaxAggregateOutputType | null
  }

  type GetUserCustomerAddressGroupByPayload<T extends UserCustomerAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCustomerAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCustomerAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCustomerAddressGroupByOutputType[P]>
            : GetScalarType<T[P], UserCustomerAddressGroupByOutputType[P]>
        }
      >
    >


  export type UserCustomerAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userCustomerId?: boolean
    label?: boolean
    recipientName?: boolean
    recipientPhone?: boolean
    fullAddress?: boolean
    note?: boolean
    isPrimary?: boolean
    customer?: boolean | UserCustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCustomerAddress"]>



  export type UserCustomerAddressSelectScalar = {
    id?: boolean
    userCustomerId?: boolean
    label?: boolean
    recipientName?: boolean
    recipientPhone?: boolean
    fullAddress?: boolean
    note?: boolean
    isPrimary?: boolean
  }

  export type UserCustomerAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userCustomerId" | "label" | "recipientName" | "recipientPhone" | "fullAddress" | "note" | "isPrimary", ExtArgs["result"]["userCustomerAddress"]>
  export type UserCustomerAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserCustomerDefaultArgs<ExtArgs>
  }

  export type $UserCustomerAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCustomerAddress"
    objects: {
      customer: Prisma.$UserCustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userCustomerId: number
      label: string
      recipientName: string
      recipientPhone: string
      fullAddress: string
      note: string | null
      isPrimary: boolean
    }, ExtArgs["result"]["userCustomerAddress"]>
    composites: {}
  }

  type UserCustomerAddressGetPayload<S extends boolean | null | undefined | UserCustomerAddressDefaultArgs> = $Result.GetResult<Prisma.$UserCustomerAddressPayload, S>

  type UserCustomerAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserCustomerAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCustomerAddressCountAggregateInputType | true
    }

  export interface UserCustomerAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCustomerAddress'], meta: { name: 'UserCustomerAddress' } }
    /**
     * Find zero or one UserCustomerAddress that matches the filter.
     * @param {UserCustomerAddressFindUniqueArgs} args - Arguments to find a UserCustomerAddress
     * @example
     * // Get one UserCustomerAddress
     * const userCustomerAddress = await prisma.userCustomerAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCustomerAddressFindUniqueArgs>(args: SelectSubset<T, UserCustomerAddressFindUniqueArgs<ExtArgs>>): Prisma__UserCustomerAddressClient<$Result.GetResult<Prisma.$UserCustomerAddressPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserCustomerAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCustomerAddressFindUniqueOrThrowArgs} args - Arguments to find a UserCustomerAddress
     * @example
     * // Get one UserCustomerAddress
     * const userCustomerAddress = await prisma.userCustomerAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCustomerAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCustomerAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCustomerAddressClient<$Result.GetResult<Prisma.$UserCustomerAddressPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserCustomerAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomerAddressFindFirstArgs} args - Arguments to find a UserCustomerAddress
     * @example
     * // Get one UserCustomerAddress
     * const userCustomerAddress = await prisma.userCustomerAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCustomerAddressFindFirstArgs>(args?: SelectSubset<T, UserCustomerAddressFindFirstArgs<ExtArgs>>): Prisma__UserCustomerAddressClient<$Result.GetResult<Prisma.$UserCustomerAddressPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserCustomerAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomerAddressFindFirstOrThrowArgs} args - Arguments to find a UserCustomerAddress
     * @example
     * // Get one UserCustomerAddress
     * const userCustomerAddress = await prisma.userCustomerAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCustomerAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCustomerAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCustomerAddressClient<$Result.GetResult<Prisma.$UserCustomerAddressPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserCustomerAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomerAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCustomerAddresses
     * const userCustomerAddresses = await prisma.userCustomerAddress.findMany()
     * 
     * // Get first 10 UserCustomerAddresses
     * const userCustomerAddresses = await prisma.userCustomerAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCustomerAddressWithIdOnly = await prisma.userCustomerAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserCustomerAddressFindManyArgs>(args?: SelectSubset<T, UserCustomerAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCustomerAddressPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserCustomerAddress.
     * @param {UserCustomerAddressCreateArgs} args - Arguments to create a UserCustomerAddress.
     * @example
     * // Create one UserCustomerAddress
     * const UserCustomerAddress = await prisma.userCustomerAddress.create({
     *   data: {
     *     // ... data to create a UserCustomerAddress
     *   }
     * })
     * 
     */
    create<T extends UserCustomerAddressCreateArgs>(args: SelectSubset<T, UserCustomerAddressCreateArgs<ExtArgs>>): Prisma__UserCustomerAddressClient<$Result.GetResult<Prisma.$UserCustomerAddressPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserCustomerAddresses.
     * @param {UserCustomerAddressCreateManyArgs} args - Arguments to create many UserCustomerAddresses.
     * @example
     * // Create many UserCustomerAddresses
     * const userCustomerAddress = await prisma.userCustomerAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCustomerAddressCreateManyArgs>(args?: SelectSubset<T, UserCustomerAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserCustomerAddress.
     * @param {UserCustomerAddressDeleteArgs} args - Arguments to delete one UserCustomerAddress.
     * @example
     * // Delete one UserCustomerAddress
     * const UserCustomerAddress = await prisma.userCustomerAddress.delete({
     *   where: {
     *     // ... filter to delete one UserCustomerAddress
     *   }
     * })
     * 
     */
    delete<T extends UserCustomerAddressDeleteArgs>(args: SelectSubset<T, UserCustomerAddressDeleteArgs<ExtArgs>>): Prisma__UserCustomerAddressClient<$Result.GetResult<Prisma.$UserCustomerAddressPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserCustomerAddress.
     * @param {UserCustomerAddressUpdateArgs} args - Arguments to update one UserCustomerAddress.
     * @example
     * // Update one UserCustomerAddress
     * const userCustomerAddress = await prisma.userCustomerAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCustomerAddressUpdateArgs>(args: SelectSubset<T, UserCustomerAddressUpdateArgs<ExtArgs>>): Prisma__UserCustomerAddressClient<$Result.GetResult<Prisma.$UserCustomerAddressPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserCustomerAddresses.
     * @param {UserCustomerAddressDeleteManyArgs} args - Arguments to filter UserCustomerAddresses to delete.
     * @example
     * // Delete a few UserCustomerAddresses
     * const { count } = await prisma.userCustomerAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCustomerAddressDeleteManyArgs>(args?: SelectSubset<T, UserCustomerAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCustomerAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomerAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCustomerAddresses
     * const userCustomerAddress = await prisma.userCustomerAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCustomerAddressUpdateManyArgs>(args: SelectSubset<T, UserCustomerAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserCustomerAddress.
     * @param {UserCustomerAddressUpsertArgs} args - Arguments to update or create a UserCustomerAddress.
     * @example
     * // Update or create a UserCustomerAddress
     * const userCustomerAddress = await prisma.userCustomerAddress.upsert({
     *   create: {
     *     // ... data to create a UserCustomerAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCustomerAddress we want to update
     *   }
     * })
     */
    upsert<T extends UserCustomerAddressUpsertArgs>(args: SelectSubset<T, UserCustomerAddressUpsertArgs<ExtArgs>>): Prisma__UserCustomerAddressClient<$Result.GetResult<Prisma.$UserCustomerAddressPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserCustomerAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomerAddressCountArgs} args - Arguments to filter UserCustomerAddresses to count.
     * @example
     * // Count the number of UserCustomerAddresses
     * const count = await prisma.userCustomerAddress.count({
     *   where: {
     *     // ... the filter for the UserCustomerAddresses we want to count
     *   }
     * })
    **/
    count<T extends UserCustomerAddressCountArgs>(
      args?: Subset<T, UserCustomerAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCustomerAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCustomerAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomerAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCustomerAddressAggregateArgs>(args: Subset<T, UserCustomerAddressAggregateArgs>): Prisma.PrismaPromise<GetUserCustomerAddressAggregateType<T>>

    /**
     * Group by UserCustomerAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomerAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCustomerAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCustomerAddressGroupByArgs['orderBy'] }
        : { orderBy?: UserCustomerAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCustomerAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCustomerAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCustomerAddress model
   */
  readonly fields: UserCustomerAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCustomerAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCustomerAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserCustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserCustomerDefaultArgs<ExtArgs>>): Prisma__UserCustomerClient<$Result.GetResult<Prisma.$UserCustomerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCustomerAddress model
   */ 
  interface UserCustomerAddressFieldRefs {
    readonly id: FieldRef<"UserCustomerAddress", 'Int'>
    readonly userCustomerId: FieldRef<"UserCustomerAddress", 'Int'>
    readonly label: FieldRef<"UserCustomerAddress", 'String'>
    readonly recipientName: FieldRef<"UserCustomerAddress", 'String'>
    readonly recipientPhone: FieldRef<"UserCustomerAddress", 'String'>
    readonly fullAddress: FieldRef<"UserCustomerAddress", 'String'>
    readonly note: FieldRef<"UserCustomerAddress", 'String'>
    readonly isPrimary: FieldRef<"UserCustomerAddress", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * UserCustomerAddress findUnique
   */
  export type UserCustomerAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomerAddress
     */
    select?: UserCustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomerAddress
     */
    omit?: UserCustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserCustomerAddress to fetch.
     */
    where: UserCustomerAddressWhereUniqueInput
  }

  /**
   * UserCustomerAddress findUniqueOrThrow
   */
  export type UserCustomerAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomerAddress
     */
    select?: UserCustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomerAddress
     */
    omit?: UserCustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserCustomerAddress to fetch.
     */
    where: UserCustomerAddressWhereUniqueInput
  }

  /**
   * UserCustomerAddress findFirst
   */
  export type UserCustomerAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomerAddress
     */
    select?: UserCustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomerAddress
     */
    omit?: UserCustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserCustomerAddress to fetch.
     */
    where?: UserCustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCustomerAddresses to fetch.
     */
    orderBy?: UserCustomerAddressOrderByWithRelationInput | UserCustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCustomerAddresses.
     */
    cursor?: UserCustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCustomerAddresses.
     */
    distinct?: UserCustomerAddressScalarFieldEnum | UserCustomerAddressScalarFieldEnum[]
  }

  /**
   * UserCustomerAddress findFirstOrThrow
   */
  export type UserCustomerAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomerAddress
     */
    select?: UserCustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomerAddress
     */
    omit?: UserCustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserCustomerAddress to fetch.
     */
    where?: UserCustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCustomerAddresses to fetch.
     */
    orderBy?: UserCustomerAddressOrderByWithRelationInput | UserCustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCustomerAddresses.
     */
    cursor?: UserCustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCustomerAddresses.
     */
    distinct?: UserCustomerAddressScalarFieldEnum | UserCustomerAddressScalarFieldEnum[]
  }

  /**
   * UserCustomerAddress findMany
   */
  export type UserCustomerAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomerAddress
     */
    select?: UserCustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomerAddress
     */
    omit?: UserCustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserCustomerAddresses to fetch.
     */
    where?: UserCustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCustomerAddresses to fetch.
     */
    orderBy?: UserCustomerAddressOrderByWithRelationInput | UserCustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCustomerAddresses.
     */
    cursor?: UserCustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCustomerAddresses.
     */
    skip?: number
    distinct?: UserCustomerAddressScalarFieldEnum | UserCustomerAddressScalarFieldEnum[]
  }

  /**
   * UserCustomerAddress create
   */
  export type UserCustomerAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomerAddress
     */
    select?: UserCustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomerAddress
     */
    omit?: UserCustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCustomerAddress.
     */
    data: XOR<UserCustomerAddressCreateInput, UserCustomerAddressUncheckedCreateInput>
  }

  /**
   * UserCustomerAddress createMany
   */
  export type UserCustomerAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCustomerAddresses.
     */
    data: UserCustomerAddressCreateManyInput | UserCustomerAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCustomerAddress update
   */
  export type UserCustomerAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomerAddress
     */
    select?: UserCustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomerAddress
     */
    omit?: UserCustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCustomerAddress.
     */
    data: XOR<UserCustomerAddressUpdateInput, UserCustomerAddressUncheckedUpdateInput>
    /**
     * Choose, which UserCustomerAddress to update.
     */
    where: UserCustomerAddressWhereUniqueInput
  }

  /**
   * UserCustomerAddress updateMany
   */
  export type UserCustomerAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCustomerAddresses.
     */
    data: XOR<UserCustomerAddressUpdateManyMutationInput, UserCustomerAddressUncheckedUpdateManyInput>
    /**
     * Filter which UserCustomerAddresses to update
     */
    where?: UserCustomerAddressWhereInput
  }

  /**
   * UserCustomerAddress upsert
   */
  export type UserCustomerAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomerAddress
     */
    select?: UserCustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomerAddress
     */
    omit?: UserCustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCustomerAddress to update in case it exists.
     */
    where: UserCustomerAddressWhereUniqueInput
    /**
     * In case the UserCustomerAddress found by the `where` argument doesn't exist, create a new UserCustomerAddress with this data.
     */
    create: XOR<UserCustomerAddressCreateInput, UserCustomerAddressUncheckedCreateInput>
    /**
     * In case the UserCustomerAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCustomerAddressUpdateInput, UserCustomerAddressUncheckedUpdateInput>
  }

  /**
   * UserCustomerAddress delete
   */
  export type UserCustomerAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomerAddress
     */
    select?: UserCustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomerAddress
     */
    omit?: UserCustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerAddressInclude<ExtArgs> | null
    /**
     * Filter which UserCustomerAddress to delete.
     */
    where: UserCustomerAddressWhereUniqueInput
  }

  /**
   * UserCustomerAddress deleteMany
   */
  export type UserCustomerAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCustomerAddresses to delete
     */
    where?: UserCustomerAddressWhereInput
  }

  /**
   * UserCustomerAddress without action
   */
  export type UserCustomerAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomerAddress
     */
    select?: UserCustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomerAddress
     */
    omit?: UserCustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomerAddressInclude<ExtArgs> | null
  }


  /**
   * Model UserMember
   */

  export type AggregateUserMember = {
    _count: UserMemberCountAggregateOutputType | null
    _avg: UserMemberAvgAggregateOutputType | null
    _sum: UserMemberSumAggregateOutputType | null
    _min: UserMemberMinAggregateOutputType | null
    _max: UserMemberMaxAggregateOutputType | null
  }

  export type UserMemberAvgAggregateOutputType = {
    id: number | null
    userCustomerId: number | null
  }

  export type UserMemberSumAggregateOutputType = {
    id: number | null
    userCustomerId: number | null
  }

  export type UserMemberMinAggregateOutputType = {
    id: number | null
    userCustomerId: number | null
    tier: $Enums.MemberTier | null
    memberNumber: string | null
    joinedAt: Date | null
    expiredAt: Date | null
  }

  export type UserMemberMaxAggregateOutputType = {
    id: number | null
    userCustomerId: number | null
    tier: $Enums.MemberTier | null
    memberNumber: string | null
    joinedAt: Date | null
    expiredAt: Date | null
  }

  export type UserMemberCountAggregateOutputType = {
    id: number
    userCustomerId: number
    tier: number
    memberNumber: number
    joinedAt: number
    expiredAt: number
    _all: number
  }


  export type UserMemberAvgAggregateInputType = {
    id?: true
    userCustomerId?: true
  }

  export type UserMemberSumAggregateInputType = {
    id?: true
    userCustomerId?: true
  }

  export type UserMemberMinAggregateInputType = {
    id?: true
    userCustomerId?: true
    tier?: true
    memberNumber?: true
    joinedAt?: true
    expiredAt?: true
  }

  export type UserMemberMaxAggregateInputType = {
    id?: true
    userCustomerId?: true
    tier?: true
    memberNumber?: true
    joinedAt?: true
    expiredAt?: true
  }

  export type UserMemberCountAggregateInputType = {
    id?: true
    userCustomerId?: true
    tier?: true
    memberNumber?: true
    joinedAt?: true
    expiredAt?: true
    _all?: true
  }

  export type UserMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMember to aggregate.
     */
    where?: UserMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMembers to fetch.
     */
    orderBy?: UserMemberOrderByWithRelationInput | UserMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserMembers
    **/
    _count?: true | UserMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMemberMaxAggregateInputType
  }

  export type GetUserMemberAggregateType<T extends UserMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateUserMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserMember[P]>
      : GetScalarType<T[P], AggregateUserMember[P]>
  }




  export type UserMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMemberWhereInput
    orderBy?: UserMemberOrderByWithAggregationInput | UserMemberOrderByWithAggregationInput[]
    by: UserMemberScalarFieldEnum[] | UserMemberScalarFieldEnum
    having?: UserMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserMemberCountAggregateInputType | true
    _avg?: UserMemberAvgAggregateInputType
    _sum?: UserMemberSumAggregateInputType
    _min?: UserMemberMinAggregateInputType
    _max?: UserMemberMaxAggregateInputType
  }

  export type UserMemberGroupByOutputType = {
    id: number
    userCustomerId: number
    tier: $Enums.MemberTier
    memberNumber: string
    joinedAt: Date
    expiredAt: Date | null
    _count: UserMemberCountAggregateOutputType | null
    _avg: UserMemberAvgAggregateOutputType | null
    _sum: UserMemberSumAggregateOutputType | null
    _min: UserMemberMinAggregateOutputType | null
    _max: UserMemberMaxAggregateOutputType | null
  }

  type GetUserMemberGroupByPayload<T extends UserMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserMemberGroupByOutputType[P]>
            : GetScalarType<T[P], UserMemberGroupByOutputType[P]>
        }
      >
    >


  export type UserMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userCustomerId?: boolean
    tier?: boolean
    memberNumber?: boolean
    joinedAt?: boolean
    expiredAt?: boolean
    customer?: boolean | UserCustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMember"]>



  export type UserMemberSelectScalar = {
    id?: boolean
    userCustomerId?: boolean
    tier?: boolean
    memberNumber?: boolean
    joinedAt?: boolean
    expiredAt?: boolean
  }

  export type UserMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userCustomerId" | "tier" | "memberNumber" | "joinedAt" | "expiredAt", ExtArgs["result"]["userMember"]>
  export type UserMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserCustomerDefaultArgs<ExtArgs>
  }

  export type $UserMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserMember"
    objects: {
      customer: Prisma.$UserCustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userCustomerId: number
      tier: $Enums.MemberTier
      memberNumber: string
      joinedAt: Date
      expiredAt: Date | null
    }, ExtArgs["result"]["userMember"]>
    composites: {}
  }

  type UserMemberGetPayload<S extends boolean | null | undefined | UserMemberDefaultArgs> = $Result.GetResult<Prisma.$UserMemberPayload, S>

  type UserMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserMemberCountAggregateInputType | true
    }

  export interface UserMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserMember'], meta: { name: 'UserMember' } }
    /**
     * Find zero or one UserMember that matches the filter.
     * @param {UserMemberFindUniqueArgs} args - Arguments to find a UserMember
     * @example
     * // Get one UserMember
     * const userMember = await prisma.userMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserMemberFindUniqueArgs>(args: SelectSubset<T, UserMemberFindUniqueArgs<ExtArgs>>): Prisma__UserMemberClient<$Result.GetResult<Prisma.$UserMemberPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserMemberFindUniqueOrThrowArgs} args - Arguments to find a UserMember
     * @example
     * // Get one UserMember
     * const userMember = await prisma.userMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, UserMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserMemberClient<$Result.GetResult<Prisma.$UserMemberPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMemberFindFirstArgs} args - Arguments to find a UserMember
     * @example
     * // Get one UserMember
     * const userMember = await prisma.userMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserMemberFindFirstArgs>(args?: SelectSubset<T, UserMemberFindFirstArgs<ExtArgs>>): Prisma__UserMemberClient<$Result.GetResult<Prisma.$UserMemberPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMemberFindFirstOrThrowArgs} args - Arguments to find a UserMember
     * @example
     * // Get one UserMember
     * const userMember = await prisma.userMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, UserMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserMemberClient<$Result.GetResult<Prisma.$UserMemberPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserMembers
     * const userMembers = await prisma.userMember.findMany()
     * 
     * // Get first 10 UserMembers
     * const userMembers = await prisma.userMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userMemberWithIdOnly = await prisma.userMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserMemberFindManyArgs>(args?: SelectSubset<T, UserMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMemberPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserMember.
     * @param {UserMemberCreateArgs} args - Arguments to create a UserMember.
     * @example
     * // Create one UserMember
     * const UserMember = await prisma.userMember.create({
     *   data: {
     *     // ... data to create a UserMember
     *   }
     * })
     * 
     */
    create<T extends UserMemberCreateArgs>(args: SelectSubset<T, UserMemberCreateArgs<ExtArgs>>): Prisma__UserMemberClient<$Result.GetResult<Prisma.$UserMemberPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserMembers.
     * @param {UserMemberCreateManyArgs} args - Arguments to create many UserMembers.
     * @example
     * // Create many UserMembers
     * const userMember = await prisma.userMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserMemberCreateManyArgs>(args?: SelectSubset<T, UserMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserMember.
     * @param {UserMemberDeleteArgs} args - Arguments to delete one UserMember.
     * @example
     * // Delete one UserMember
     * const UserMember = await prisma.userMember.delete({
     *   where: {
     *     // ... filter to delete one UserMember
     *   }
     * })
     * 
     */
    delete<T extends UserMemberDeleteArgs>(args: SelectSubset<T, UserMemberDeleteArgs<ExtArgs>>): Prisma__UserMemberClient<$Result.GetResult<Prisma.$UserMemberPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserMember.
     * @param {UserMemberUpdateArgs} args - Arguments to update one UserMember.
     * @example
     * // Update one UserMember
     * const userMember = await prisma.userMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserMemberUpdateArgs>(args: SelectSubset<T, UserMemberUpdateArgs<ExtArgs>>): Prisma__UserMemberClient<$Result.GetResult<Prisma.$UserMemberPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserMembers.
     * @param {UserMemberDeleteManyArgs} args - Arguments to filter UserMembers to delete.
     * @example
     * // Delete a few UserMembers
     * const { count } = await prisma.userMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserMemberDeleteManyArgs>(args?: SelectSubset<T, UserMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserMembers
     * const userMember = await prisma.userMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserMemberUpdateManyArgs>(args: SelectSubset<T, UserMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserMember.
     * @param {UserMemberUpsertArgs} args - Arguments to update or create a UserMember.
     * @example
     * // Update or create a UserMember
     * const userMember = await prisma.userMember.upsert({
     *   create: {
     *     // ... data to create a UserMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserMember we want to update
     *   }
     * })
     */
    upsert<T extends UserMemberUpsertArgs>(args: SelectSubset<T, UserMemberUpsertArgs<ExtArgs>>): Prisma__UserMemberClient<$Result.GetResult<Prisma.$UserMemberPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMemberCountArgs} args - Arguments to filter UserMembers to count.
     * @example
     * // Count the number of UserMembers
     * const count = await prisma.userMember.count({
     *   where: {
     *     // ... the filter for the UserMembers we want to count
     *   }
     * })
    **/
    count<T extends UserMemberCountArgs>(
      args?: Subset<T, UserMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserMemberAggregateArgs>(args: Subset<T, UserMemberAggregateArgs>): Prisma.PrismaPromise<GetUserMemberAggregateType<T>>

    /**
     * Group by UserMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserMemberGroupByArgs['orderBy'] }
        : { orderBy?: UserMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserMember model
   */
  readonly fields: UserMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserCustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserCustomerDefaultArgs<ExtArgs>>): Prisma__UserCustomerClient<$Result.GetResult<Prisma.$UserCustomerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserMember model
   */ 
  interface UserMemberFieldRefs {
    readonly id: FieldRef<"UserMember", 'Int'>
    readonly userCustomerId: FieldRef<"UserMember", 'Int'>
    readonly tier: FieldRef<"UserMember", 'MemberTier'>
    readonly memberNumber: FieldRef<"UserMember", 'String'>
    readonly joinedAt: FieldRef<"UserMember", 'DateTime'>
    readonly expiredAt: FieldRef<"UserMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserMember findUnique
   */
  export type UserMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMember
     */
    select?: UserMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMember
     */
    omit?: UserMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMemberInclude<ExtArgs> | null
    /**
     * Filter, which UserMember to fetch.
     */
    where: UserMemberWhereUniqueInput
  }

  /**
   * UserMember findUniqueOrThrow
   */
  export type UserMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMember
     */
    select?: UserMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMember
     */
    omit?: UserMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMemberInclude<ExtArgs> | null
    /**
     * Filter, which UserMember to fetch.
     */
    where: UserMemberWhereUniqueInput
  }

  /**
   * UserMember findFirst
   */
  export type UserMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMember
     */
    select?: UserMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMember
     */
    omit?: UserMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMemberInclude<ExtArgs> | null
    /**
     * Filter, which UserMember to fetch.
     */
    where?: UserMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMembers to fetch.
     */
    orderBy?: UserMemberOrderByWithRelationInput | UserMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMembers.
     */
    cursor?: UserMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMembers.
     */
    distinct?: UserMemberScalarFieldEnum | UserMemberScalarFieldEnum[]
  }

  /**
   * UserMember findFirstOrThrow
   */
  export type UserMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMember
     */
    select?: UserMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMember
     */
    omit?: UserMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMemberInclude<ExtArgs> | null
    /**
     * Filter, which UserMember to fetch.
     */
    where?: UserMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMembers to fetch.
     */
    orderBy?: UserMemberOrderByWithRelationInput | UserMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMembers.
     */
    cursor?: UserMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMembers.
     */
    distinct?: UserMemberScalarFieldEnum | UserMemberScalarFieldEnum[]
  }

  /**
   * UserMember findMany
   */
  export type UserMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMember
     */
    select?: UserMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMember
     */
    omit?: UserMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMemberInclude<ExtArgs> | null
    /**
     * Filter, which UserMembers to fetch.
     */
    where?: UserMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMembers to fetch.
     */
    orderBy?: UserMemberOrderByWithRelationInput | UserMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserMembers.
     */
    cursor?: UserMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMembers.
     */
    skip?: number
    distinct?: UserMemberScalarFieldEnum | UserMemberScalarFieldEnum[]
  }

  /**
   * UserMember create
   */
  export type UserMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMember
     */
    select?: UserMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMember
     */
    omit?: UserMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a UserMember.
     */
    data: XOR<UserMemberCreateInput, UserMemberUncheckedCreateInput>
  }

  /**
   * UserMember createMany
   */
  export type UserMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserMembers.
     */
    data: UserMemberCreateManyInput | UserMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserMember update
   */
  export type UserMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMember
     */
    select?: UserMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMember
     */
    omit?: UserMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a UserMember.
     */
    data: XOR<UserMemberUpdateInput, UserMemberUncheckedUpdateInput>
    /**
     * Choose, which UserMember to update.
     */
    where: UserMemberWhereUniqueInput
  }

  /**
   * UserMember updateMany
   */
  export type UserMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserMembers.
     */
    data: XOR<UserMemberUpdateManyMutationInput, UserMemberUncheckedUpdateManyInput>
    /**
     * Filter which UserMembers to update
     */
    where?: UserMemberWhereInput
  }

  /**
   * UserMember upsert
   */
  export type UserMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMember
     */
    select?: UserMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMember
     */
    omit?: UserMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the UserMember to update in case it exists.
     */
    where: UserMemberWhereUniqueInput
    /**
     * In case the UserMember found by the `where` argument doesn't exist, create a new UserMember with this data.
     */
    create: XOR<UserMemberCreateInput, UserMemberUncheckedCreateInput>
    /**
     * In case the UserMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserMemberUpdateInput, UserMemberUncheckedUpdateInput>
  }

  /**
   * UserMember delete
   */
  export type UserMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMember
     */
    select?: UserMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMember
     */
    omit?: UserMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMemberInclude<ExtArgs> | null
    /**
     * Filter which UserMember to delete.
     */
    where: UserMemberWhereUniqueInput
  }

  /**
   * UserMember deleteMany
   */
  export type UserMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMembers to delete
     */
    where?: UserMemberWhereInput
  }

  /**
   * UserMember without action
   */
  export type UserMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMember
     */
    select?: UserMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMember
     */
    omit?: UserMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMemberInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CustomerFormFieldScalarFieldEnum: {
    id: 'id',
    label: 'label',
    fieldKey: 'fieldKey',
    type: 'type',
    options: 'options',
    isRequired: 'isRequired',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerFormFieldScalarFieldEnum = (typeof CustomerFormFieldScalarFieldEnum)[keyof typeof CustomerFormFieldScalarFieldEnum]


  export const CustomerResponseScalarFieldEnum: {
    id: 'id',
    userCustomerId: 'userCustomerId',
    fieldId: 'fieldId',
    answer: 'answer',
    createdAt: 'createdAt'
  };

  export type CustomerResponseScalarFieldEnum = (typeof CustomerResponseScalarFieldEnum)[keyof typeof CustomerResponseScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    itemTypeId: 'itemTypeId',
    itemCategoryId: 'itemCategoryId',
    name: 'name',
    slug: 'slug',
    description: 'description',
    shortDescription: 'shortDescription',
    tags: 'tags',
    attributes: 'attributes',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    status: 'status',
    isPinned: 'isPinned',
    isFavorite: 'isFavorite',
    isDeleted: 'isDeleted',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const ItemAttributeTemplateScalarFieldEnum: {
    id: 'id',
    itemCategoryId: 'itemCategoryId',
    name: 'name',
    type: 'type',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ItemAttributeTemplateScalarFieldEnum = (typeof ItemAttributeTemplateScalarFieldEnum)[keyof typeof ItemAttributeTemplateScalarFieldEnum]


  export const ItemCategoryScalarFieldEnum: {
    id: 'id',
    parentId: 'parentId',
    name: 'name',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ItemCategoryScalarFieldEnum = (typeof ItemCategoryScalarFieldEnum)[keyof typeof ItemCategoryScalarFieldEnum]


  export const ItemImageScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    url: 'url',
    isPrimary: 'isPrimary',
    sortOrder: 'sortOrder',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ItemImageScalarFieldEnum = (typeof ItemImageScalarFieldEnum)[keyof typeof ItemImageScalarFieldEnum]


  export const ItemPriceScalarFieldEnum: {
    id: 'id',
    itemVariantId: 'itemVariantId',
    price: 'price',
    priceType: 'priceType',
    startDate: 'startDate',
    endDate: 'endDate',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ItemPriceScalarFieldEnum = (typeof ItemPriceScalarFieldEnum)[keyof typeof ItemPriceScalarFieldEnum]


  export const ItemTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ItemTypeScalarFieldEnum = (typeof ItemTypeScalarFieldEnum)[keyof typeof ItemTypeScalarFieldEnum]


  export const ItemUpdateHistoryScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    itemName: 'itemName',
    userId: 'userId',
    userName: 'userName',
    columnName: 'columnName',
    createdAt: 'createdAt'
  };

  export type ItemUpdateHistoryScalarFieldEnum = (typeof ItemUpdateHistoryScalarFieldEnum)[keyof typeof ItemUpdateHistoryScalarFieldEnum]


  export const ItemVariantScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    code: 'code',
    name: 'name',
    imageUrl: 'imageUrl',
    price: 'price',
    quantity: 'quantity',
    options: 'options',
    isActive: 'isActive',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ItemVariantScalarFieldEnum = (typeof ItemVariantScalarFieldEnum)[keyof typeof ItemVariantScalarFieldEnum]


  export const ItemVideoScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    url: 'url',
    provider: 'provider',
    isPrimary: 'isPrimary',
    sortOrder: 'sortOrder',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ItemVideoScalarFieldEnum = (typeof ItemVideoScalarFieldEnum)[keyof typeof ItemVideoScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserAdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fullName: 'fullName',
    employeeId: 'employeeId',
    department: 'department',
    phoneNumber: 'phoneNumber',
    accessLevel: 'accessLevel',
    lastLoginAt: 'lastLoginAt',
    lastLoginIp: 'lastLoginIp'
  };

  export type UserAdminScalarFieldEnum = (typeof UserAdminScalarFieldEnum)[keyof typeof UserAdminScalarFieldEnum]


  export const UserCustomerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fullName: 'fullName',
    phoneNumber: 'phoneNumber',
    birthDate: 'birthDate',
    loyaltyPoint: 'loyaltyPoint',
    referralCode: 'referralCode',
    isVerified: 'isVerified',
    verifiedAt: 'verifiedAt'
  };

  export type UserCustomerScalarFieldEnum = (typeof UserCustomerScalarFieldEnum)[keyof typeof UserCustomerScalarFieldEnum]


  export const UserCustomerAddressScalarFieldEnum: {
    id: 'id',
    userCustomerId: 'userCustomerId',
    label: 'label',
    recipientName: 'recipientName',
    recipientPhone: 'recipientPhone',
    fullAddress: 'fullAddress',
    note: 'note',
    isPrimary: 'isPrimary'
  };

  export type UserCustomerAddressScalarFieldEnum = (typeof UserCustomerAddressScalarFieldEnum)[keyof typeof UserCustomerAddressScalarFieldEnum]


  export const UserMemberScalarFieldEnum: {
    id: 'id',
    userCustomerId: 'userCustomerId',
    tier: 'tier',
    memberNumber: 'memberNumber',
    joinedAt: 'joinedAt',
    expiredAt: 'expiredAt'
  };

  export type UserMemberScalarFieldEnum = (typeof UserMemberScalarFieldEnum)[keyof typeof UserMemberScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const CustomerFormFieldOrderByRelevanceFieldEnum: {
    label: 'label',
    fieldKey: 'fieldKey'
  };

  export type CustomerFormFieldOrderByRelevanceFieldEnum = (typeof CustomerFormFieldOrderByRelevanceFieldEnum)[keyof typeof CustomerFormFieldOrderByRelevanceFieldEnum]


  export const CustomerResponseOrderByRelevanceFieldEnum: {
    answer: 'answer'
  };

  export type CustomerResponseOrderByRelevanceFieldEnum = (typeof CustomerResponseOrderByRelevanceFieldEnum)[keyof typeof CustomerResponseOrderByRelevanceFieldEnum]


  export const ItemOrderByRelevanceFieldEnum: {
    name: 'name',
    slug: 'slug',
    description: 'description',
    shortDescription: 'shortDescription',
    tags: 'tags',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription'
  };

  export type ItemOrderByRelevanceFieldEnum = (typeof ItemOrderByRelevanceFieldEnum)[keyof typeof ItemOrderByRelevanceFieldEnum]


  export const ItemAttributeTemplateOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type ItemAttributeTemplateOrderByRelevanceFieldEnum = (typeof ItemAttributeTemplateOrderByRelevanceFieldEnum)[keyof typeof ItemAttributeTemplateOrderByRelevanceFieldEnum]


  export const ItemCategoryOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type ItemCategoryOrderByRelevanceFieldEnum = (typeof ItemCategoryOrderByRelevanceFieldEnum)[keyof typeof ItemCategoryOrderByRelevanceFieldEnum]


  export const ItemImageOrderByRelevanceFieldEnum: {
    url: 'url'
  };

  export type ItemImageOrderByRelevanceFieldEnum = (typeof ItemImageOrderByRelevanceFieldEnum)[keyof typeof ItemImageOrderByRelevanceFieldEnum]


  export const ItemPriceOrderByRelevanceFieldEnum: {
    startTime: 'startTime',
    endTime: 'endTime'
  };

  export type ItemPriceOrderByRelevanceFieldEnum = (typeof ItemPriceOrderByRelevanceFieldEnum)[keyof typeof ItemPriceOrderByRelevanceFieldEnum]


  export const ItemTypeOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type ItemTypeOrderByRelevanceFieldEnum = (typeof ItemTypeOrderByRelevanceFieldEnum)[keyof typeof ItemTypeOrderByRelevanceFieldEnum]


  export const ItemUpdateHistoryOrderByRelevanceFieldEnum: {
    itemName: 'itemName',
    userName: 'userName',
    columnName: 'columnName'
  };

  export type ItemUpdateHistoryOrderByRelevanceFieldEnum = (typeof ItemUpdateHistoryOrderByRelevanceFieldEnum)[keyof typeof ItemUpdateHistoryOrderByRelevanceFieldEnum]


  export const ItemVariantOrderByRelevanceFieldEnum: {
    code: 'code',
    name: 'name',
    imageUrl: 'imageUrl'
  };

  export type ItemVariantOrderByRelevanceFieldEnum = (typeof ItemVariantOrderByRelevanceFieldEnum)[keyof typeof ItemVariantOrderByRelevanceFieldEnum]


  export const ItemVideoOrderByRelevanceFieldEnum: {
    url: 'url',
    provider: 'provider'
  };

  export type ItemVideoOrderByRelevanceFieldEnum = (typeof ItemVideoOrderByRelevanceFieldEnum)[keyof typeof ItemVideoOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    username: 'username',
    email: 'email',
    password: 'password'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const UserAdminOrderByRelevanceFieldEnum: {
    fullName: 'fullName',
    employeeId: 'employeeId',
    department: 'department',
    phoneNumber: 'phoneNumber',
    lastLoginIp: 'lastLoginIp'
  };

  export type UserAdminOrderByRelevanceFieldEnum = (typeof UserAdminOrderByRelevanceFieldEnum)[keyof typeof UserAdminOrderByRelevanceFieldEnum]


  export const UserCustomerOrderByRelevanceFieldEnum: {
    fullName: 'fullName',
    phoneNumber: 'phoneNumber',
    referralCode: 'referralCode'
  };

  export type UserCustomerOrderByRelevanceFieldEnum = (typeof UserCustomerOrderByRelevanceFieldEnum)[keyof typeof UserCustomerOrderByRelevanceFieldEnum]


  export const UserCustomerAddressOrderByRelevanceFieldEnum: {
    label: 'label',
    recipientName: 'recipientName',
    recipientPhone: 'recipientPhone',
    fullAddress: 'fullAddress',
    note: 'note'
  };

  export type UserCustomerAddressOrderByRelevanceFieldEnum = (typeof UserCustomerAddressOrderByRelevanceFieldEnum)[keyof typeof UserCustomerAddressOrderByRelevanceFieldEnum]


  export const UserMemberOrderByRelevanceFieldEnum: {
    memberNumber: 'memberNumber'
  };

  export type UserMemberOrderByRelevanceFieldEnum = (typeof UserMemberOrderByRelevanceFieldEnum)[keyof typeof UserMemberOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'FieldType'
   */
  export type EnumFieldTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FieldType'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'ItemStatus'
   */
  export type EnumItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemStatus'>
    


  /**
   * Reference to a field of type 'AttributeType'
   */
  export type EnumAttributeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttributeType'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'PriceType'
   */
  export type EnumPriceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PriceType'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'MemberTier'
   */
  export type EnumMemberTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberTier'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type CustomerFormFieldWhereInput = {
    AND?: CustomerFormFieldWhereInput | CustomerFormFieldWhereInput[]
    OR?: CustomerFormFieldWhereInput[]
    NOT?: CustomerFormFieldWhereInput | CustomerFormFieldWhereInput[]
    id?: IntFilter<"CustomerFormField"> | number
    label?: StringFilter<"CustomerFormField"> | string
    fieldKey?: StringFilter<"CustomerFormField"> | string
    type?: EnumFieldTypeFilter<"CustomerFormField"> | $Enums.FieldType
    options?: JsonNullableFilter<"CustomerFormField">
    isRequired?: BoolFilter<"CustomerFormField"> | boolean
    isActive?: BoolFilter<"CustomerFormField"> | boolean
    createdAt?: DateTimeFilter<"CustomerFormField"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerFormField"> | Date | string
    responses?: CustomerResponseListRelationFilter
  }

  export type CustomerFormFieldOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    fieldKey?: SortOrder
    type?: SortOrder
    options?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    responses?: CustomerResponseOrderByRelationAggregateInput
    _relevance?: CustomerFormFieldOrderByRelevanceInput
  }

  export type CustomerFormFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    fieldKey?: string
    AND?: CustomerFormFieldWhereInput | CustomerFormFieldWhereInput[]
    OR?: CustomerFormFieldWhereInput[]
    NOT?: CustomerFormFieldWhereInput | CustomerFormFieldWhereInput[]
    label?: StringFilter<"CustomerFormField"> | string
    type?: EnumFieldTypeFilter<"CustomerFormField"> | $Enums.FieldType
    options?: JsonNullableFilter<"CustomerFormField">
    isRequired?: BoolFilter<"CustomerFormField"> | boolean
    isActive?: BoolFilter<"CustomerFormField"> | boolean
    createdAt?: DateTimeFilter<"CustomerFormField"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerFormField"> | Date | string
    responses?: CustomerResponseListRelationFilter
  }, "id" | "fieldKey">

  export type CustomerFormFieldOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    fieldKey?: SortOrder
    type?: SortOrder
    options?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerFormFieldCountOrderByAggregateInput
    _avg?: CustomerFormFieldAvgOrderByAggregateInput
    _max?: CustomerFormFieldMaxOrderByAggregateInput
    _min?: CustomerFormFieldMinOrderByAggregateInput
    _sum?: CustomerFormFieldSumOrderByAggregateInput
  }

  export type CustomerFormFieldScalarWhereWithAggregatesInput = {
    AND?: CustomerFormFieldScalarWhereWithAggregatesInput | CustomerFormFieldScalarWhereWithAggregatesInput[]
    OR?: CustomerFormFieldScalarWhereWithAggregatesInput[]
    NOT?: CustomerFormFieldScalarWhereWithAggregatesInput | CustomerFormFieldScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CustomerFormField"> | number
    label?: StringWithAggregatesFilter<"CustomerFormField"> | string
    fieldKey?: StringWithAggregatesFilter<"CustomerFormField"> | string
    type?: EnumFieldTypeWithAggregatesFilter<"CustomerFormField"> | $Enums.FieldType
    options?: JsonNullableWithAggregatesFilter<"CustomerFormField">
    isRequired?: BoolWithAggregatesFilter<"CustomerFormField"> | boolean
    isActive?: BoolWithAggregatesFilter<"CustomerFormField"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomerFormField"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerFormField"> | Date | string
  }

  export type CustomerResponseWhereInput = {
    AND?: CustomerResponseWhereInput | CustomerResponseWhereInput[]
    OR?: CustomerResponseWhereInput[]
    NOT?: CustomerResponseWhereInput | CustomerResponseWhereInput[]
    id?: IntFilter<"CustomerResponse"> | number
    userCustomerId?: IntFilter<"CustomerResponse"> | number
    fieldId?: IntFilter<"CustomerResponse"> | number
    answer?: StringFilter<"CustomerResponse"> | string
    createdAt?: DateTimeFilter<"CustomerResponse"> | Date | string
    customer?: XOR<UserCustomerScalarRelationFilter, UserCustomerWhereInput>
    field?: XOR<CustomerFormFieldScalarRelationFilter, CustomerFormFieldWhereInput>
  }

  export type CustomerResponseOrderByWithRelationInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
    fieldId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    customer?: UserCustomerOrderByWithRelationInput
    field?: CustomerFormFieldOrderByWithRelationInput
    _relevance?: CustomerResponseOrderByRelevanceInput
  }

  export type CustomerResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomerResponseWhereInput | CustomerResponseWhereInput[]
    OR?: CustomerResponseWhereInput[]
    NOT?: CustomerResponseWhereInput | CustomerResponseWhereInput[]
    userCustomerId?: IntFilter<"CustomerResponse"> | number
    fieldId?: IntFilter<"CustomerResponse"> | number
    answer?: StringFilter<"CustomerResponse"> | string
    createdAt?: DateTimeFilter<"CustomerResponse"> | Date | string
    customer?: XOR<UserCustomerScalarRelationFilter, UserCustomerWhereInput>
    field?: XOR<CustomerFormFieldScalarRelationFilter, CustomerFormFieldWhereInput>
  }, "id">

  export type CustomerResponseOrderByWithAggregationInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
    fieldId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    _count?: CustomerResponseCountOrderByAggregateInput
    _avg?: CustomerResponseAvgOrderByAggregateInput
    _max?: CustomerResponseMaxOrderByAggregateInput
    _min?: CustomerResponseMinOrderByAggregateInput
    _sum?: CustomerResponseSumOrderByAggregateInput
  }

  export type CustomerResponseScalarWhereWithAggregatesInput = {
    AND?: CustomerResponseScalarWhereWithAggregatesInput | CustomerResponseScalarWhereWithAggregatesInput[]
    OR?: CustomerResponseScalarWhereWithAggregatesInput[]
    NOT?: CustomerResponseScalarWhereWithAggregatesInput | CustomerResponseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CustomerResponse"> | number
    userCustomerId?: IntWithAggregatesFilter<"CustomerResponse"> | number
    fieldId?: IntWithAggregatesFilter<"CustomerResponse"> | number
    answer?: StringWithAggregatesFilter<"CustomerResponse"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CustomerResponse"> | Date | string
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: BigIntFilter<"Item"> | bigint | number
    itemTypeId?: IntFilter<"Item"> | number
    itemCategoryId?: IntFilter<"Item"> | number
    name?: StringFilter<"Item"> | string
    slug?: StringFilter<"Item"> | string
    description?: StringNullableFilter<"Item"> | string | null
    shortDescription?: StringNullableFilter<"Item"> | string | null
    tags?: StringNullableFilter<"Item"> | string | null
    attributes?: JsonNullableFilter<"Item">
    metaTitle?: StringNullableFilter<"Item"> | string | null
    metaDescription?: StringNullableFilter<"Item"> | string | null
    status?: EnumItemStatusFilter<"Item"> | $Enums.ItemStatus
    isPinned?: BoolFilter<"Item"> | boolean
    isFavorite?: BoolFilter<"Item"> | boolean
    isDeleted?: BoolFilter<"Item"> | boolean
    createdBy?: IntNullableFilter<"Item"> | number | null
    updatedBy?: IntNullableFilter<"Item"> | number | null
    deletedBy?: IntNullableFilter<"Item"> | number | null
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Item"> | Date | string | null
    itemType?: XOR<ItemTypeScalarRelationFilter, ItemTypeWhereInput>
    category?: XOR<ItemCategoryScalarRelationFilter, ItemCategoryWhereInput>
    variants?: ItemVariantListRelationFilter
    images?: ItemImageListRelationFilter
    videos?: ItemVideoListRelationFilter
    updateHistories?: ItemUpdateHistoryListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    itemCategoryId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    attributes?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    status?: SortOrder
    isPinned?: SortOrder
    isFavorite?: SortOrder
    isDeleted?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    itemType?: ItemTypeOrderByWithRelationInput
    category?: ItemCategoryOrderByWithRelationInput
    variants?: ItemVariantOrderByRelationAggregateInput
    images?: ItemImageOrderByRelationAggregateInput
    videos?: ItemVideoOrderByRelationAggregateInput
    updateHistories?: ItemUpdateHistoryOrderByRelationAggregateInput
    _relevance?: ItemOrderByRelevanceInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    slug?: string
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    itemTypeId?: IntFilter<"Item"> | number
    itemCategoryId?: IntFilter<"Item"> | number
    name?: StringFilter<"Item"> | string
    description?: StringNullableFilter<"Item"> | string | null
    shortDescription?: StringNullableFilter<"Item"> | string | null
    tags?: StringNullableFilter<"Item"> | string | null
    attributes?: JsonNullableFilter<"Item">
    metaTitle?: StringNullableFilter<"Item"> | string | null
    metaDescription?: StringNullableFilter<"Item"> | string | null
    status?: EnumItemStatusFilter<"Item"> | $Enums.ItemStatus
    isPinned?: BoolFilter<"Item"> | boolean
    isFavorite?: BoolFilter<"Item"> | boolean
    isDeleted?: BoolFilter<"Item"> | boolean
    createdBy?: IntNullableFilter<"Item"> | number | null
    updatedBy?: IntNullableFilter<"Item"> | number | null
    deletedBy?: IntNullableFilter<"Item"> | number | null
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Item"> | Date | string | null
    itemType?: XOR<ItemTypeScalarRelationFilter, ItemTypeWhereInput>
    category?: XOR<ItemCategoryScalarRelationFilter, ItemCategoryWhereInput>
    variants?: ItemVariantListRelationFilter
    images?: ItemImageListRelationFilter
    videos?: ItemVideoListRelationFilter
    updateHistories?: ItemUpdateHistoryListRelationFilter
  }, "id" | "slug">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    itemCategoryId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    attributes?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    status?: SortOrder
    isPinned?: SortOrder
    isFavorite?: SortOrder
    isDeleted?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Item"> | bigint | number
    itemTypeId?: IntWithAggregatesFilter<"Item"> | number
    itemCategoryId?: IntWithAggregatesFilter<"Item"> | number
    name?: StringWithAggregatesFilter<"Item"> | string
    slug?: StringWithAggregatesFilter<"Item"> | string
    description?: StringNullableWithAggregatesFilter<"Item"> | string | null
    shortDescription?: StringNullableWithAggregatesFilter<"Item"> | string | null
    tags?: StringNullableWithAggregatesFilter<"Item"> | string | null
    attributes?: JsonNullableWithAggregatesFilter<"Item">
    metaTitle?: StringNullableWithAggregatesFilter<"Item"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Item"> | string | null
    status?: EnumItemStatusWithAggregatesFilter<"Item"> | $Enums.ItemStatus
    isPinned?: BoolWithAggregatesFilter<"Item"> | boolean
    isFavorite?: BoolWithAggregatesFilter<"Item"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"Item"> | boolean
    createdBy?: IntNullableWithAggregatesFilter<"Item"> | number | null
    updatedBy?: IntNullableWithAggregatesFilter<"Item"> | number | null
    deletedBy?: IntNullableWithAggregatesFilter<"Item"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Item"> | Date | string | null
  }

  export type ItemAttributeTemplateWhereInput = {
    AND?: ItemAttributeTemplateWhereInput | ItemAttributeTemplateWhereInput[]
    OR?: ItemAttributeTemplateWhereInput[]
    NOT?: ItemAttributeTemplateWhereInput | ItemAttributeTemplateWhereInput[]
    id?: IntFilter<"ItemAttributeTemplate"> | number
    itemCategoryId?: IntFilter<"ItemAttributeTemplate"> | number
    name?: StringFilter<"ItemAttributeTemplate"> | string
    type?: EnumAttributeTypeFilter<"ItemAttributeTemplate"> | $Enums.AttributeType
    createdBy?: IntNullableFilter<"ItemAttributeTemplate"> | number | null
    updatedBy?: IntNullableFilter<"ItemAttributeTemplate"> | number | null
    deletedBy?: IntNullableFilter<"ItemAttributeTemplate"> | number | null
    createdAt?: DateTimeFilter<"ItemAttributeTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ItemAttributeTemplate"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemAttributeTemplate"> | Date | string | null
    category?: XOR<ItemCategoryScalarRelationFilter, ItemCategoryWhereInput>
  }

  export type ItemAttributeTemplateOrderByWithRelationInput = {
    id?: SortOrder
    itemCategoryId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    category?: ItemCategoryOrderByWithRelationInput
    _relevance?: ItemAttributeTemplateOrderByRelevanceInput
  }

  export type ItemAttributeTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ItemAttributeTemplateWhereInput | ItemAttributeTemplateWhereInput[]
    OR?: ItemAttributeTemplateWhereInput[]
    NOT?: ItemAttributeTemplateWhereInput | ItemAttributeTemplateWhereInput[]
    itemCategoryId?: IntFilter<"ItemAttributeTemplate"> | number
    name?: StringFilter<"ItemAttributeTemplate"> | string
    type?: EnumAttributeTypeFilter<"ItemAttributeTemplate"> | $Enums.AttributeType
    createdBy?: IntNullableFilter<"ItemAttributeTemplate"> | number | null
    updatedBy?: IntNullableFilter<"ItemAttributeTemplate"> | number | null
    deletedBy?: IntNullableFilter<"ItemAttributeTemplate"> | number | null
    createdAt?: DateTimeFilter<"ItemAttributeTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ItemAttributeTemplate"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemAttributeTemplate"> | Date | string | null
    category?: XOR<ItemCategoryScalarRelationFilter, ItemCategoryWhereInput>
  }, "id">

  export type ItemAttributeTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    itemCategoryId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ItemAttributeTemplateCountOrderByAggregateInput
    _avg?: ItemAttributeTemplateAvgOrderByAggregateInput
    _max?: ItemAttributeTemplateMaxOrderByAggregateInput
    _min?: ItemAttributeTemplateMinOrderByAggregateInput
    _sum?: ItemAttributeTemplateSumOrderByAggregateInput
  }

  export type ItemAttributeTemplateScalarWhereWithAggregatesInput = {
    AND?: ItemAttributeTemplateScalarWhereWithAggregatesInput | ItemAttributeTemplateScalarWhereWithAggregatesInput[]
    OR?: ItemAttributeTemplateScalarWhereWithAggregatesInput[]
    NOT?: ItemAttributeTemplateScalarWhereWithAggregatesInput | ItemAttributeTemplateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItemAttributeTemplate"> | number
    itemCategoryId?: IntWithAggregatesFilter<"ItemAttributeTemplate"> | number
    name?: StringWithAggregatesFilter<"ItemAttributeTemplate"> | string
    type?: EnumAttributeTypeWithAggregatesFilter<"ItemAttributeTemplate"> | $Enums.AttributeType
    createdBy?: IntNullableWithAggregatesFilter<"ItemAttributeTemplate"> | number | null
    updatedBy?: IntNullableWithAggregatesFilter<"ItemAttributeTemplate"> | number | null
    deletedBy?: IntNullableWithAggregatesFilter<"ItemAttributeTemplate"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ItemAttributeTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ItemAttributeTemplate"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ItemAttributeTemplate"> | Date | string | null
  }

  export type ItemCategoryWhereInput = {
    AND?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    OR?: ItemCategoryWhereInput[]
    NOT?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    id?: IntFilter<"ItemCategory"> | number
    parentId?: IntNullableFilter<"ItemCategory"> | number | null
    name?: StringFilter<"ItemCategory"> | string
    createdBy?: IntNullableFilter<"ItemCategory"> | number | null
    updatedBy?: IntNullableFilter<"ItemCategory"> | number | null
    deletedBy?: IntNullableFilter<"ItemCategory"> | number | null
    createdAt?: DateTimeFilter<"ItemCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ItemCategory"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemCategory"> | Date | string | null
    parent?: XOR<ItemCategoryNullableScalarRelationFilter, ItemCategoryWhereInput> | null
    children?: ItemCategoryListRelationFilter
    items?: ItemListRelationFilter
    attributeTemplates?: ItemAttributeTemplateListRelationFilter
  }

  export type ItemCategoryOrderByWithRelationInput = {
    id?: SortOrder
    parentId?: SortOrderInput | SortOrder
    name?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    parent?: ItemCategoryOrderByWithRelationInput
    children?: ItemCategoryOrderByRelationAggregateInput
    items?: ItemOrderByRelationAggregateInput
    attributeTemplates?: ItemAttributeTemplateOrderByRelationAggregateInput
    _relevance?: ItemCategoryOrderByRelevanceInput
  }

  export type ItemCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    OR?: ItemCategoryWhereInput[]
    NOT?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    parentId?: IntNullableFilter<"ItemCategory"> | number | null
    name?: StringFilter<"ItemCategory"> | string
    createdBy?: IntNullableFilter<"ItemCategory"> | number | null
    updatedBy?: IntNullableFilter<"ItemCategory"> | number | null
    deletedBy?: IntNullableFilter<"ItemCategory"> | number | null
    createdAt?: DateTimeFilter<"ItemCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ItemCategory"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemCategory"> | Date | string | null
    parent?: XOR<ItemCategoryNullableScalarRelationFilter, ItemCategoryWhereInput> | null
    children?: ItemCategoryListRelationFilter
    items?: ItemListRelationFilter
    attributeTemplates?: ItemAttributeTemplateListRelationFilter
  }, "id">

  export type ItemCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    parentId?: SortOrderInput | SortOrder
    name?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ItemCategoryCountOrderByAggregateInput
    _avg?: ItemCategoryAvgOrderByAggregateInput
    _max?: ItemCategoryMaxOrderByAggregateInput
    _min?: ItemCategoryMinOrderByAggregateInput
    _sum?: ItemCategorySumOrderByAggregateInput
  }

  export type ItemCategoryScalarWhereWithAggregatesInput = {
    AND?: ItemCategoryScalarWhereWithAggregatesInput | ItemCategoryScalarWhereWithAggregatesInput[]
    OR?: ItemCategoryScalarWhereWithAggregatesInput[]
    NOT?: ItemCategoryScalarWhereWithAggregatesInput | ItemCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItemCategory"> | number
    parentId?: IntNullableWithAggregatesFilter<"ItemCategory"> | number | null
    name?: StringWithAggregatesFilter<"ItemCategory"> | string
    createdBy?: IntNullableWithAggregatesFilter<"ItemCategory"> | number | null
    updatedBy?: IntNullableWithAggregatesFilter<"ItemCategory"> | number | null
    deletedBy?: IntNullableWithAggregatesFilter<"ItemCategory"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ItemCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ItemCategory"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ItemCategory"> | Date | string | null
  }

  export type ItemImageWhereInput = {
    AND?: ItemImageWhereInput | ItemImageWhereInput[]
    OR?: ItemImageWhereInput[]
    NOT?: ItemImageWhereInput | ItemImageWhereInput[]
    id?: BigIntFilter<"ItemImage"> | bigint | number
    itemId?: BigIntFilter<"ItemImage"> | bigint | number
    url?: StringFilter<"ItemImage"> | string
    isPrimary?: BoolFilter<"ItemImage"> | boolean
    sortOrder?: IntFilter<"ItemImage"> | number
    createdBy?: IntNullableFilter<"ItemImage"> | number | null
    updatedBy?: IntNullableFilter<"ItemImage"> | number | null
    deletedBy?: IntNullableFilter<"ItemImage"> | number | null
    createdAt?: DateTimeFilter<"ItemImage"> | Date | string
    updatedAt?: DateTimeFilter<"ItemImage"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemImage"> | Date | string | null
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type ItemImageOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    url?: SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    item?: ItemOrderByWithRelationInput
    _relevance?: ItemImageOrderByRelevanceInput
  }

  export type ItemImageWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ItemImageWhereInput | ItemImageWhereInput[]
    OR?: ItemImageWhereInput[]
    NOT?: ItemImageWhereInput | ItemImageWhereInput[]
    itemId?: BigIntFilter<"ItemImage"> | bigint | number
    url?: StringFilter<"ItemImage"> | string
    isPrimary?: BoolFilter<"ItemImage"> | boolean
    sortOrder?: IntFilter<"ItemImage"> | number
    createdBy?: IntNullableFilter<"ItemImage"> | number | null
    updatedBy?: IntNullableFilter<"ItemImage"> | number | null
    deletedBy?: IntNullableFilter<"ItemImage"> | number | null
    createdAt?: DateTimeFilter<"ItemImage"> | Date | string
    updatedAt?: DateTimeFilter<"ItemImage"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemImage"> | Date | string | null
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type ItemImageOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    url?: SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ItemImageCountOrderByAggregateInput
    _avg?: ItemImageAvgOrderByAggregateInput
    _max?: ItemImageMaxOrderByAggregateInput
    _min?: ItemImageMinOrderByAggregateInput
    _sum?: ItemImageSumOrderByAggregateInput
  }

  export type ItemImageScalarWhereWithAggregatesInput = {
    AND?: ItemImageScalarWhereWithAggregatesInput | ItemImageScalarWhereWithAggregatesInput[]
    OR?: ItemImageScalarWhereWithAggregatesInput[]
    NOT?: ItemImageScalarWhereWithAggregatesInput | ItemImageScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"ItemImage"> | bigint | number
    itemId?: BigIntWithAggregatesFilter<"ItemImage"> | bigint | number
    url?: StringWithAggregatesFilter<"ItemImage"> | string
    isPrimary?: BoolWithAggregatesFilter<"ItemImage"> | boolean
    sortOrder?: IntWithAggregatesFilter<"ItemImage"> | number
    createdBy?: IntNullableWithAggregatesFilter<"ItemImage"> | number | null
    updatedBy?: IntNullableWithAggregatesFilter<"ItemImage"> | number | null
    deletedBy?: IntNullableWithAggregatesFilter<"ItemImage"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ItemImage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ItemImage"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ItemImage"> | Date | string | null
  }

  export type ItemPriceWhereInput = {
    AND?: ItemPriceWhereInput | ItemPriceWhereInput[]
    OR?: ItemPriceWhereInput[]
    NOT?: ItemPriceWhereInput | ItemPriceWhereInput[]
    id?: BigIntFilter<"ItemPrice"> | bigint | number
    itemVariantId?: BigIntFilter<"ItemPrice"> | bigint | number
    price?: DecimalFilter<"ItemPrice"> | Decimal | DecimalJsLike | number | string
    priceType?: EnumPriceTypeFilter<"ItemPrice"> | $Enums.PriceType
    startDate?: DateTimeNullableFilter<"ItemPrice"> | Date | string | null
    endDate?: DateTimeNullableFilter<"ItemPrice"> | Date | string | null
    dayOfWeek?: IntNullableFilter<"ItemPrice"> | number | null
    startTime?: StringNullableFilter<"ItemPrice"> | string | null
    endTime?: StringNullableFilter<"ItemPrice"> | string | null
    createdBy?: IntNullableFilter<"ItemPrice"> | number | null
    updatedBy?: IntNullableFilter<"ItemPrice"> | number | null
    deletedBy?: IntNullableFilter<"ItemPrice"> | number | null
    createdAt?: DateTimeFilter<"ItemPrice"> | Date | string
    updatedAt?: DateTimeFilter<"ItemPrice"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemPrice"> | Date | string | null
    variant?: XOR<ItemVariantScalarRelationFilter, ItemVariantWhereInput>
  }

  export type ItemPriceOrderByWithRelationInput = {
    id?: SortOrder
    itemVariantId?: SortOrder
    price?: SortOrder
    priceType?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    variant?: ItemVariantOrderByWithRelationInput
    _relevance?: ItemPriceOrderByRelevanceInput
  }

  export type ItemPriceWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ItemPriceWhereInput | ItemPriceWhereInput[]
    OR?: ItemPriceWhereInput[]
    NOT?: ItemPriceWhereInput | ItemPriceWhereInput[]
    itemVariantId?: BigIntFilter<"ItemPrice"> | bigint | number
    price?: DecimalFilter<"ItemPrice"> | Decimal | DecimalJsLike | number | string
    priceType?: EnumPriceTypeFilter<"ItemPrice"> | $Enums.PriceType
    startDate?: DateTimeNullableFilter<"ItemPrice"> | Date | string | null
    endDate?: DateTimeNullableFilter<"ItemPrice"> | Date | string | null
    dayOfWeek?: IntNullableFilter<"ItemPrice"> | number | null
    startTime?: StringNullableFilter<"ItemPrice"> | string | null
    endTime?: StringNullableFilter<"ItemPrice"> | string | null
    createdBy?: IntNullableFilter<"ItemPrice"> | number | null
    updatedBy?: IntNullableFilter<"ItemPrice"> | number | null
    deletedBy?: IntNullableFilter<"ItemPrice"> | number | null
    createdAt?: DateTimeFilter<"ItemPrice"> | Date | string
    updatedAt?: DateTimeFilter<"ItemPrice"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemPrice"> | Date | string | null
    variant?: XOR<ItemVariantScalarRelationFilter, ItemVariantWhereInput>
  }, "id">

  export type ItemPriceOrderByWithAggregationInput = {
    id?: SortOrder
    itemVariantId?: SortOrder
    price?: SortOrder
    priceType?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ItemPriceCountOrderByAggregateInput
    _avg?: ItemPriceAvgOrderByAggregateInput
    _max?: ItemPriceMaxOrderByAggregateInput
    _min?: ItemPriceMinOrderByAggregateInput
    _sum?: ItemPriceSumOrderByAggregateInput
  }

  export type ItemPriceScalarWhereWithAggregatesInput = {
    AND?: ItemPriceScalarWhereWithAggregatesInput | ItemPriceScalarWhereWithAggregatesInput[]
    OR?: ItemPriceScalarWhereWithAggregatesInput[]
    NOT?: ItemPriceScalarWhereWithAggregatesInput | ItemPriceScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"ItemPrice"> | bigint | number
    itemVariantId?: BigIntWithAggregatesFilter<"ItemPrice"> | bigint | number
    price?: DecimalWithAggregatesFilter<"ItemPrice"> | Decimal | DecimalJsLike | number | string
    priceType?: EnumPriceTypeWithAggregatesFilter<"ItemPrice"> | $Enums.PriceType
    startDate?: DateTimeNullableWithAggregatesFilter<"ItemPrice"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"ItemPrice"> | Date | string | null
    dayOfWeek?: IntNullableWithAggregatesFilter<"ItemPrice"> | number | null
    startTime?: StringNullableWithAggregatesFilter<"ItemPrice"> | string | null
    endTime?: StringNullableWithAggregatesFilter<"ItemPrice"> | string | null
    createdBy?: IntNullableWithAggregatesFilter<"ItemPrice"> | number | null
    updatedBy?: IntNullableWithAggregatesFilter<"ItemPrice"> | number | null
    deletedBy?: IntNullableWithAggregatesFilter<"ItemPrice"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ItemPrice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ItemPrice"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ItemPrice"> | Date | string | null
  }

  export type ItemTypeWhereInput = {
    AND?: ItemTypeWhereInput | ItemTypeWhereInput[]
    OR?: ItemTypeWhereInput[]
    NOT?: ItemTypeWhereInput | ItemTypeWhereInput[]
    id?: IntFilter<"ItemType"> | number
    name?: StringFilter<"ItemType"> | string
    description?: StringNullableFilter<"ItemType"> | string | null
    createdBy?: IntNullableFilter<"ItemType"> | number | null
    updatedBy?: IntNullableFilter<"ItemType"> | number | null
    deletedBy?: IntNullableFilter<"ItemType"> | number | null
    createdAt?: DateTimeFilter<"ItemType"> | Date | string
    updatedAt?: DateTimeFilter<"ItemType"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemType"> | Date | string | null
    items?: ItemListRelationFilter
  }

  export type ItemTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    items?: ItemOrderByRelationAggregateInput
    _relevance?: ItemTypeOrderByRelevanceInput
  }

  export type ItemTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ItemTypeWhereInput | ItemTypeWhereInput[]
    OR?: ItemTypeWhereInput[]
    NOT?: ItemTypeWhereInput | ItemTypeWhereInput[]
    name?: StringFilter<"ItemType"> | string
    description?: StringNullableFilter<"ItemType"> | string | null
    createdBy?: IntNullableFilter<"ItemType"> | number | null
    updatedBy?: IntNullableFilter<"ItemType"> | number | null
    deletedBy?: IntNullableFilter<"ItemType"> | number | null
    createdAt?: DateTimeFilter<"ItemType"> | Date | string
    updatedAt?: DateTimeFilter<"ItemType"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemType"> | Date | string | null
    items?: ItemListRelationFilter
  }, "id">

  export type ItemTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ItemTypeCountOrderByAggregateInput
    _avg?: ItemTypeAvgOrderByAggregateInput
    _max?: ItemTypeMaxOrderByAggregateInput
    _min?: ItemTypeMinOrderByAggregateInput
    _sum?: ItemTypeSumOrderByAggregateInput
  }

  export type ItemTypeScalarWhereWithAggregatesInput = {
    AND?: ItemTypeScalarWhereWithAggregatesInput | ItemTypeScalarWhereWithAggregatesInput[]
    OR?: ItemTypeScalarWhereWithAggregatesInput[]
    NOT?: ItemTypeScalarWhereWithAggregatesInput | ItemTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItemType"> | number
    name?: StringWithAggregatesFilter<"ItemType"> | string
    description?: StringNullableWithAggregatesFilter<"ItemType"> | string | null
    createdBy?: IntNullableWithAggregatesFilter<"ItemType"> | number | null
    updatedBy?: IntNullableWithAggregatesFilter<"ItemType"> | number | null
    deletedBy?: IntNullableWithAggregatesFilter<"ItemType"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ItemType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ItemType"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ItemType"> | Date | string | null
  }

  export type ItemUpdateHistoryWhereInput = {
    AND?: ItemUpdateHistoryWhereInput | ItemUpdateHistoryWhereInput[]
    OR?: ItemUpdateHistoryWhereInput[]
    NOT?: ItemUpdateHistoryWhereInput | ItemUpdateHistoryWhereInput[]
    id?: BigIntFilter<"ItemUpdateHistory"> | bigint | number
    itemId?: BigIntFilter<"ItemUpdateHistory"> | bigint | number
    itemName?: StringFilter<"ItemUpdateHistory"> | string
    userId?: IntFilter<"ItemUpdateHistory"> | number
    userName?: StringFilter<"ItemUpdateHistory"> | string
    columnName?: StringFilter<"ItemUpdateHistory"> | string
    createdAt?: DateTimeFilter<"ItemUpdateHistory"> | Date | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type ItemUpdateHistoryOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    itemName?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    columnName?: SortOrder
    createdAt?: SortOrder
    item?: ItemOrderByWithRelationInput
    _relevance?: ItemUpdateHistoryOrderByRelevanceInput
  }

  export type ItemUpdateHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ItemUpdateHistoryWhereInput | ItemUpdateHistoryWhereInput[]
    OR?: ItemUpdateHistoryWhereInput[]
    NOT?: ItemUpdateHistoryWhereInput | ItemUpdateHistoryWhereInput[]
    itemId?: BigIntFilter<"ItemUpdateHistory"> | bigint | number
    itemName?: StringFilter<"ItemUpdateHistory"> | string
    userId?: IntFilter<"ItemUpdateHistory"> | number
    userName?: StringFilter<"ItemUpdateHistory"> | string
    columnName?: StringFilter<"ItemUpdateHistory"> | string
    createdAt?: DateTimeFilter<"ItemUpdateHistory"> | Date | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type ItemUpdateHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    itemName?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    columnName?: SortOrder
    createdAt?: SortOrder
    _count?: ItemUpdateHistoryCountOrderByAggregateInput
    _avg?: ItemUpdateHistoryAvgOrderByAggregateInput
    _max?: ItemUpdateHistoryMaxOrderByAggregateInput
    _min?: ItemUpdateHistoryMinOrderByAggregateInput
    _sum?: ItemUpdateHistorySumOrderByAggregateInput
  }

  export type ItemUpdateHistoryScalarWhereWithAggregatesInput = {
    AND?: ItemUpdateHistoryScalarWhereWithAggregatesInput | ItemUpdateHistoryScalarWhereWithAggregatesInput[]
    OR?: ItemUpdateHistoryScalarWhereWithAggregatesInput[]
    NOT?: ItemUpdateHistoryScalarWhereWithAggregatesInput | ItemUpdateHistoryScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"ItemUpdateHistory"> | bigint | number
    itemId?: BigIntWithAggregatesFilter<"ItemUpdateHistory"> | bigint | number
    itemName?: StringWithAggregatesFilter<"ItemUpdateHistory"> | string
    userId?: IntWithAggregatesFilter<"ItemUpdateHistory"> | number
    userName?: StringWithAggregatesFilter<"ItemUpdateHistory"> | string
    columnName?: StringWithAggregatesFilter<"ItemUpdateHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ItemUpdateHistory"> | Date | string
  }

  export type ItemVariantWhereInput = {
    AND?: ItemVariantWhereInput | ItemVariantWhereInput[]
    OR?: ItemVariantWhereInput[]
    NOT?: ItemVariantWhereInput | ItemVariantWhereInput[]
    id?: BigIntFilter<"ItemVariant"> | bigint | number
    itemId?: BigIntFilter<"ItemVariant"> | bigint | number
    code?: StringFilter<"ItemVariant"> | string
    name?: StringNullableFilter<"ItemVariant"> | string | null
    imageUrl?: StringNullableFilter<"ItemVariant"> | string | null
    price?: DecimalFilter<"ItemVariant"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"ItemVariant"> | number
    options?: JsonNullableFilter<"ItemVariant">
    isActive?: BoolFilter<"ItemVariant"> | boolean
    createdBy?: IntNullableFilter<"ItemVariant"> | number | null
    updatedBy?: IntNullableFilter<"ItemVariant"> | number | null
    deletedBy?: IntNullableFilter<"ItemVariant"> | number | null
    createdAt?: DateTimeFilter<"ItemVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ItemVariant"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemVariant"> | Date | string | null
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    prices?: ItemPriceListRelationFilter
  }

  export type ItemVariantOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    code?: SortOrder
    name?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    price?: SortOrder
    quantity?: SortOrder
    options?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    item?: ItemOrderByWithRelationInput
    prices?: ItemPriceOrderByRelationAggregateInput
    _relevance?: ItemVariantOrderByRelevanceInput
  }

  export type ItemVariantWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    code?: string
    AND?: ItemVariantWhereInput | ItemVariantWhereInput[]
    OR?: ItemVariantWhereInput[]
    NOT?: ItemVariantWhereInput | ItemVariantWhereInput[]
    itemId?: BigIntFilter<"ItemVariant"> | bigint | number
    name?: StringNullableFilter<"ItemVariant"> | string | null
    imageUrl?: StringNullableFilter<"ItemVariant"> | string | null
    price?: DecimalFilter<"ItemVariant"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"ItemVariant"> | number
    options?: JsonNullableFilter<"ItemVariant">
    isActive?: BoolFilter<"ItemVariant"> | boolean
    createdBy?: IntNullableFilter<"ItemVariant"> | number | null
    updatedBy?: IntNullableFilter<"ItemVariant"> | number | null
    deletedBy?: IntNullableFilter<"ItemVariant"> | number | null
    createdAt?: DateTimeFilter<"ItemVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ItemVariant"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemVariant"> | Date | string | null
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    prices?: ItemPriceListRelationFilter
  }, "id" | "code">

  export type ItemVariantOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    code?: SortOrder
    name?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    price?: SortOrder
    quantity?: SortOrder
    options?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ItemVariantCountOrderByAggregateInput
    _avg?: ItemVariantAvgOrderByAggregateInput
    _max?: ItemVariantMaxOrderByAggregateInput
    _min?: ItemVariantMinOrderByAggregateInput
    _sum?: ItemVariantSumOrderByAggregateInput
  }

  export type ItemVariantScalarWhereWithAggregatesInput = {
    AND?: ItemVariantScalarWhereWithAggregatesInput | ItemVariantScalarWhereWithAggregatesInput[]
    OR?: ItemVariantScalarWhereWithAggregatesInput[]
    NOT?: ItemVariantScalarWhereWithAggregatesInput | ItemVariantScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"ItemVariant"> | bigint | number
    itemId?: BigIntWithAggregatesFilter<"ItemVariant"> | bigint | number
    code?: StringWithAggregatesFilter<"ItemVariant"> | string
    name?: StringNullableWithAggregatesFilter<"ItemVariant"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"ItemVariant"> | string | null
    price?: DecimalWithAggregatesFilter<"ItemVariant"> | Decimal | DecimalJsLike | number | string
    quantity?: IntWithAggregatesFilter<"ItemVariant"> | number
    options?: JsonNullableWithAggregatesFilter<"ItemVariant">
    isActive?: BoolWithAggregatesFilter<"ItemVariant"> | boolean
    createdBy?: IntNullableWithAggregatesFilter<"ItemVariant"> | number | null
    updatedBy?: IntNullableWithAggregatesFilter<"ItemVariant"> | number | null
    deletedBy?: IntNullableWithAggregatesFilter<"ItemVariant"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ItemVariant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ItemVariant"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ItemVariant"> | Date | string | null
  }

  export type ItemVideoWhereInput = {
    AND?: ItemVideoWhereInput | ItemVideoWhereInput[]
    OR?: ItemVideoWhereInput[]
    NOT?: ItemVideoWhereInput | ItemVideoWhereInput[]
    id?: BigIntFilter<"ItemVideo"> | bigint | number
    itemId?: BigIntFilter<"ItemVideo"> | bigint | number
    url?: StringFilter<"ItemVideo"> | string
    provider?: StringNullableFilter<"ItemVideo"> | string | null
    isPrimary?: BoolFilter<"ItemVideo"> | boolean
    sortOrder?: IntFilter<"ItemVideo"> | number
    createdBy?: IntNullableFilter<"ItemVideo"> | number | null
    updatedBy?: IntNullableFilter<"ItemVideo"> | number | null
    deletedBy?: IntNullableFilter<"ItemVideo"> | number | null
    createdAt?: DateTimeFilter<"ItemVideo"> | Date | string
    updatedAt?: DateTimeFilter<"ItemVideo"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemVideo"> | Date | string | null
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type ItemVideoOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    url?: SortOrder
    provider?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    item?: ItemOrderByWithRelationInput
    _relevance?: ItemVideoOrderByRelevanceInput
  }

  export type ItemVideoWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ItemVideoWhereInput | ItemVideoWhereInput[]
    OR?: ItemVideoWhereInput[]
    NOT?: ItemVideoWhereInput | ItemVideoWhereInput[]
    itemId?: BigIntFilter<"ItemVideo"> | bigint | number
    url?: StringFilter<"ItemVideo"> | string
    provider?: StringNullableFilter<"ItemVideo"> | string | null
    isPrimary?: BoolFilter<"ItemVideo"> | boolean
    sortOrder?: IntFilter<"ItemVideo"> | number
    createdBy?: IntNullableFilter<"ItemVideo"> | number | null
    updatedBy?: IntNullableFilter<"ItemVideo"> | number | null
    deletedBy?: IntNullableFilter<"ItemVideo"> | number | null
    createdAt?: DateTimeFilter<"ItemVideo"> | Date | string
    updatedAt?: DateTimeFilter<"ItemVideo"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemVideo"> | Date | string | null
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type ItemVideoOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    url?: SortOrder
    provider?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ItemVideoCountOrderByAggregateInput
    _avg?: ItemVideoAvgOrderByAggregateInput
    _max?: ItemVideoMaxOrderByAggregateInput
    _min?: ItemVideoMinOrderByAggregateInput
    _sum?: ItemVideoSumOrderByAggregateInput
  }

  export type ItemVideoScalarWhereWithAggregatesInput = {
    AND?: ItemVideoScalarWhereWithAggregatesInput | ItemVideoScalarWhereWithAggregatesInput[]
    OR?: ItemVideoScalarWhereWithAggregatesInput[]
    NOT?: ItemVideoScalarWhereWithAggregatesInput | ItemVideoScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"ItemVideo"> | bigint | number
    itemId?: BigIntWithAggregatesFilter<"ItemVideo"> | bigint | number
    url?: StringWithAggregatesFilter<"ItemVideo"> | string
    provider?: StringNullableWithAggregatesFilter<"ItemVideo"> | string | null
    isPrimary?: BoolWithAggregatesFilter<"ItemVideo"> | boolean
    sortOrder?: IntWithAggregatesFilter<"ItemVideo"> | number
    createdBy?: IntNullableWithAggregatesFilter<"ItemVideo"> | number | null
    updatedBy?: IntNullableWithAggregatesFilter<"ItemVideo"> | number | null
    deletedBy?: IntNullableWithAggregatesFilter<"ItemVideo"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ItemVideo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ItemVideo"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ItemVideo"> | Date | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    adminProfile?: XOR<UserAdminNullableScalarRelationFilter, UserAdminWhereInput> | null
    customerProfile?: XOR<UserCustomerNullableScalarRelationFilter, UserCustomerWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    adminProfile?: UserAdminOrderByWithRelationInput
    customerProfile?: UserCustomerOrderByWithRelationInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    adminProfile?: XOR<UserAdminNullableScalarRelationFilter, UserAdminWhereInput> | null
    customerProfile?: XOR<UserCustomerNullableScalarRelationFilter, UserCustomerWhereInput> | null
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type UserAdminWhereInput = {
    AND?: UserAdminWhereInput | UserAdminWhereInput[]
    OR?: UserAdminWhereInput[]
    NOT?: UserAdminWhereInput | UserAdminWhereInput[]
    id?: IntFilter<"UserAdmin"> | number
    userId?: IntFilter<"UserAdmin"> | number
    fullName?: StringFilter<"UserAdmin"> | string
    employeeId?: StringNullableFilter<"UserAdmin"> | string | null
    department?: StringNullableFilter<"UserAdmin"> | string | null
    phoneNumber?: StringNullableFilter<"UserAdmin"> | string | null
    accessLevel?: IntFilter<"UserAdmin"> | number
    lastLoginAt?: DateTimeNullableFilter<"UserAdmin"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"UserAdmin"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserAdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    accessLevel?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: UserAdminOrderByRelevanceInput
  }

  export type UserAdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    employeeId?: string
    AND?: UserAdminWhereInput | UserAdminWhereInput[]
    OR?: UserAdminWhereInput[]
    NOT?: UserAdminWhereInput | UserAdminWhereInput[]
    fullName?: StringFilter<"UserAdmin"> | string
    department?: StringNullableFilter<"UserAdmin"> | string | null
    phoneNumber?: StringNullableFilter<"UserAdmin"> | string | null
    accessLevel?: IntFilter<"UserAdmin"> | number
    lastLoginAt?: DateTimeNullableFilter<"UserAdmin"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"UserAdmin"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId" | "employeeId">

  export type UserAdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    accessLevel?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    _count?: UserAdminCountOrderByAggregateInput
    _avg?: UserAdminAvgOrderByAggregateInput
    _max?: UserAdminMaxOrderByAggregateInput
    _min?: UserAdminMinOrderByAggregateInput
    _sum?: UserAdminSumOrderByAggregateInput
  }

  export type UserAdminScalarWhereWithAggregatesInput = {
    AND?: UserAdminScalarWhereWithAggregatesInput | UserAdminScalarWhereWithAggregatesInput[]
    OR?: UserAdminScalarWhereWithAggregatesInput[]
    NOT?: UserAdminScalarWhereWithAggregatesInput | UserAdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserAdmin"> | number
    userId?: IntWithAggregatesFilter<"UserAdmin"> | number
    fullName?: StringWithAggregatesFilter<"UserAdmin"> | string
    employeeId?: StringNullableWithAggregatesFilter<"UserAdmin"> | string | null
    department?: StringNullableWithAggregatesFilter<"UserAdmin"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"UserAdmin"> | string | null
    accessLevel?: IntWithAggregatesFilter<"UserAdmin"> | number
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"UserAdmin"> | Date | string | null
    lastLoginIp?: StringNullableWithAggregatesFilter<"UserAdmin"> | string | null
  }

  export type UserCustomerWhereInput = {
    AND?: UserCustomerWhereInput | UserCustomerWhereInput[]
    OR?: UserCustomerWhereInput[]
    NOT?: UserCustomerWhereInput | UserCustomerWhereInput[]
    id?: IntFilter<"UserCustomer"> | number
    userId?: IntFilter<"UserCustomer"> | number
    fullName?: StringFilter<"UserCustomer"> | string
    phoneNumber?: StringNullableFilter<"UserCustomer"> | string | null
    birthDate?: DateTimeNullableFilter<"UserCustomer"> | Date | string | null
    loyaltyPoint?: IntFilter<"UserCustomer"> | number
    referralCode?: StringNullableFilter<"UserCustomer"> | string | null
    isVerified?: BoolFilter<"UserCustomer"> | boolean
    verifiedAt?: DateTimeNullableFilter<"UserCustomer"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    addresses?: UserCustomerAddressListRelationFilter
    member?: XOR<UserMemberNullableScalarRelationFilter, UserMemberWhereInput> | null
    responses?: CustomerResponseListRelationFilter
  }

  export type UserCustomerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    loyaltyPoint?: SortOrder
    referralCode?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    addresses?: UserCustomerAddressOrderByRelationAggregateInput
    member?: UserMemberOrderByWithRelationInput
    responses?: CustomerResponseOrderByRelationAggregateInput
    _relevance?: UserCustomerOrderByRelevanceInput
  }

  export type UserCustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    referralCode?: string
    AND?: UserCustomerWhereInput | UserCustomerWhereInput[]
    OR?: UserCustomerWhereInput[]
    NOT?: UserCustomerWhereInput | UserCustomerWhereInput[]
    fullName?: StringFilter<"UserCustomer"> | string
    phoneNumber?: StringNullableFilter<"UserCustomer"> | string | null
    birthDate?: DateTimeNullableFilter<"UserCustomer"> | Date | string | null
    loyaltyPoint?: IntFilter<"UserCustomer"> | number
    isVerified?: BoolFilter<"UserCustomer"> | boolean
    verifiedAt?: DateTimeNullableFilter<"UserCustomer"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    addresses?: UserCustomerAddressListRelationFilter
    member?: XOR<UserMemberNullableScalarRelationFilter, UserMemberWhereInput> | null
    responses?: CustomerResponseListRelationFilter
  }, "id" | "userId" | "referralCode">

  export type UserCustomerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    loyaltyPoint?: SortOrder
    referralCode?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    _count?: UserCustomerCountOrderByAggregateInput
    _avg?: UserCustomerAvgOrderByAggregateInput
    _max?: UserCustomerMaxOrderByAggregateInput
    _min?: UserCustomerMinOrderByAggregateInput
    _sum?: UserCustomerSumOrderByAggregateInput
  }

  export type UserCustomerScalarWhereWithAggregatesInput = {
    AND?: UserCustomerScalarWhereWithAggregatesInput | UserCustomerScalarWhereWithAggregatesInput[]
    OR?: UserCustomerScalarWhereWithAggregatesInput[]
    NOT?: UserCustomerScalarWhereWithAggregatesInput | UserCustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserCustomer"> | number
    userId?: IntWithAggregatesFilter<"UserCustomer"> | number
    fullName?: StringWithAggregatesFilter<"UserCustomer"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"UserCustomer"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"UserCustomer"> | Date | string | null
    loyaltyPoint?: IntWithAggregatesFilter<"UserCustomer"> | number
    referralCode?: StringNullableWithAggregatesFilter<"UserCustomer"> | string | null
    isVerified?: BoolWithAggregatesFilter<"UserCustomer"> | boolean
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"UserCustomer"> | Date | string | null
  }

  export type UserCustomerAddressWhereInput = {
    AND?: UserCustomerAddressWhereInput | UserCustomerAddressWhereInput[]
    OR?: UserCustomerAddressWhereInput[]
    NOT?: UserCustomerAddressWhereInput | UserCustomerAddressWhereInput[]
    id?: IntFilter<"UserCustomerAddress"> | number
    userCustomerId?: IntFilter<"UserCustomerAddress"> | number
    label?: StringFilter<"UserCustomerAddress"> | string
    recipientName?: StringFilter<"UserCustomerAddress"> | string
    recipientPhone?: StringFilter<"UserCustomerAddress"> | string
    fullAddress?: StringFilter<"UserCustomerAddress"> | string
    note?: StringNullableFilter<"UserCustomerAddress"> | string | null
    isPrimary?: BoolFilter<"UserCustomerAddress"> | boolean
    customer?: XOR<UserCustomerScalarRelationFilter, UserCustomerWhereInput>
  }

  export type UserCustomerAddressOrderByWithRelationInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
    label?: SortOrder
    recipientName?: SortOrder
    recipientPhone?: SortOrder
    fullAddress?: SortOrder
    note?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    customer?: UserCustomerOrderByWithRelationInput
    _relevance?: UserCustomerAddressOrderByRelevanceInput
  }

  export type UserCustomerAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserCustomerAddressWhereInput | UserCustomerAddressWhereInput[]
    OR?: UserCustomerAddressWhereInput[]
    NOT?: UserCustomerAddressWhereInput | UserCustomerAddressWhereInput[]
    userCustomerId?: IntFilter<"UserCustomerAddress"> | number
    label?: StringFilter<"UserCustomerAddress"> | string
    recipientName?: StringFilter<"UserCustomerAddress"> | string
    recipientPhone?: StringFilter<"UserCustomerAddress"> | string
    fullAddress?: StringFilter<"UserCustomerAddress"> | string
    note?: StringNullableFilter<"UserCustomerAddress"> | string | null
    isPrimary?: BoolFilter<"UserCustomerAddress"> | boolean
    customer?: XOR<UserCustomerScalarRelationFilter, UserCustomerWhereInput>
  }, "id">

  export type UserCustomerAddressOrderByWithAggregationInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
    label?: SortOrder
    recipientName?: SortOrder
    recipientPhone?: SortOrder
    fullAddress?: SortOrder
    note?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    _count?: UserCustomerAddressCountOrderByAggregateInput
    _avg?: UserCustomerAddressAvgOrderByAggregateInput
    _max?: UserCustomerAddressMaxOrderByAggregateInput
    _min?: UserCustomerAddressMinOrderByAggregateInput
    _sum?: UserCustomerAddressSumOrderByAggregateInput
  }

  export type UserCustomerAddressScalarWhereWithAggregatesInput = {
    AND?: UserCustomerAddressScalarWhereWithAggregatesInput | UserCustomerAddressScalarWhereWithAggregatesInput[]
    OR?: UserCustomerAddressScalarWhereWithAggregatesInput[]
    NOT?: UserCustomerAddressScalarWhereWithAggregatesInput | UserCustomerAddressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserCustomerAddress"> | number
    userCustomerId?: IntWithAggregatesFilter<"UserCustomerAddress"> | number
    label?: StringWithAggregatesFilter<"UserCustomerAddress"> | string
    recipientName?: StringWithAggregatesFilter<"UserCustomerAddress"> | string
    recipientPhone?: StringWithAggregatesFilter<"UserCustomerAddress"> | string
    fullAddress?: StringWithAggregatesFilter<"UserCustomerAddress"> | string
    note?: StringNullableWithAggregatesFilter<"UserCustomerAddress"> | string | null
    isPrimary?: BoolWithAggregatesFilter<"UserCustomerAddress"> | boolean
  }

  export type UserMemberWhereInput = {
    AND?: UserMemberWhereInput | UserMemberWhereInput[]
    OR?: UserMemberWhereInput[]
    NOT?: UserMemberWhereInput | UserMemberWhereInput[]
    id?: IntFilter<"UserMember"> | number
    userCustomerId?: IntFilter<"UserMember"> | number
    tier?: EnumMemberTierFilter<"UserMember"> | $Enums.MemberTier
    memberNumber?: StringFilter<"UserMember"> | string
    joinedAt?: DateTimeFilter<"UserMember"> | Date | string
    expiredAt?: DateTimeNullableFilter<"UserMember"> | Date | string | null
    customer?: XOR<UserCustomerScalarRelationFilter, UserCustomerWhereInput>
  }

  export type UserMemberOrderByWithRelationInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
    tier?: SortOrder
    memberNumber?: SortOrder
    joinedAt?: SortOrder
    expiredAt?: SortOrderInput | SortOrder
    customer?: UserCustomerOrderByWithRelationInput
    _relevance?: UserMemberOrderByRelevanceInput
  }

  export type UserMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userCustomerId?: number
    memberNumber?: string
    AND?: UserMemberWhereInput | UserMemberWhereInput[]
    OR?: UserMemberWhereInput[]
    NOT?: UserMemberWhereInput | UserMemberWhereInput[]
    tier?: EnumMemberTierFilter<"UserMember"> | $Enums.MemberTier
    joinedAt?: DateTimeFilter<"UserMember"> | Date | string
    expiredAt?: DateTimeNullableFilter<"UserMember"> | Date | string | null
    customer?: XOR<UserCustomerScalarRelationFilter, UserCustomerWhereInput>
  }, "id" | "userCustomerId" | "memberNumber">

  export type UserMemberOrderByWithAggregationInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
    tier?: SortOrder
    memberNumber?: SortOrder
    joinedAt?: SortOrder
    expiredAt?: SortOrderInput | SortOrder
    _count?: UserMemberCountOrderByAggregateInput
    _avg?: UserMemberAvgOrderByAggregateInput
    _max?: UserMemberMaxOrderByAggregateInput
    _min?: UserMemberMinOrderByAggregateInput
    _sum?: UserMemberSumOrderByAggregateInput
  }

  export type UserMemberScalarWhereWithAggregatesInput = {
    AND?: UserMemberScalarWhereWithAggregatesInput | UserMemberScalarWhereWithAggregatesInput[]
    OR?: UserMemberScalarWhereWithAggregatesInput[]
    NOT?: UserMemberScalarWhereWithAggregatesInput | UserMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserMember"> | number
    userCustomerId?: IntWithAggregatesFilter<"UserMember"> | number
    tier?: EnumMemberTierWithAggregatesFilter<"UserMember"> | $Enums.MemberTier
    memberNumber?: StringWithAggregatesFilter<"UserMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"UserMember"> | Date | string
    expiredAt?: DateTimeNullableWithAggregatesFilter<"UserMember"> | Date | string | null
  }

  export type CustomerFormFieldCreateInput = {
    label: string
    fieldKey: string
    type?: $Enums.FieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: CustomerResponseCreateNestedManyWithoutFieldInput
  }

  export type CustomerFormFieldUncheckedCreateInput = {
    id?: number
    label: string
    fieldKey: string
    type?: $Enums.FieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: CustomerResponseUncheckedCreateNestedManyWithoutFieldInput
  }

  export type CustomerFormFieldUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    fieldKey?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: CustomerResponseUpdateManyWithoutFieldNestedInput
  }

  export type CustomerFormFieldUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    fieldKey?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: CustomerResponseUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type CustomerFormFieldCreateManyInput = {
    id?: number
    label: string
    fieldKey: string
    type?: $Enums.FieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerFormFieldUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    fieldKey?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerFormFieldUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    fieldKey?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerResponseCreateInput = {
    answer: string
    createdAt?: Date | string
    customer: UserCustomerCreateNestedOneWithoutResponsesInput
    field: CustomerFormFieldCreateNestedOneWithoutResponsesInput
  }

  export type CustomerResponseUncheckedCreateInput = {
    id?: number
    userCustomerId: number
    fieldId: number
    answer: string
    createdAt?: Date | string
  }

  export type CustomerResponseUpdateInput = {
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserCustomerUpdateOneRequiredWithoutResponsesNestedInput
    field?: CustomerFormFieldUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type CustomerResponseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCustomerId?: IntFieldUpdateOperationsInput | number
    fieldId?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerResponseCreateManyInput = {
    id?: number
    userCustomerId: number
    fieldId: number
    answer: string
    createdAt?: Date | string
  }

  export type CustomerResponseUpdateManyMutationInput = {
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerResponseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCustomerId?: IntFieldUpdateOperationsInput | number
    fieldId?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateInput = {
    id?: bigint | number
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    tags?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    status?: $Enums.ItemStatus
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    itemType: ItemTypeCreateNestedOneWithoutItemsInput
    category: ItemCategoryCreateNestedOneWithoutItemsInput
    variants?: ItemVariantCreateNestedManyWithoutItemInput
    images?: ItemImageCreateNestedManyWithoutItemInput
    videos?: ItemVideoCreateNestedManyWithoutItemInput
    updateHistories?: ItemUpdateHistoryCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: bigint | number
    itemTypeId: number
    itemCategoryId: number
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    tags?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    status?: $Enums.ItemStatus
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    variants?: ItemVariantUncheckedCreateNestedManyWithoutItemInput
    images?: ItemImageUncheckedCreateNestedManyWithoutItemInput
    videos?: ItemVideoUncheckedCreateNestedManyWithoutItemInput
    updateHistories?: ItemUpdateHistoryUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumItemStatusFieldUpdateOperationsInput | $Enums.ItemStatus
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemType?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    category?: ItemCategoryUpdateOneRequiredWithoutItemsNestedInput
    variants?: ItemVariantUpdateManyWithoutItemNestedInput
    images?: ItemImageUpdateManyWithoutItemNestedInput
    videos?: ItemVideoUpdateManyWithoutItemNestedInput
    updateHistories?: ItemUpdateHistoryUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    itemCategoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumItemStatusFieldUpdateOperationsInput | $Enums.ItemStatus
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variants?: ItemVariantUncheckedUpdateManyWithoutItemNestedInput
    images?: ItemImageUncheckedUpdateManyWithoutItemNestedInput
    videos?: ItemVideoUncheckedUpdateManyWithoutItemNestedInput
    updateHistories?: ItemUpdateHistoryUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: bigint | number
    itemTypeId: number
    itemCategoryId: number
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    tags?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    status?: $Enums.ItemStatus
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumItemStatusFieldUpdateOperationsInput | $Enums.ItemStatus
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    itemCategoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumItemStatusFieldUpdateOperationsInput | $Enums.ItemStatus
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemAttributeTemplateCreateInput = {
    name: string
    type?: $Enums.AttributeType
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    category: ItemCategoryCreateNestedOneWithoutAttributeTemplatesInput
  }

  export type ItemAttributeTemplateUncheckedCreateInput = {
    id?: number
    itemCategoryId: number
    name: string
    type?: $Enums.AttributeType
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemAttributeTemplateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAttributeTypeFieldUpdateOperationsInput | $Enums.AttributeType
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: ItemCategoryUpdateOneRequiredWithoutAttributeTemplatesNestedInput
  }

  export type ItemAttributeTemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemCategoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAttributeTypeFieldUpdateOperationsInput | $Enums.AttributeType
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemAttributeTemplateCreateManyInput = {
    id?: number
    itemCategoryId: number
    name: string
    type?: $Enums.AttributeType
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemAttributeTemplateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAttributeTypeFieldUpdateOperationsInput | $Enums.AttributeType
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemAttributeTemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemCategoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAttributeTypeFieldUpdateOperationsInput | $Enums.AttributeType
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemCategoryCreateInput = {
    name: string
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    parent?: ItemCategoryCreateNestedOneWithoutChildrenInput
    children?: ItemCategoryCreateNestedManyWithoutParentInput
    items?: ItemCreateNestedManyWithoutCategoryInput
    attributeTemplates?: ItemAttributeTemplateCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryUncheckedCreateInput = {
    id?: number
    parentId?: number | null
    name: string
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: ItemCategoryUncheckedCreateNestedManyWithoutParentInput
    items?: ItemUncheckedCreateNestedManyWithoutCategoryInput
    attributeTemplates?: ItemAttributeTemplateUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: ItemCategoryUpdateOneWithoutChildrenNestedInput
    children?: ItemCategoryUpdateManyWithoutParentNestedInput
    items?: ItemUpdateManyWithoutCategoryNestedInput
    attributeTemplates?: ItemAttributeTemplateUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ItemCategoryUncheckedUpdateManyWithoutParentNestedInput
    items?: ItemUncheckedUpdateManyWithoutCategoryNestedInput
    attributeTemplates?: ItemAttributeTemplateUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryCreateManyInput = {
    id?: number
    parentId?: number | null
    name: string
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemImageCreateInput = {
    id?: bigint | number
    url: string
    isPrimary?: boolean
    sortOrder?: number
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    item: ItemCreateNestedOneWithoutImagesInput
  }

  export type ItemImageUncheckedCreateInput = {
    id?: bigint | number
    itemId: bigint | number
    url: string
    isPrimary?: boolean
    sortOrder?: number
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemImageUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item?: ItemUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ItemImageUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemImageCreateManyInput = {
    id?: bigint | number
    itemId: bigint | number
    url: string
    isPrimary?: boolean
    sortOrder?: number
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemImageUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemImageUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemPriceCreateInput = {
    id?: bigint | number
    price: Decimal | DecimalJsLike | number | string
    priceType?: $Enums.PriceType
    startDate?: Date | string | null
    endDate?: Date | string | null
    dayOfWeek?: number | null
    startTime?: string | null
    endTime?: string | null
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    variant: ItemVariantCreateNestedOneWithoutPricesInput
  }

  export type ItemPriceUncheckedCreateInput = {
    id?: bigint | number
    itemVariantId: bigint | number
    price: Decimal | DecimalJsLike | number | string
    priceType?: $Enums.PriceType
    startDate?: Date | string | null
    endDate?: Date | string | null
    dayOfWeek?: number | null
    startTime?: string | null
    endTime?: string | null
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemPriceUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceType?: EnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variant?: ItemVariantUpdateOneRequiredWithoutPricesNestedInput
  }

  export type ItemPriceUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemVariantId?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceType?: EnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemPriceCreateManyInput = {
    id?: bigint | number
    itemVariantId: bigint | number
    price: Decimal | DecimalJsLike | number | string
    priceType?: $Enums.PriceType
    startDate?: Date | string | null
    endDate?: Date | string | null
    dayOfWeek?: number | null
    startTime?: string | null
    endTime?: string | null
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemPriceUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceType?: EnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemPriceUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemVariantId?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceType?: EnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemTypeCreateInput = {
    name: string
    description?: string | null
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: ItemCreateNestedManyWithoutItemTypeInput
  }

  export type ItemTypeUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: ItemUncheckedCreateNestedManyWithoutItemTypeInput
  }

  export type ItemTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: ItemUpdateManyWithoutItemTypeNestedInput
  }

  export type ItemTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: ItemUncheckedUpdateManyWithoutItemTypeNestedInput
  }

  export type ItemTypeCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemUpdateHistoryCreateInput = {
    id?: bigint | number
    itemName: string
    userId: number
    userName: string
    columnName: string
    createdAt?: Date | string
    item: ItemCreateNestedOneWithoutUpdateHistoriesInput
  }

  export type ItemUpdateHistoryUncheckedCreateInput = {
    id?: bigint | number
    itemId: bigint | number
    itemName: string
    userId: number
    userName: string
    columnName: string
    createdAt?: Date | string
  }

  export type ItemUpdateHistoryUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemName?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutUpdateHistoriesNestedInput
  }

  export type ItemUpdateHistoryUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemName?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUpdateHistoryCreateManyInput = {
    id?: bigint | number
    itemId: bigint | number
    itemName: string
    userId: number
    userName: string
    columnName: string
    createdAt?: Date | string
  }

  export type ItemUpdateHistoryUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemName?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUpdateHistoryUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemName?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemVariantCreateInput = {
    id?: bigint | number
    code: string
    name?: string | null
    imageUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    quantity?: number
    options?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    item: ItemCreateNestedOneWithoutVariantsInput
    prices?: ItemPriceCreateNestedManyWithoutVariantInput
  }

  export type ItemVariantUncheckedCreateInput = {
    id?: bigint | number
    itemId: bigint | number
    code: string
    name?: string | null
    imageUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    quantity?: number
    options?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    prices?: ItemPriceUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ItemVariantUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item?: ItemUpdateOneRequiredWithoutVariantsNestedInput
    prices?: ItemPriceUpdateManyWithoutVariantNestedInput
  }

  export type ItemVariantUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prices?: ItemPriceUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type ItemVariantCreateManyInput = {
    id?: bigint | number
    itemId: bigint | number
    code: string
    name?: string | null
    imageUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    quantity?: number
    options?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemVariantUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemVariantUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemVideoCreateInput = {
    id?: bigint | number
    url: string
    provider?: string | null
    isPrimary?: boolean
    sortOrder?: number
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    item: ItemCreateNestedOneWithoutVideosInput
  }

  export type ItemVideoUncheckedCreateInput = {
    id?: bigint | number
    itemId: bigint | number
    url: string
    provider?: string | null
    isPrimary?: boolean
    sortOrder?: number
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemVideoUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item?: ItemUpdateOneRequiredWithoutVideosNestedInput
  }

  export type ItemVideoUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemVideoCreateManyInput = {
    id?: bigint | number
    itemId: bigint | number
    url: string
    provider?: string | null
    isPrimary?: boolean
    sortOrder?: number
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemVideoUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemVideoUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateInput = {
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    adminProfile?: UserAdminCreateNestedOneWithoutUserInput
    customerProfile?: UserCustomerCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    adminProfile?: UserAdminUncheckedCreateNestedOneWithoutUserInput
    customerProfile?: UserCustomerUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminProfile?: UserAdminUpdateOneWithoutUserNestedInput
    customerProfile?: UserCustomerUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminProfile?: UserAdminUncheckedUpdateOneWithoutUserNestedInput
    customerProfile?: UserCustomerUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAdminCreateInput = {
    fullName: string
    employeeId?: string | null
    department?: string | null
    phoneNumber?: string | null
    accessLevel?: number
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    user: UserCreateNestedOneWithoutAdminProfileInput
  }

  export type UserAdminUncheckedCreateInput = {
    id?: number
    userId: number
    fullName: string
    employeeId?: string | null
    department?: string | null
    phoneNumber?: string | null
    accessLevel?: number
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
  }

  export type UserAdminUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: IntFieldUpdateOperationsInput | number
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAdminProfileNestedInput
  }

  export type UserAdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: IntFieldUpdateOperationsInput | number
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAdminCreateManyInput = {
    id?: number
    userId: number
    fullName: string
    employeeId?: string | null
    department?: string | null
    phoneNumber?: string | null
    accessLevel?: number
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
  }

  export type UserAdminUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: IntFieldUpdateOperationsInput | number
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: IntFieldUpdateOperationsInput | number
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCustomerCreateInput = {
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    loyaltyPoint?: number
    referralCode?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    user: UserCreateNestedOneWithoutCustomerProfileInput
    addresses?: UserCustomerAddressCreateNestedManyWithoutCustomerInput
    member?: UserMemberCreateNestedOneWithoutCustomerInput
    responses?: CustomerResponseCreateNestedManyWithoutCustomerInput
  }

  export type UserCustomerUncheckedCreateInput = {
    id?: number
    userId: number
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    loyaltyPoint?: number
    referralCode?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    addresses?: UserCustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    member?: UserMemberUncheckedCreateNestedOneWithoutCustomerInput
    responses?: CustomerResponseUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type UserCustomerUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoint?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCustomerProfileNestedInput
    addresses?: UserCustomerAddressUpdateManyWithoutCustomerNestedInput
    member?: UserMemberUpdateOneWithoutCustomerNestedInput
    responses?: CustomerResponseUpdateManyWithoutCustomerNestedInput
  }

  export type UserCustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoint?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addresses?: UserCustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    member?: UserMemberUncheckedUpdateOneWithoutCustomerNestedInput
    responses?: CustomerResponseUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserCustomerCreateManyInput = {
    id?: number
    userId: number
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    loyaltyPoint?: number
    referralCode?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
  }

  export type UserCustomerUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoint?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoint?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCustomerAddressCreateInput = {
    label: string
    recipientName: string
    recipientPhone: string
    fullAddress: string
    note?: string | null
    isPrimary?: boolean
    customer: UserCustomerCreateNestedOneWithoutAddressesInput
  }

  export type UserCustomerAddressUncheckedCreateInput = {
    id?: number
    userCustomerId: number
    label: string
    recipientName: string
    recipientPhone: string
    fullAddress: string
    note?: string | null
    isPrimary?: boolean
  }

  export type UserCustomerAddressUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientPhone?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    customer?: UserCustomerUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type UserCustomerAddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCustomerId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientPhone?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCustomerAddressCreateManyInput = {
    id?: number
    userCustomerId: number
    label: string
    recipientName: string
    recipientPhone: string
    fullAddress: string
    note?: string | null
    isPrimary?: boolean
  }

  export type UserCustomerAddressUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientPhone?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCustomerAddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCustomerId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientPhone?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserMemberCreateInput = {
    tier?: $Enums.MemberTier
    memberNumber: string
    joinedAt?: Date | string
    expiredAt?: Date | string | null
    customer: UserCustomerCreateNestedOneWithoutMemberInput
  }

  export type UserMemberUncheckedCreateInput = {
    id?: number
    userCustomerId: number
    tier?: $Enums.MemberTier
    memberNumber: string
    joinedAt?: Date | string
    expiredAt?: Date | string | null
  }

  export type UserMemberUpdateInput = {
    tier?: EnumMemberTierFieldUpdateOperationsInput | $Enums.MemberTier
    memberNumber?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: UserCustomerUpdateOneRequiredWithoutMemberNestedInput
  }

  export type UserMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCustomerId?: IntFieldUpdateOperationsInput | number
    tier?: EnumMemberTierFieldUpdateOperationsInput | $Enums.MemberTier
    memberNumber?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserMemberCreateManyInput = {
    id?: number
    userCustomerId: number
    tier?: $Enums.MemberTier
    memberNumber: string
    joinedAt?: Date | string
    expiredAt?: Date | string | null
  }

  export type UserMemberUpdateManyMutationInput = {
    tier?: EnumMemberTierFieldUpdateOperationsInput | $Enums.MemberTier
    memberNumber?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCustomerId?: IntFieldUpdateOperationsInput | number
    tier?: EnumMemberTierFieldUpdateOperationsInput | $Enums.MemberTier
    memberNumber?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumFieldTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[]
    notIn?: $Enums.FieldType[]
    not?: NestedEnumFieldTypeFilter<$PrismaModel> | $Enums.FieldType
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CustomerResponseListRelationFilter = {
    every?: CustomerResponseWhereInput
    some?: CustomerResponseWhereInput
    none?: CustomerResponseWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CustomerResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerFormFieldOrderByRelevanceInput = {
    fields: CustomerFormFieldOrderByRelevanceFieldEnum | CustomerFormFieldOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomerFormFieldCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    fieldKey?: SortOrder
    type?: SortOrder
    options?: SortOrder
    isRequired?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerFormFieldAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerFormFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    fieldKey?: SortOrder
    type?: SortOrder
    isRequired?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerFormFieldMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    fieldKey?: SortOrder
    type?: SortOrder
    isRequired?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerFormFieldSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumFieldTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[]
    notIn?: $Enums.FieldType[]
    not?: NestedEnumFieldTypeWithAggregatesFilter<$PrismaModel> | $Enums.FieldType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFieldTypeFilter<$PrismaModel>
    _max?: NestedEnumFieldTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserCustomerScalarRelationFilter = {
    is?: UserCustomerWhereInput
    isNot?: UserCustomerWhereInput
  }

  export type CustomerFormFieldScalarRelationFilter = {
    is?: CustomerFormFieldWhereInput
    isNot?: CustomerFormFieldWhereInput
  }

  export type CustomerResponseOrderByRelevanceInput = {
    fields: CustomerResponseOrderByRelevanceFieldEnum | CustomerResponseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomerResponseCountOrderByAggregateInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
    fieldId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerResponseAvgOrderByAggregateInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
    fieldId?: SortOrder
  }

  export type CustomerResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
    fieldId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerResponseMinOrderByAggregateInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
    fieldId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerResponseSumOrderByAggregateInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
    fieldId?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemStatus | EnumItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ItemStatus[]
    notIn?: $Enums.ItemStatus[]
    not?: NestedEnumItemStatusFilter<$PrismaModel> | $Enums.ItemStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ItemTypeScalarRelationFilter = {
    is?: ItemTypeWhereInput
    isNot?: ItemTypeWhereInput
  }

  export type ItemCategoryScalarRelationFilter = {
    is?: ItemCategoryWhereInput
    isNot?: ItemCategoryWhereInput
  }

  export type ItemVariantListRelationFilter = {
    every?: ItemVariantWhereInput
    some?: ItemVariantWhereInput
    none?: ItemVariantWhereInput
  }

  export type ItemImageListRelationFilter = {
    every?: ItemImageWhereInput
    some?: ItemImageWhereInput
    none?: ItemImageWhereInput
  }

  export type ItemVideoListRelationFilter = {
    every?: ItemVideoWhereInput
    some?: ItemVideoWhereInput
    none?: ItemVideoWhereInput
  }

  export type ItemUpdateHistoryListRelationFilter = {
    every?: ItemUpdateHistoryWhereInput
    some?: ItemUpdateHistoryWhereInput
    none?: ItemUpdateHistoryWhereInput
  }

  export type ItemVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemVideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemUpdateHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemOrderByRelevanceInput = {
    fields: ItemOrderByRelevanceFieldEnum | ItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    itemCategoryId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    tags?: SortOrder
    attributes?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    status?: SortOrder
    isPinned?: SortOrder
    isFavorite?: SortOrder
    isDeleted?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    itemCategoryId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    itemCategoryId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    tags?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    status?: SortOrder
    isPinned?: SortOrder
    isFavorite?: SortOrder
    isDeleted?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    itemCategoryId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    tags?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    status?: SortOrder
    isPinned?: SortOrder
    isFavorite?: SortOrder
    isDeleted?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    itemCategoryId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemStatus | EnumItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ItemStatus[]
    notIn?: $Enums.ItemStatus[]
    not?: NestedEnumItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.ItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemStatusFilter<$PrismaModel>
    _max?: NestedEnumItemStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumAttributeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AttributeType | EnumAttributeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttributeType[]
    notIn?: $Enums.AttributeType[]
    not?: NestedEnumAttributeTypeFilter<$PrismaModel> | $Enums.AttributeType
  }

  export type ItemAttributeTemplateOrderByRelevanceInput = {
    fields: ItemAttributeTemplateOrderByRelevanceFieldEnum | ItemAttributeTemplateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ItemAttributeTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    itemCategoryId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemAttributeTemplateAvgOrderByAggregateInput = {
    id?: SortOrder
    itemCategoryId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type ItemAttributeTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    itemCategoryId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemAttributeTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    itemCategoryId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemAttributeTemplateSumOrderByAggregateInput = {
    id?: SortOrder
    itemCategoryId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type EnumAttributeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttributeType | EnumAttributeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttributeType[]
    notIn?: $Enums.AttributeType[]
    not?: NestedEnumAttributeTypeWithAggregatesFilter<$PrismaModel> | $Enums.AttributeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttributeTypeFilter<$PrismaModel>
    _max?: NestedEnumAttributeTypeFilter<$PrismaModel>
  }

  export type ItemCategoryNullableScalarRelationFilter = {
    is?: ItemCategoryWhereInput | null
    isNot?: ItemCategoryWhereInput | null
  }

  export type ItemCategoryListRelationFilter = {
    every?: ItemCategoryWhereInput
    some?: ItemCategoryWhereInput
    none?: ItemCategoryWhereInput
  }

  export type ItemListRelationFilter = {
    every?: ItemWhereInput
    some?: ItemWhereInput
    none?: ItemWhereInput
  }

  export type ItemAttributeTemplateListRelationFilter = {
    every?: ItemAttributeTemplateWhereInput
    some?: ItemAttributeTemplateWhereInput
    none?: ItemAttributeTemplateWhereInput
  }

  export type ItemCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemAttributeTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCategoryOrderByRelevanceInput = {
    fields: ItemCategoryOrderByRelevanceFieldEnum | ItemCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ItemCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type ItemCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemCategorySumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type ItemScalarRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type ItemImageOrderByRelevanceInput = {
    fields: ItemImageOrderByRelevanceFieldEnum | ItemImageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ItemImageCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    url?: SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemImageAvgOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type ItemImageMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    url?: SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemImageMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    url?: SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemImageSumOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumPriceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceType | EnumPriceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PriceType[]
    notIn?: $Enums.PriceType[]
    not?: NestedEnumPriceTypeFilter<$PrismaModel> | $Enums.PriceType
  }

  export type ItemVariantScalarRelationFilter = {
    is?: ItemVariantWhereInput
    isNot?: ItemVariantWhereInput
  }

  export type ItemPriceOrderByRelevanceInput = {
    fields: ItemPriceOrderByRelevanceFieldEnum | ItemPriceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ItemPriceCountOrderByAggregateInput = {
    id?: SortOrder
    itemVariantId?: SortOrder
    price?: SortOrder
    priceType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemPriceAvgOrderByAggregateInput = {
    id?: SortOrder
    itemVariantId?: SortOrder
    price?: SortOrder
    dayOfWeek?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type ItemPriceMaxOrderByAggregateInput = {
    id?: SortOrder
    itemVariantId?: SortOrder
    price?: SortOrder
    priceType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemPriceMinOrderByAggregateInput = {
    id?: SortOrder
    itemVariantId?: SortOrder
    price?: SortOrder
    priceType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemPriceSumOrderByAggregateInput = {
    id?: SortOrder
    itemVariantId?: SortOrder
    price?: SortOrder
    dayOfWeek?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumPriceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceType | EnumPriceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PriceType[]
    notIn?: $Enums.PriceType[]
    not?: NestedEnumPriceTypeWithAggregatesFilter<$PrismaModel> | $Enums.PriceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriceTypeFilter<$PrismaModel>
    _max?: NestedEnumPriceTypeFilter<$PrismaModel>
  }

  export type ItemTypeOrderByRelevanceInput = {
    fields: ItemTypeOrderByRelevanceFieldEnum | ItemTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ItemTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type ItemTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemTypeSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type ItemUpdateHistoryOrderByRelevanceInput = {
    fields: ItemUpdateHistoryOrderByRelevanceFieldEnum | ItemUpdateHistoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ItemUpdateHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    itemName?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    columnName?: SortOrder
    createdAt?: SortOrder
  }

  export type ItemUpdateHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    userId?: SortOrder
  }

  export type ItemUpdateHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    itemName?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    columnName?: SortOrder
    createdAt?: SortOrder
  }

  export type ItemUpdateHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    itemName?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    columnName?: SortOrder
    createdAt?: SortOrder
  }

  export type ItemUpdateHistorySumOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    userId?: SortOrder
  }

  export type ItemPriceListRelationFilter = {
    every?: ItemPriceWhereInput
    some?: ItemPriceWhereInput
    none?: ItemPriceWhereInput
  }

  export type ItemPriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemVariantOrderByRelevanceInput = {
    fields: ItemVariantOrderByRelevanceFieldEnum | ItemVariantOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ItemVariantCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    options?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemVariantAvgOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type ItemVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemVariantMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemVariantSumOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type ItemVideoOrderByRelevanceInput = {
    fields: ItemVideoOrderByRelevanceFieldEnum | ItemVideoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ItemVideoCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    url?: SortOrder
    provider?: SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemVideoAvgOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type ItemVideoMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    url?: SortOrder
    provider?: SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemVideoMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    url?: SortOrder
    provider?: SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ItemVideoSumOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type UserAdminNullableScalarRelationFilter = {
    is?: UserAdminWhereInput | null
    isNot?: UserAdminWhereInput | null
  }

  export type UserCustomerNullableScalarRelationFilter = {
    is?: UserCustomerWhereInput | null
    isNot?: UserCustomerWhereInput | null
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserAdminOrderByRelevanceInput = {
    fields: UserAdminOrderByRelevanceFieldEnum | UserAdminOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserAdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    phoneNumber?: SortOrder
    accessLevel?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
  }

  export type UserAdminAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accessLevel?: SortOrder
  }

  export type UserAdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    phoneNumber?: SortOrder
    accessLevel?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
  }

  export type UserAdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    phoneNumber?: SortOrder
    accessLevel?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
  }

  export type UserAdminSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accessLevel?: SortOrder
  }

  export type UserCustomerAddressListRelationFilter = {
    every?: UserCustomerAddressWhereInput
    some?: UserCustomerAddressWhereInput
    none?: UserCustomerAddressWhereInput
  }

  export type UserMemberNullableScalarRelationFilter = {
    is?: UserMemberWhereInput | null
    isNot?: UserMemberWhereInput | null
  }

  export type UserCustomerAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCustomerOrderByRelevanceInput = {
    fields: UserCustomerOrderByRelevanceFieldEnum | UserCustomerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCustomerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrder
    birthDate?: SortOrder
    loyaltyPoint?: SortOrder
    referralCode?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
  }

  export type UserCustomerAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loyaltyPoint?: SortOrder
  }

  export type UserCustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrder
    birthDate?: SortOrder
    loyaltyPoint?: SortOrder
    referralCode?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
  }

  export type UserCustomerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrder
    birthDate?: SortOrder
    loyaltyPoint?: SortOrder
    referralCode?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
  }

  export type UserCustomerSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loyaltyPoint?: SortOrder
  }

  export type UserCustomerAddressOrderByRelevanceInput = {
    fields: UserCustomerAddressOrderByRelevanceFieldEnum | UserCustomerAddressOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCustomerAddressCountOrderByAggregateInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
    label?: SortOrder
    recipientName?: SortOrder
    recipientPhone?: SortOrder
    fullAddress?: SortOrder
    note?: SortOrder
    isPrimary?: SortOrder
  }

  export type UserCustomerAddressAvgOrderByAggregateInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
  }

  export type UserCustomerAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
    label?: SortOrder
    recipientName?: SortOrder
    recipientPhone?: SortOrder
    fullAddress?: SortOrder
    note?: SortOrder
    isPrimary?: SortOrder
  }

  export type UserCustomerAddressMinOrderByAggregateInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
    label?: SortOrder
    recipientName?: SortOrder
    recipientPhone?: SortOrder
    fullAddress?: SortOrder
    note?: SortOrder
    isPrimary?: SortOrder
  }

  export type UserCustomerAddressSumOrderByAggregateInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
  }

  export type EnumMemberTierFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberTier | EnumMemberTierFieldRefInput<$PrismaModel>
    in?: $Enums.MemberTier[]
    notIn?: $Enums.MemberTier[]
    not?: NestedEnumMemberTierFilter<$PrismaModel> | $Enums.MemberTier
  }

  export type UserMemberOrderByRelevanceInput = {
    fields: UserMemberOrderByRelevanceFieldEnum | UserMemberOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserMemberCountOrderByAggregateInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
    tier?: SortOrder
    memberNumber?: SortOrder
    joinedAt?: SortOrder
    expiredAt?: SortOrder
  }

  export type UserMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
  }

  export type UserMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
    tier?: SortOrder
    memberNumber?: SortOrder
    joinedAt?: SortOrder
    expiredAt?: SortOrder
  }

  export type UserMemberMinOrderByAggregateInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
    tier?: SortOrder
    memberNumber?: SortOrder
    joinedAt?: SortOrder
    expiredAt?: SortOrder
  }

  export type UserMemberSumOrderByAggregateInput = {
    id?: SortOrder
    userCustomerId?: SortOrder
  }

  export type EnumMemberTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberTier | EnumMemberTierFieldRefInput<$PrismaModel>
    in?: $Enums.MemberTier[]
    notIn?: $Enums.MemberTier[]
    not?: NestedEnumMemberTierWithAggregatesFilter<$PrismaModel> | $Enums.MemberTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberTierFilter<$PrismaModel>
    _max?: NestedEnumMemberTierFilter<$PrismaModel>
  }

  export type CustomerResponseCreateNestedManyWithoutFieldInput = {
    create?: XOR<CustomerResponseCreateWithoutFieldInput, CustomerResponseUncheckedCreateWithoutFieldInput> | CustomerResponseCreateWithoutFieldInput[] | CustomerResponseUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: CustomerResponseCreateOrConnectWithoutFieldInput | CustomerResponseCreateOrConnectWithoutFieldInput[]
    createMany?: CustomerResponseCreateManyFieldInputEnvelope
    connect?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
  }

  export type CustomerResponseUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<CustomerResponseCreateWithoutFieldInput, CustomerResponseUncheckedCreateWithoutFieldInput> | CustomerResponseCreateWithoutFieldInput[] | CustomerResponseUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: CustomerResponseCreateOrConnectWithoutFieldInput | CustomerResponseCreateOrConnectWithoutFieldInput[]
    createMany?: CustomerResponseCreateManyFieldInputEnvelope
    connect?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumFieldTypeFieldUpdateOperationsInput = {
    set?: $Enums.FieldType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CustomerResponseUpdateManyWithoutFieldNestedInput = {
    create?: XOR<CustomerResponseCreateWithoutFieldInput, CustomerResponseUncheckedCreateWithoutFieldInput> | CustomerResponseCreateWithoutFieldInput[] | CustomerResponseUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: CustomerResponseCreateOrConnectWithoutFieldInput | CustomerResponseCreateOrConnectWithoutFieldInput[]
    upsert?: CustomerResponseUpsertWithWhereUniqueWithoutFieldInput | CustomerResponseUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: CustomerResponseCreateManyFieldInputEnvelope
    set?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
    disconnect?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
    delete?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
    connect?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
    update?: CustomerResponseUpdateWithWhereUniqueWithoutFieldInput | CustomerResponseUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: CustomerResponseUpdateManyWithWhereWithoutFieldInput | CustomerResponseUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: CustomerResponseScalarWhereInput | CustomerResponseScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerResponseUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<CustomerResponseCreateWithoutFieldInput, CustomerResponseUncheckedCreateWithoutFieldInput> | CustomerResponseCreateWithoutFieldInput[] | CustomerResponseUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: CustomerResponseCreateOrConnectWithoutFieldInput | CustomerResponseCreateOrConnectWithoutFieldInput[]
    upsert?: CustomerResponseUpsertWithWhereUniqueWithoutFieldInput | CustomerResponseUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: CustomerResponseCreateManyFieldInputEnvelope
    set?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
    disconnect?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
    delete?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
    connect?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
    update?: CustomerResponseUpdateWithWhereUniqueWithoutFieldInput | CustomerResponseUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: CustomerResponseUpdateManyWithWhereWithoutFieldInput | CustomerResponseUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: CustomerResponseScalarWhereInput | CustomerResponseScalarWhereInput[]
  }

  export type UserCustomerCreateNestedOneWithoutResponsesInput = {
    create?: XOR<UserCustomerCreateWithoutResponsesInput, UserCustomerUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: UserCustomerCreateOrConnectWithoutResponsesInput
    connect?: UserCustomerWhereUniqueInput
  }

  export type CustomerFormFieldCreateNestedOneWithoutResponsesInput = {
    create?: XOR<CustomerFormFieldCreateWithoutResponsesInput, CustomerFormFieldUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: CustomerFormFieldCreateOrConnectWithoutResponsesInput
    connect?: CustomerFormFieldWhereUniqueInput
  }

  export type UserCustomerUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<UserCustomerCreateWithoutResponsesInput, UserCustomerUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: UserCustomerCreateOrConnectWithoutResponsesInput
    upsert?: UserCustomerUpsertWithoutResponsesInput
    connect?: UserCustomerWhereUniqueInput
    update?: XOR<XOR<UserCustomerUpdateToOneWithWhereWithoutResponsesInput, UserCustomerUpdateWithoutResponsesInput>, UserCustomerUncheckedUpdateWithoutResponsesInput>
  }

  export type CustomerFormFieldUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<CustomerFormFieldCreateWithoutResponsesInput, CustomerFormFieldUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: CustomerFormFieldCreateOrConnectWithoutResponsesInput
    upsert?: CustomerFormFieldUpsertWithoutResponsesInput
    connect?: CustomerFormFieldWhereUniqueInput
    update?: XOR<XOR<CustomerFormFieldUpdateToOneWithWhereWithoutResponsesInput, CustomerFormFieldUpdateWithoutResponsesInput>, CustomerFormFieldUncheckedUpdateWithoutResponsesInput>
  }

  export type ItemTypeCreateNestedOneWithoutItemsInput = {
    create?: XOR<ItemTypeCreateWithoutItemsInput, ItemTypeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemTypeCreateOrConnectWithoutItemsInput
    connect?: ItemTypeWhereUniqueInput
  }

  export type ItemCategoryCreateNestedOneWithoutItemsInput = {
    create?: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutItemsInput
    connect?: ItemCategoryWhereUniqueInput
  }

  export type ItemVariantCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemVariantCreateWithoutItemInput, ItemVariantUncheckedCreateWithoutItemInput> | ItemVariantCreateWithoutItemInput[] | ItemVariantUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemVariantCreateOrConnectWithoutItemInput | ItemVariantCreateOrConnectWithoutItemInput[]
    createMany?: ItemVariantCreateManyItemInputEnvelope
    connect?: ItemVariantWhereUniqueInput | ItemVariantWhereUniqueInput[]
  }

  export type ItemImageCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemImageCreateWithoutItemInput, ItemImageUncheckedCreateWithoutItemInput> | ItemImageCreateWithoutItemInput[] | ItemImageUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemImageCreateOrConnectWithoutItemInput | ItemImageCreateOrConnectWithoutItemInput[]
    createMany?: ItemImageCreateManyItemInputEnvelope
    connect?: ItemImageWhereUniqueInput | ItemImageWhereUniqueInput[]
  }

  export type ItemVideoCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemVideoCreateWithoutItemInput, ItemVideoUncheckedCreateWithoutItemInput> | ItemVideoCreateWithoutItemInput[] | ItemVideoUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemVideoCreateOrConnectWithoutItemInput | ItemVideoCreateOrConnectWithoutItemInput[]
    createMany?: ItemVideoCreateManyItemInputEnvelope
    connect?: ItemVideoWhereUniqueInput | ItemVideoWhereUniqueInput[]
  }

  export type ItemUpdateHistoryCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemUpdateHistoryCreateWithoutItemInput, ItemUpdateHistoryUncheckedCreateWithoutItemInput> | ItemUpdateHistoryCreateWithoutItemInput[] | ItemUpdateHistoryUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemUpdateHistoryCreateOrConnectWithoutItemInput | ItemUpdateHistoryCreateOrConnectWithoutItemInput[]
    createMany?: ItemUpdateHistoryCreateManyItemInputEnvelope
    connect?: ItemUpdateHistoryWhereUniqueInput | ItemUpdateHistoryWhereUniqueInput[]
  }

  export type ItemVariantUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemVariantCreateWithoutItemInput, ItemVariantUncheckedCreateWithoutItemInput> | ItemVariantCreateWithoutItemInput[] | ItemVariantUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemVariantCreateOrConnectWithoutItemInput | ItemVariantCreateOrConnectWithoutItemInput[]
    createMany?: ItemVariantCreateManyItemInputEnvelope
    connect?: ItemVariantWhereUniqueInput | ItemVariantWhereUniqueInput[]
  }

  export type ItemImageUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemImageCreateWithoutItemInput, ItemImageUncheckedCreateWithoutItemInput> | ItemImageCreateWithoutItemInput[] | ItemImageUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemImageCreateOrConnectWithoutItemInput | ItemImageCreateOrConnectWithoutItemInput[]
    createMany?: ItemImageCreateManyItemInputEnvelope
    connect?: ItemImageWhereUniqueInput | ItemImageWhereUniqueInput[]
  }

  export type ItemVideoUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemVideoCreateWithoutItemInput, ItemVideoUncheckedCreateWithoutItemInput> | ItemVideoCreateWithoutItemInput[] | ItemVideoUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemVideoCreateOrConnectWithoutItemInput | ItemVideoCreateOrConnectWithoutItemInput[]
    createMany?: ItemVideoCreateManyItemInputEnvelope
    connect?: ItemVideoWhereUniqueInput | ItemVideoWhereUniqueInput[]
  }

  export type ItemUpdateHistoryUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemUpdateHistoryCreateWithoutItemInput, ItemUpdateHistoryUncheckedCreateWithoutItemInput> | ItemUpdateHistoryCreateWithoutItemInput[] | ItemUpdateHistoryUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemUpdateHistoryCreateOrConnectWithoutItemInput | ItemUpdateHistoryCreateOrConnectWithoutItemInput[]
    createMany?: ItemUpdateHistoryCreateManyItemInputEnvelope
    connect?: ItemUpdateHistoryWhereUniqueInput | ItemUpdateHistoryWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumItemStatusFieldUpdateOperationsInput = {
    set?: $Enums.ItemStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ItemTypeUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ItemTypeCreateWithoutItemsInput, ItemTypeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemTypeCreateOrConnectWithoutItemsInput
    upsert?: ItemTypeUpsertWithoutItemsInput
    connect?: ItemTypeWhereUniqueInput
    update?: XOR<XOR<ItemTypeUpdateToOneWithWhereWithoutItemsInput, ItemTypeUpdateWithoutItemsInput>, ItemTypeUncheckedUpdateWithoutItemsInput>
  }

  export type ItemCategoryUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutItemsInput
    upsert?: ItemCategoryUpsertWithoutItemsInput
    connect?: ItemCategoryWhereUniqueInput
    update?: XOR<XOR<ItemCategoryUpdateToOneWithWhereWithoutItemsInput, ItemCategoryUpdateWithoutItemsInput>, ItemCategoryUncheckedUpdateWithoutItemsInput>
  }

  export type ItemVariantUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemVariantCreateWithoutItemInput, ItemVariantUncheckedCreateWithoutItemInput> | ItemVariantCreateWithoutItemInput[] | ItemVariantUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemVariantCreateOrConnectWithoutItemInput | ItemVariantCreateOrConnectWithoutItemInput[]
    upsert?: ItemVariantUpsertWithWhereUniqueWithoutItemInput | ItemVariantUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemVariantCreateManyItemInputEnvelope
    set?: ItemVariantWhereUniqueInput | ItemVariantWhereUniqueInput[]
    disconnect?: ItemVariantWhereUniqueInput | ItemVariantWhereUniqueInput[]
    delete?: ItemVariantWhereUniqueInput | ItemVariantWhereUniqueInput[]
    connect?: ItemVariantWhereUniqueInput | ItemVariantWhereUniqueInput[]
    update?: ItemVariantUpdateWithWhereUniqueWithoutItemInput | ItemVariantUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemVariantUpdateManyWithWhereWithoutItemInput | ItemVariantUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemVariantScalarWhereInput | ItemVariantScalarWhereInput[]
  }

  export type ItemImageUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemImageCreateWithoutItemInput, ItemImageUncheckedCreateWithoutItemInput> | ItemImageCreateWithoutItemInput[] | ItemImageUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemImageCreateOrConnectWithoutItemInput | ItemImageCreateOrConnectWithoutItemInput[]
    upsert?: ItemImageUpsertWithWhereUniqueWithoutItemInput | ItemImageUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemImageCreateManyItemInputEnvelope
    set?: ItemImageWhereUniqueInput | ItemImageWhereUniqueInput[]
    disconnect?: ItemImageWhereUniqueInput | ItemImageWhereUniqueInput[]
    delete?: ItemImageWhereUniqueInput | ItemImageWhereUniqueInput[]
    connect?: ItemImageWhereUniqueInput | ItemImageWhereUniqueInput[]
    update?: ItemImageUpdateWithWhereUniqueWithoutItemInput | ItemImageUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemImageUpdateManyWithWhereWithoutItemInput | ItemImageUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemImageScalarWhereInput | ItemImageScalarWhereInput[]
  }

  export type ItemVideoUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemVideoCreateWithoutItemInput, ItemVideoUncheckedCreateWithoutItemInput> | ItemVideoCreateWithoutItemInput[] | ItemVideoUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemVideoCreateOrConnectWithoutItemInput | ItemVideoCreateOrConnectWithoutItemInput[]
    upsert?: ItemVideoUpsertWithWhereUniqueWithoutItemInput | ItemVideoUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemVideoCreateManyItemInputEnvelope
    set?: ItemVideoWhereUniqueInput | ItemVideoWhereUniqueInput[]
    disconnect?: ItemVideoWhereUniqueInput | ItemVideoWhereUniqueInput[]
    delete?: ItemVideoWhereUniqueInput | ItemVideoWhereUniqueInput[]
    connect?: ItemVideoWhereUniqueInput | ItemVideoWhereUniqueInput[]
    update?: ItemVideoUpdateWithWhereUniqueWithoutItemInput | ItemVideoUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemVideoUpdateManyWithWhereWithoutItemInput | ItemVideoUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemVideoScalarWhereInput | ItemVideoScalarWhereInput[]
  }

  export type ItemUpdateHistoryUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemUpdateHistoryCreateWithoutItemInput, ItemUpdateHistoryUncheckedCreateWithoutItemInput> | ItemUpdateHistoryCreateWithoutItemInput[] | ItemUpdateHistoryUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemUpdateHistoryCreateOrConnectWithoutItemInput | ItemUpdateHistoryCreateOrConnectWithoutItemInput[]
    upsert?: ItemUpdateHistoryUpsertWithWhereUniqueWithoutItemInput | ItemUpdateHistoryUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemUpdateHistoryCreateManyItemInputEnvelope
    set?: ItemUpdateHistoryWhereUniqueInput | ItemUpdateHistoryWhereUniqueInput[]
    disconnect?: ItemUpdateHistoryWhereUniqueInput | ItemUpdateHistoryWhereUniqueInput[]
    delete?: ItemUpdateHistoryWhereUniqueInput | ItemUpdateHistoryWhereUniqueInput[]
    connect?: ItemUpdateHistoryWhereUniqueInput | ItemUpdateHistoryWhereUniqueInput[]
    update?: ItemUpdateHistoryUpdateWithWhereUniqueWithoutItemInput | ItemUpdateHistoryUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemUpdateHistoryUpdateManyWithWhereWithoutItemInput | ItemUpdateHistoryUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemUpdateHistoryScalarWhereInput | ItemUpdateHistoryScalarWhereInput[]
  }

  export type ItemVariantUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemVariantCreateWithoutItemInput, ItemVariantUncheckedCreateWithoutItemInput> | ItemVariantCreateWithoutItemInput[] | ItemVariantUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemVariantCreateOrConnectWithoutItemInput | ItemVariantCreateOrConnectWithoutItemInput[]
    upsert?: ItemVariantUpsertWithWhereUniqueWithoutItemInput | ItemVariantUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemVariantCreateManyItemInputEnvelope
    set?: ItemVariantWhereUniqueInput | ItemVariantWhereUniqueInput[]
    disconnect?: ItemVariantWhereUniqueInput | ItemVariantWhereUniqueInput[]
    delete?: ItemVariantWhereUniqueInput | ItemVariantWhereUniqueInput[]
    connect?: ItemVariantWhereUniqueInput | ItemVariantWhereUniqueInput[]
    update?: ItemVariantUpdateWithWhereUniqueWithoutItemInput | ItemVariantUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemVariantUpdateManyWithWhereWithoutItemInput | ItemVariantUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemVariantScalarWhereInput | ItemVariantScalarWhereInput[]
  }

  export type ItemImageUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemImageCreateWithoutItemInput, ItemImageUncheckedCreateWithoutItemInput> | ItemImageCreateWithoutItemInput[] | ItemImageUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemImageCreateOrConnectWithoutItemInput | ItemImageCreateOrConnectWithoutItemInput[]
    upsert?: ItemImageUpsertWithWhereUniqueWithoutItemInput | ItemImageUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemImageCreateManyItemInputEnvelope
    set?: ItemImageWhereUniqueInput | ItemImageWhereUniqueInput[]
    disconnect?: ItemImageWhereUniqueInput | ItemImageWhereUniqueInput[]
    delete?: ItemImageWhereUniqueInput | ItemImageWhereUniqueInput[]
    connect?: ItemImageWhereUniqueInput | ItemImageWhereUniqueInput[]
    update?: ItemImageUpdateWithWhereUniqueWithoutItemInput | ItemImageUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemImageUpdateManyWithWhereWithoutItemInput | ItemImageUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemImageScalarWhereInput | ItemImageScalarWhereInput[]
  }

  export type ItemVideoUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemVideoCreateWithoutItemInput, ItemVideoUncheckedCreateWithoutItemInput> | ItemVideoCreateWithoutItemInput[] | ItemVideoUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemVideoCreateOrConnectWithoutItemInput | ItemVideoCreateOrConnectWithoutItemInput[]
    upsert?: ItemVideoUpsertWithWhereUniqueWithoutItemInput | ItemVideoUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemVideoCreateManyItemInputEnvelope
    set?: ItemVideoWhereUniqueInput | ItemVideoWhereUniqueInput[]
    disconnect?: ItemVideoWhereUniqueInput | ItemVideoWhereUniqueInput[]
    delete?: ItemVideoWhereUniqueInput | ItemVideoWhereUniqueInput[]
    connect?: ItemVideoWhereUniqueInput | ItemVideoWhereUniqueInput[]
    update?: ItemVideoUpdateWithWhereUniqueWithoutItemInput | ItemVideoUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemVideoUpdateManyWithWhereWithoutItemInput | ItemVideoUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemVideoScalarWhereInput | ItemVideoScalarWhereInput[]
  }

  export type ItemUpdateHistoryUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemUpdateHistoryCreateWithoutItemInput, ItemUpdateHistoryUncheckedCreateWithoutItemInput> | ItemUpdateHistoryCreateWithoutItemInput[] | ItemUpdateHistoryUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemUpdateHistoryCreateOrConnectWithoutItemInput | ItemUpdateHistoryCreateOrConnectWithoutItemInput[]
    upsert?: ItemUpdateHistoryUpsertWithWhereUniqueWithoutItemInput | ItemUpdateHistoryUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemUpdateHistoryCreateManyItemInputEnvelope
    set?: ItemUpdateHistoryWhereUniqueInput | ItemUpdateHistoryWhereUniqueInput[]
    disconnect?: ItemUpdateHistoryWhereUniqueInput | ItemUpdateHistoryWhereUniqueInput[]
    delete?: ItemUpdateHistoryWhereUniqueInput | ItemUpdateHistoryWhereUniqueInput[]
    connect?: ItemUpdateHistoryWhereUniqueInput | ItemUpdateHistoryWhereUniqueInput[]
    update?: ItemUpdateHistoryUpdateWithWhereUniqueWithoutItemInput | ItemUpdateHistoryUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemUpdateHistoryUpdateManyWithWhereWithoutItemInput | ItemUpdateHistoryUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemUpdateHistoryScalarWhereInput | ItemUpdateHistoryScalarWhereInput[]
  }

  export type ItemCategoryCreateNestedOneWithoutAttributeTemplatesInput = {
    create?: XOR<ItemCategoryCreateWithoutAttributeTemplatesInput, ItemCategoryUncheckedCreateWithoutAttributeTemplatesInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutAttributeTemplatesInput
    connect?: ItemCategoryWhereUniqueInput
  }

  export type EnumAttributeTypeFieldUpdateOperationsInput = {
    set?: $Enums.AttributeType
  }

  export type ItemCategoryUpdateOneRequiredWithoutAttributeTemplatesNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutAttributeTemplatesInput, ItemCategoryUncheckedCreateWithoutAttributeTemplatesInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutAttributeTemplatesInput
    upsert?: ItemCategoryUpsertWithoutAttributeTemplatesInput
    connect?: ItemCategoryWhereUniqueInput
    update?: XOR<XOR<ItemCategoryUpdateToOneWithWhereWithoutAttributeTemplatesInput, ItemCategoryUpdateWithoutAttributeTemplatesInput>, ItemCategoryUncheckedUpdateWithoutAttributeTemplatesInput>
  }

  export type ItemCategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ItemCategoryCreateWithoutChildrenInput, ItemCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutChildrenInput
    connect?: ItemCategoryWhereUniqueInput
  }

  export type ItemCategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<ItemCategoryCreateWithoutParentInput, ItemCategoryUncheckedCreateWithoutParentInput> | ItemCategoryCreateWithoutParentInput[] | ItemCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutParentInput | ItemCategoryCreateOrConnectWithoutParentInput[]
    createMany?: ItemCategoryCreateManyParentInputEnvelope
    connect?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
  }

  export type ItemCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput> | ItemCreateWithoutCategoryInput[] | ItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCategoryInput | ItemCreateOrConnectWithoutCategoryInput[]
    createMany?: ItemCreateManyCategoryInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemAttributeTemplateCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ItemAttributeTemplateCreateWithoutCategoryInput, ItemAttributeTemplateUncheckedCreateWithoutCategoryInput> | ItemAttributeTemplateCreateWithoutCategoryInput[] | ItemAttributeTemplateUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemAttributeTemplateCreateOrConnectWithoutCategoryInput | ItemAttributeTemplateCreateOrConnectWithoutCategoryInput[]
    createMany?: ItemAttributeTemplateCreateManyCategoryInputEnvelope
    connect?: ItemAttributeTemplateWhereUniqueInput | ItemAttributeTemplateWhereUniqueInput[]
  }

  export type ItemCategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<ItemCategoryCreateWithoutParentInput, ItemCategoryUncheckedCreateWithoutParentInput> | ItemCategoryCreateWithoutParentInput[] | ItemCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutParentInput | ItemCategoryCreateOrConnectWithoutParentInput[]
    createMany?: ItemCategoryCreateManyParentInputEnvelope
    connect?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput> | ItemCreateWithoutCategoryInput[] | ItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCategoryInput | ItemCreateOrConnectWithoutCategoryInput[]
    createMany?: ItemCreateManyCategoryInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemAttributeTemplateUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ItemAttributeTemplateCreateWithoutCategoryInput, ItemAttributeTemplateUncheckedCreateWithoutCategoryInput> | ItemAttributeTemplateCreateWithoutCategoryInput[] | ItemAttributeTemplateUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemAttributeTemplateCreateOrConnectWithoutCategoryInput | ItemAttributeTemplateCreateOrConnectWithoutCategoryInput[]
    createMany?: ItemAttributeTemplateCreateManyCategoryInputEnvelope
    connect?: ItemAttributeTemplateWhereUniqueInput | ItemAttributeTemplateWhereUniqueInput[]
  }

  export type ItemCategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutChildrenInput, ItemCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutChildrenInput
    upsert?: ItemCategoryUpsertWithoutChildrenInput
    disconnect?: ItemCategoryWhereInput | boolean
    delete?: ItemCategoryWhereInput | boolean
    connect?: ItemCategoryWhereUniqueInput
    update?: XOR<XOR<ItemCategoryUpdateToOneWithWhereWithoutChildrenInput, ItemCategoryUpdateWithoutChildrenInput>, ItemCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type ItemCategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutParentInput, ItemCategoryUncheckedCreateWithoutParentInput> | ItemCategoryCreateWithoutParentInput[] | ItemCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutParentInput | ItemCategoryCreateOrConnectWithoutParentInput[]
    upsert?: ItemCategoryUpsertWithWhereUniqueWithoutParentInput | ItemCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ItemCategoryCreateManyParentInputEnvelope
    set?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    disconnect?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    delete?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    connect?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    update?: ItemCategoryUpdateWithWhereUniqueWithoutParentInput | ItemCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ItemCategoryUpdateManyWithWhereWithoutParentInput | ItemCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ItemCategoryScalarWhereInput | ItemCategoryScalarWhereInput[]
  }

  export type ItemUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput> | ItemCreateWithoutCategoryInput[] | ItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCategoryInput | ItemCreateOrConnectWithoutCategoryInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutCategoryInput | ItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ItemCreateManyCategoryInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutCategoryInput | ItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutCategoryInput | ItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemAttributeTemplateUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ItemAttributeTemplateCreateWithoutCategoryInput, ItemAttributeTemplateUncheckedCreateWithoutCategoryInput> | ItemAttributeTemplateCreateWithoutCategoryInput[] | ItemAttributeTemplateUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemAttributeTemplateCreateOrConnectWithoutCategoryInput | ItemAttributeTemplateCreateOrConnectWithoutCategoryInput[]
    upsert?: ItemAttributeTemplateUpsertWithWhereUniqueWithoutCategoryInput | ItemAttributeTemplateUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ItemAttributeTemplateCreateManyCategoryInputEnvelope
    set?: ItemAttributeTemplateWhereUniqueInput | ItemAttributeTemplateWhereUniqueInput[]
    disconnect?: ItemAttributeTemplateWhereUniqueInput | ItemAttributeTemplateWhereUniqueInput[]
    delete?: ItemAttributeTemplateWhereUniqueInput | ItemAttributeTemplateWhereUniqueInput[]
    connect?: ItemAttributeTemplateWhereUniqueInput | ItemAttributeTemplateWhereUniqueInput[]
    update?: ItemAttributeTemplateUpdateWithWhereUniqueWithoutCategoryInput | ItemAttributeTemplateUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ItemAttributeTemplateUpdateManyWithWhereWithoutCategoryInput | ItemAttributeTemplateUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ItemAttributeTemplateScalarWhereInput | ItemAttributeTemplateScalarWhereInput[]
  }

  export type ItemCategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutParentInput, ItemCategoryUncheckedCreateWithoutParentInput> | ItemCategoryCreateWithoutParentInput[] | ItemCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutParentInput | ItemCategoryCreateOrConnectWithoutParentInput[]
    upsert?: ItemCategoryUpsertWithWhereUniqueWithoutParentInput | ItemCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ItemCategoryCreateManyParentInputEnvelope
    set?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    disconnect?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    delete?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    connect?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    update?: ItemCategoryUpdateWithWhereUniqueWithoutParentInput | ItemCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ItemCategoryUpdateManyWithWhereWithoutParentInput | ItemCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ItemCategoryScalarWhereInput | ItemCategoryScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput> | ItemCreateWithoutCategoryInput[] | ItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCategoryInput | ItemCreateOrConnectWithoutCategoryInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutCategoryInput | ItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ItemCreateManyCategoryInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutCategoryInput | ItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutCategoryInput | ItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemAttributeTemplateUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ItemAttributeTemplateCreateWithoutCategoryInput, ItemAttributeTemplateUncheckedCreateWithoutCategoryInput> | ItemAttributeTemplateCreateWithoutCategoryInput[] | ItemAttributeTemplateUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemAttributeTemplateCreateOrConnectWithoutCategoryInput | ItemAttributeTemplateCreateOrConnectWithoutCategoryInput[]
    upsert?: ItemAttributeTemplateUpsertWithWhereUniqueWithoutCategoryInput | ItemAttributeTemplateUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ItemAttributeTemplateCreateManyCategoryInputEnvelope
    set?: ItemAttributeTemplateWhereUniqueInput | ItemAttributeTemplateWhereUniqueInput[]
    disconnect?: ItemAttributeTemplateWhereUniqueInput | ItemAttributeTemplateWhereUniqueInput[]
    delete?: ItemAttributeTemplateWhereUniqueInput | ItemAttributeTemplateWhereUniqueInput[]
    connect?: ItemAttributeTemplateWhereUniqueInput | ItemAttributeTemplateWhereUniqueInput[]
    update?: ItemAttributeTemplateUpdateWithWhereUniqueWithoutCategoryInput | ItemAttributeTemplateUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ItemAttributeTemplateUpdateManyWithWhereWithoutCategoryInput | ItemAttributeTemplateUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ItemAttributeTemplateScalarWhereInput | ItemAttributeTemplateScalarWhereInput[]
  }

  export type ItemCreateNestedOneWithoutImagesInput = {
    create?: XOR<ItemCreateWithoutImagesInput, ItemUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutImagesInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<ItemCreateWithoutImagesInput, ItemUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutImagesInput
    upsert?: ItemUpsertWithoutImagesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutImagesInput, ItemUpdateWithoutImagesInput>, ItemUncheckedUpdateWithoutImagesInput>
  }

  export type ItemVariantCreateNestedOneWithoutPricesInput = {
    create?: XOR<ItemVariantCreateWithoutPricesInput, ItemVariantUncheckedCreateWithoutPricesInput>
    connectOrCreate?: ItemVariantCreateOrConnectWithoutPricesInput
    connect?: ItemVariantWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumPriceTypeFieldUpdateOperationsInput = {
    set?: $Enums.PriceType
  }

  export type ItemVariantUpdateOneRequiredWithoutPricesNestedInput = {
    create?: XOR<ItemVariantCreateWithoutPricesInput, ItemVariantUncheckedCreateWithoutPricesInput>
    connectOrCreate?: ItemVariantCreateOrConnectWithoutPricesInput
    upsert?: ItemVariantUpsertWithoutPricesInput
    connect?: ItemVariantWhereUniqueInput
    update?: XOR<XOR<ItemVariantUpdateToOneWithWhereWithoutPricesInput, ItemVariantUpdateWithoutPricesInput>, ItemVariantUncheckedUpdateWithoutPricesInput>
  }

  export type ItemCreateNestedManyWithoutItemTypeInput = {
    create?: XOR<ItemCreateWithoutItemTypeInput, ItemUncheckedCreateWithoutItemTypeInput> | ItemCreateWithoutItemTypeInput[] | ItemUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItemTypeInput | ItemCreateOrConnectWithoutItemTypeInput[]
    createMany?: ItemCreateManyItemTypeInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutItemTypeInput = {
    create?: XOR<ItemCreateWithoutItemTypeInput, ItemUncheckedCreateWithoutItemTypeInput> | ItemCreateWithoutItemTypeInput[] | ItemUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItemTypeInput | ItemCreateOrConnectWithoutItemTypeInput[]
    createMany?: ItemCreateManyItemTypeInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemUpdateManyWithoutItemTypeNestedInput = {
    create?: XOR<ItemCreateWithoutItemTypeInput, ItemUncheckedCreateWithoutItemTypeInput> | ItemCreateWithoutItemTypeInput[] | ItemUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItemTypeInput | ItemCreateOrConnectWithoutItemTypeInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutItemTypeInput | ItemUpsertWithWhereUniqueWithoutItemTypeInput[]
    createMany?: ItemCreateManyItemTypeInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutItemTypeInput | ItemUpdateWithWhereUniqueWithoutItemTypeInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutItemTypeInput | ItemUpdateManyWithWhereWithoutItemTypeInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutItemTypeNestedInput = {
    create?: XOR<ItemCreateWithoutItemTypeInput, ItemUncheckedCreateWithoutItemTypeInput> | ItemCreateWithoutItemTypeInput[] | ItemUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItemTypeInput | ItemCreateOrConnectWithoutItemTypeInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutItemTypeInput | ItemUpsertWithWhereUniqueWithoutItemTypeInput[]
    createMany?: ItemCreateManyItemTypeInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutItemTypeInput | ItemUpdateWithWhereUniqueWithoutItemTypeInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutItemTypeInput | ItemUpdateManyWithWhereWithoutItemTypeInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemCreateNestedOneWithoutUpdateHistoriesInput = {
    create?: XOR<ItemCreateWithoutUpdateHistoriesInput, ItemUncheckedCreateWithoutUpdateHistoriesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutUpdateHistoriesInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutUpdateHistoriesNestedInput = {
    create?: XOR<ItemCreateWithoutUpdateHistoriesInput, ItemUncheckedCreateWithoutUpdateHistoriesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutUpdateHistoriesInput
    upsert?: ItemUpsertWithoutUpdateHistoriesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutUpdateHistoriesInput, ItemUpdateWithoutUpdateHistoriesInput>, ItemUncheckedUpdateWithoutUpdateHistoriesInput>
  }

  export type ItemCreateNestedOneWithoutVariantsInput = {
    create?: XOR<ItemCreateWithoutVariantsInput, ItemUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutVariantsInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemPriceCreateNestedManyWithoutVariantInput = {
    create?: XOR<ItemPriceCreateWithoutVariantInput, ItemPriceUncheckedCreateWithoutVariantInput> | ItemPriceCreateWithoutVariantInput[] | ItemPriceUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ItemPriceCreateOrConnectWithoutVariantInput | ItemPriceCreateOrConnectWithoutVariantInput[]
    createMany?: ItemPriceCreateManyVariantInputEnvelope
    connect?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
  }

  export type ItemPriceUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<ItemPriceCreateWithoutVariantInput, ItemPriceUncheckedCreateWithoutVariantInput> | ItemPriceCreateWithoutVariantInput[] | ItemPriceUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ItemPriceCreateOrConnectWithoutVariantInput | ItemPriceCreateOrConnectWithoutVariantInput[]
    createMany?: ItemPriceCreateManyVariantInputEnvelope
    connect?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
  }

  export type ItemUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<ItemCreateWithoutVariantsInput, ItemUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutVariantsInput
    upsert?: ItemUpsertWithoutVariantsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutVariantsInput, ItemUpdateWithoutVariantsInput>, ItemUncheckedUpdateWithoutVariantsInput>
  }

  export type ItemPriceUpdateManyWithoutVariantNestedInput = {
    create?: XOR<ItemPriceCreateWithoutVariantInput, ItemPriceUncheckedCreateWithoutVariantInput> | ItemPriceCreateWithoutVariantInput[] | ItemPriceUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ItemPriceCreateOrConnectWithoutVariantInput | ItemPriceCreateOrConnectWithoutVariantInput[]
    upsert?: ItemPriceUpsertWithWhereUniqueWithoutVariantInput | ItemPriceUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: ItemPriceCreateManyVariantInputEnvelope
    set?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
    disconnect?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
    delete?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
    connect?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
    update?: ItemPriceUpdateWithWhereUniqueWithoutVariantInput | ItemPriceUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: ItemPriceUpdateManyWithWhereWithoutVariantInput | ItemPriceUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: ItemPriceScalarWhereInput | ItemPriceScalarWhereInput[]
  }

  export type ItemPriceUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<ItemPriceCreateWithoutVariantInput, ItemPriceUncheckedCreateWithoutVariantInput> | ItemPriceCreateWithoutVariantInput[] | ItemPriceUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ItemPriceCreateOrConnectWithoutVariantInput | ItemPriceCreateOrConnectWithoutVariantInput[]
    upsert?: ItemPriceUpsertWithWhereUniqueWithoutVariantInput | ItemPriceUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: ItemPriceCreateManyVariantInputEnvelope
    set?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
    disconnect?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
    delete?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
    connect?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
    update?: ItemPriceUpdateWithWhereUniqueWithoutVariantInput | ItemPriceUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: ItemPriceUpdateManyWithWhereWithoutVariantInput | ItemPriceUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: ItemPriceScalarWhereInput | ItemPriceScalarWhereInput[]
  }

  export type ItemCreateNestedOneWithoutVideosInput = {
    create?: XOR<ItemCreateWithoutVideosInput, ItemUncheckedCreateWithoutVideosInput>
    connectOrCreate?: ItemCreateOrConnectWithoutVideosInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<ItemCreateWithoutVideosInput, ItemUncheckedCreateWithoutVideosInput>
    connectOrCreate?: ItemCreateOrConnectWithoutVideosInput
    upsert?: ItemUpsertWithoutVideosInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutVideosInput, ItemUpdateWithoutVideosInput>, ItemUncheckedUpdateWithoutVideosInput>
  }

  export type UserAdminCreateNestedOneWithoutUserInput = {
    create?: XOR<UserAdminCreateWithoutUserInput, UserAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAdminCreateOrConnectWithoutUserInput
    connect?: UserAdminWhereUniqueInput
  }

  export type UserCustomerCreateNestedOneWithoutUserInput = {
    create?: XOR<UserCustomerCreateWithoutUserInput, UserCustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserCustomerCreateOrConnectWithoutUserInput
    connect?: UserCustomerWhereUniqueInput
  }

  export type UserAdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserAdminCreateWithoutUserInput, UserAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAdminCreateOrConnectWithoutUserInput
    connect?: UserAdminWhereUniqueInput
  }

  export type UserCustomerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserCustomerCreateWithoutUserInput, UserCustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserCustomerCreateOrConnectWithoutUserInput
    connect?: UserCustomerWhereUniqueInput
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type UserAdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserAdminCreateWithoutUserInput, UserAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAdminCreateOrConnectWithoutUserInput
    upsert?: UserAdminUpsertWithoutUserInput
    disconnect?: UserAdminWhereInput | boolean
    delete?: UserAdminWhereInput | boolean
    connect?: UserAdminWhereUniqueInput
    update?: XOR<XOR<UserAdminUpdateToOneWithWhereWithoutUserInput, UserAdminUpdateWithoutUserInput>, UserAdminUncheckedUpdateWithoutUserInput>
  }

  export type UserCustomerUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserCustomerCreateWithoutUserInput, UserCustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserCustomerCreateOrConnectWithoutUserInput
    upsert?: UserCustomerUpsertWithoutUserInput
    disconnect?: UserCustomerWhereInput | boolean
    delete?: UserCustomerWhereInput | boolean
    connect?: UserCustomerWhereUniqueInput
    update?: XOR<XOR<UserCustomerUpdateToOneWithWhereWithoutUserInput, UserCustomerUpdateWithoutUserInput>, UserCustomerUncheckedUpdateWithoutUserInput>
  }

  export type UserAdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserAdminCreateWithoutUserInput, UserAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAdminCreateOrConnectWithoutUserInput
    upsert?: UserAdminUpsertWithoutUserInput
    disconnect?: UserAdminWhereInput | boolean
    delete?: UserAdminWhereInput | boolean
    connect?: UserAdminWhereUniqueInput
    update?: XOR<XOR<UserAdminUpdateToOneWithWhereWithoutUserInput, UserAdminUpdateWithoutUserInput>, UserAdminUncheckedUpdateWithoutUserInput>
  }

  export type UserCustomerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserCustomerCreateWithoutUserInput, UserCustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserCustomerCreateOrConnectWithoutUserInput
    upsert?: UserCustomerUpsertWithoutUserInput
    disconnect?: UserCustomerWhereInput | boolean
    delete?: UserCustomerWhereInput | boolean
    connect?: UserCustomerWhereUniqueInput
    update?: XOR<XOR<UserCustomerUpdateToOneWithWhereWithoutUserInput, UserCustomerUpdateWithoutUserInput>, UserCustomerUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutAdminProfileInput = {
    create?: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminProfileNestedInput = {
    create?: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminProfileInput
    upsert?: UserUpsertWithoutAdminProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminProfileInput, UserUpdateWithoutAdminProfileInput>, UserUncheckedUpdateWithoutAdminProfileInput>
  }

  export type UserCreateNestedOneWithoutCustomerProfileInput = {
    create?: XOR<UserCreateWithoutCustomerProfileInput, UserUncheckedCreateWithoutCustomerProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserCustomerAddressCreateNestedManyWithoutCustomerInput = {
    create?: XOR<UserCustomerAddressCreateWithoutCustomerInput, UserCustomerAddressUncheckedCreateWithoutCustomerInput> | UserCustomerAddressCreateWithoutCustomerInput[] | UserCustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: UserCustomerAddressCreateOrConnectWithoutCustomerInput | UserCustomerAddressCreateOrConnectWithoutCustomerInput[]
    createMany?: UserCustomerAddressCreateManyCustomerInputEnvelope
    connect?: UserCustomerAddressWhereUniqueInput | UserCustomerAddressWhereUniqueInput[]
  }

  export type UserMemberCreateNestedOneWithoutCustomerInput = {
    create?: XOR<UserMemberCreateWithoutCustomerInput, UserMemberUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserMemberCreateOrConnectWithoutCustomerInput
    connect?: UserMemberWhereUniqueInput
  }

  export type CustomerResponseCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerResponseCreateWithoutCustomerInput, CustomerResponseUncheckedCreateWithoutCustomerInput> | CustomerResponseCreateWithoutCustomerInput[] | CustomerResponseUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerResponseCreateOrConnectWithoutCustomerInput | CustomerResponseCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerResponseCreateManyCustomerInputEnvelope
    connect?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
  }

  export type UserCustomerAddressUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<UserCustomerAddressCreateWithoutCustomerInput, UserCustomerAddressUncheckedCreateWithoutCustomerInput> | UserCustomerAddressCreateWithoutCustomerInput[] | UserCustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: UserCustomerAddressCreateOrConnectWithoutCustomerInput | UserCustomerAddressCreateOrConnectWithoutCustomerInput[]
    createMany?: UserCustomerAddressCreateManyCustomerInputEnvelope
    connect?: UserCustomerAddressWhereUniqueInput | UserCustomerAddressWhereUniqueInput[]
  }

  export type UserMemberUncheckedCreateNestedOneWithoutCustomerInput = {
    create?: XOR<UserMemberCreateWithoutCustomerInput, UserMemberUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserMemberCreateOrConnectWithoutCustomerInput
    connect?: UserMemberWhereUniqueInput
  }

  export type CustomerResponseUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerResponseCreateWithoutCustomerInput, CustomerResponseUncheckedCreateWithoutCustomerInput> | CustomerResponseCreateWithoutCustomerInput[] | CustomerResponseUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerResponseCreateOrConnectWithoutCustomerInput | CustomerResponseCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerResponseCreateManyCustomerInputEnvelope
    connect?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCustomerProfileNestedInput = {
    create?: XOR<UserCreateWithoutCustomerProfileInput, UserUncheckedCreateWithoutCustomerProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerProfileInput
    upsert?: UserUpsertWithoutCustomerProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCustomerProfileInput, UserUpdateWithoutCustomerProfileInput>, UserUncheckedUpdateWithoutCustomerProfileInput>
  }

  export type UserCustomerAddressUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<UserCustomerAddressCreateWithoutCustomerInput, UserCustomerAddressUncheckedCreateWithoutCustomerInput> | UserCustomerAddressCreateWithoutCustomerInput[] | UserCustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: UserCustomerAddressCreateOrConnectWithoutCustomerInput | UserCustomerAddressCreateOrConnectWithoutCustomerInput[]
    upsert?: UserCustomerAddressUpsertWithWhereUniqueWithoutCustomerInput | UserCustomerAddressUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: UserCustomerAddressCreateManyCustomerInputEnvelope
    set?: UserCustomerAddressWhereUniqueInput | UserCustomerAddressWhereUniqueInput[]
    disconnect?: UserCustomerAddressWhereUniqueInput | UserCustomerAddressWhereUniqueInput[]
    delete?: UserCustomerAddressWhereUniqueInput | UserCustomerAddressWhereUniqueInput[]
    connect?: UserCustomerAddressWhereUniqueInput | UserCustomerAddressWhereUniqueInput[]
    update?: UserCustomerAddressUpdateWithWhereUniqueWithoutCustomerInput | UserCustomerAddressUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: UserCustomerAddressUpdateManyWithWhereWithoutCustomerInput | UserCustomerAddressUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: UserCustomerAddressScalarWhereInput | UserCustomerAddressScalarWhereInput[]
  }

  export type UserMemberUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<UserMemberCreateWithoutCustomerInput, UserMemberUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserMemberCreateOrConnectWithoutCustomerInput
    upsert?: UserMemberUpsertWithoutCustomerInput
    disconnect?: UserMemberWhereInput | boolean
    delete?: UserMemberWhereInput | boolean
    connect?: UserMemberWhereUniqueInput
    update?: XOR<XOR<UserMemberUpdateToOneWithWhereWithoutCustomerInput, UserMemberUpdateWithoutCustomerInput>, UserMemberUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerResponseUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerResponseCreateWithoutCustomerInput, CustomerResponseUncheckedCreateWithoutCustomerInput> | CustomerResponseCreateWithoutCustomerInput[] | CustomerResponseUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerResponseCreateOrConnectWithoutCustomerInput | CustomerResponseCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerResponseUpsertWithWhereUniqueWithoutCustomerInput | CustomerResponseUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerResponseCreateManyCustomerInputEnvelope
    set?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
    disconnect?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
    delete?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
    connect?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
    update?: CustomerResponseUpdateWithWhereUniqueWithoutCustomerInput | CustomerResponseUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerResponseUpdateManyWithWhereWithoutCustomerInput | CustomerResponseUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerResponseScalarWhereInput | CustomerResponseScalarWhereInput[]
  }

  export type UserCustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<UserCustomerAddressCreateWithoutCustomerInput, UserCustomerAddressUncheckedCreateWithoutCustomerInput> | UserCustomerAddressCreateWithoutCustomerInput[] | UserCustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: UserCustomerAddressCreateOrConnectWithoutCustomerInput | UserCustomerAddressCreateOrConnectWithoutCustomerInput[]
    upsert?: UserCustomerAddressUpsertWithWhereUniqueWithoutCustomerInput | UserCustomerAddressUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: UserCustomerAddressCreateManyCustomerInputEnvelope
    set?: UserCustomerAddressWhereUniqueInput | UserCustomerAddressWhereUniqueInput[]
    disconnect?: UserCustomerAddressWhereUniqueInput | UserCustomerAddressWhereUniqueInput[]
    delete?: UserCustomerAddressWhereUniqueInput | UserCustomerAddressWhereUniqueInput[]
    connect?: UserCustomerAddressWhereUniqueInput | UserCustomerAddressWhereUniqueInput[]
    update?: UserCustomerAddressUpdateWithWhereUniqueWithoutCustomerInput | UserCustomerAddressUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: UserCustomerAddressUpdateManyWithWhereWithoutCustomerInput | UserCustomerAddressUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: UserCustomerAddressScalarWhereInput | UserCustomerAddressScalarWhereInput[]
  }

  export type UserMemberUncheckedUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<UserMemberCreateWithoutCustomerInput, UserMemberUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserMemberCreateOrConnectWithoutCustomerInput
    upsert?: UserMemberUpsertWithoutCustomerInput
    disconnect?: UserMemberWhereInput | boolean
    delete?: UserMemberWhereInput | boolean
    connect?: UserMemberWhereUniqueInput
    update?: XOR<XOR<UserMemberUpdateToOneWithWhereWithoutCustomerInput, UserMemberUpdateWithoutCustomerInput>, UserMemberUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerResponseUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerResponseCreateWithoutCustomerInput, CustomerResponseUncheckedCreateWithoutCustomerInput> | CustomerResponseCreateWithoutCustomerInput[] | CustomerResponseUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerResponseCreateOrConnectWithoutCustomerInput | CustomerResponseCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerResponseUpsertWithWhereUniqueWithoutCustomerInput | CustomerResponseUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerResponseCreateManyCustomerInputEnvelope
    set?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
    disconnect?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
    delete?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
    connect?: CustomerResponseWhereUniqueInput | CustomerResponseWhereUniqueInput[]
    update?: CustomerResponseUpdateWithWhereUniqueWithoutCustomerInput | CustomerResponseUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerResponseUpdateManyWithWhereWithoutCustomerInput | CustomerResponseUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerResponseScalarWhereInput | CustomerResponseScalarWhereInput[]
  }

  export type UserCustomerCreateNestedOneWithoutAddressesInput = {
    create?: XOR<UserCustomerCreateWithoutAddressesInput, UserCustomerUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: UserCustomerCreateOrConnectWithoutAddressesInput
    connect?: UserCustomerWhereUniqueInput
  }

  export type UserCustomerUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<UserCustomerCreateWithoutAddressesInput, UserCustomerUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: UserCustomerCreateOrConnectWithoutAddressesInput
    upsert?: UserCustomerUpsertWithoutAddressesInput
    connect?: UserCustomerWhereUniqueInput
    update?: XOR<XOR<UserCustomerUpdateToOneWithWhereWithoutAddressesInput, UserCustomerUpdateWithoutAddressesInput>, UserCustomerUncheckedUpdateWithoutAddressesInput>
  }

  export type UserCustomerCreateNestedOneWithoutMemberInput = {
    create?: XOR<UserCustomerCreateWithoutMemberInput, UserCustomerUncheckedCreateWithoutMemberInput>
    connectOrCreate?: UserCustomerCreateOrConnectWithoutMemberInput
    connect?: UserCustomerWhereUniqueInput
  }

  export type EnumMemberTierFieldUpdateOperationsInput = {
    set?: $Enums.MemberTier
  }

  export type UserCustomerUpdateOneRequiredWithoutMemberNestedInput = {
    create?: XOR<UserCustomerCreateWithoutMemberInput, UserCustomerUncheckedCreateWithoutMemberInput>
    connectOrCreate?: UserCustomerCreateOrConnectWithoutMemberInput
    upsert?: UserCustomerUpsertWithoutMemberInput
    connect?: UserCustomerWhereUniqueInput
    update?: XOR<XOR<UserCustomerUpdateToOneWithWhereWithoutMemberInput, UserCustomerUpdateWithoutMemberInput>, UserCustomerUncheckedUpdateWithoutMemberInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumFieldTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[]
    notIn?: $Enums.FieldType[]
    not?: NestedEnumFieldTypeFilter<$PrismaModel> | $Enums.FieldType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumFieldTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[]
    notIn?: $Enums.FieldType[]
    not?: NestedEnumFieldTypeWithAggregatesFilter<$PrismaModel> | $Enums.FieldType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFieldTypeFilter<$PrismaModel>
    _max?: NestedEnumFieldTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemStatus | EnumItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ItemStatus[]
    notIn?: $Enums.ItemStatus[]
    not?: NestedEnumItemStatusFilter<$PrismaModel> | $Enums.ItemStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemStatus | EnumItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ItemStatus[]
    notIn?: $Enums.ItemStatus[]
    not?: NestedEnumItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.ItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemStatusFilter<$PrismaModel>
    _max?: NestedEnumItemStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAttributeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AttributeType | EnumAttributeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttributeType[]
    notIn?: $Enums.AttributeType[]
    not?: NestedEnumAttributeTypeFilter<$PrismaModel> | $Enums.AttributeType
  }

  export type NestedEnumAttributeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttributeType | EnumAttributeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttributeType[]
    notIn?: $Enums.AttributeType[]
    not?: NestedEnumAttributeTypeWithAggregatesFilter<$PrismaModel> | $Enums.AttributeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttributeTypeFilter<$PrismaModel>
    _max?: NestedEnumAttributeTypeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumPriceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceType | EnumPriceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PriceType[]
    notIn?: $Enums.PriceType[]
    not?: NestedEnumPriceTypeFilter<$PrismaModel> | $Enums.PriceType
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumPriceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceType | EnumPriceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PriceType[]
    notIn?: $Enums.PriceType[]
    not?: NestedEnumPriceTypeWithAggregatesFilter<$PrismaModel> | $Enums.PriceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriceTypeFilter<$PrismaModel>
    _max?: NestedEnumPriceTypeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumMemberTierFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberTier | EnumMemberTierFieldRefInput<$PrismaModel>
    in?: $Enums.MemberTier[]
    notIn?: $Enums.MemberTier[]
    not?: NestedEnumMemberTierFilter<$PrismaModel> | $Enums.MemberTier
  }

  export type NestedEnumMemberTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberTier | EnumMemberTierFieldRefInput<$PrismaModel>
    in?: $Enums.MemberTier[]
    notIn?: $Enums.MemberTier[]
    not?: NestedEnumMemberTierWithAggregatesFilter<$PrismaModel> | $Enums.MemberTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberTierFilter<$PrismaModel>
    _max?: NestedEnumMemberTierFilter<$PrismaModel>
  }

  export type CustomerResponseCreateWithoutFieldInput = {
    answer: string
    createdAt?: Date | string
    customer: UserCustomerCreateNestedOneWithoutResponsesInput
  }

  export type CustomerResponseUncheckedCreateWithoutFieldInput = {
    id?: number
    userCustomerId: number
    answer: string
    createdAt?: Date | string
  }

  export type CustomerResponseCreateOrConnectWithoutFieldInput = {
    where: CustomerResponseWhereUniqueInput
    create: XOR<CustomerResponseCreateWithoutFieldInput, CustomerResponseUncheckedCreateWithoutFieldInput>
  }

  export type CustomerResponseCreateManyFieldInputEnvelope = {
    data: CustomerResponseCreateManyFieldInput | CustomerResponseCreateManyFieldInput[]
    skipDuplicates?: boolean
  }

  export type CustomerResponseUpsertWithWhereUniqueWithoutFieldInput = {
    where: CustomerResponseWhereUniqueInput
    update: XOR<CustomerResponseUpdateWithoutFieldInput, CustomerResponseUncheckedUpdateWithoutFieldInput>
    create: XOR<CustomerResponseCreateWithoutFieldInput, CustomerResponseUncheckedCreateWithoutFieldInput>
  }

  export type CustomerResponseUpdateWithWhereUniqueWithoutFieldInput = {
    where: CustomerResponseWhereUniqueInput
    data: XOR<CustomerResponseUpdateWithoutFieldInput, CustomerResponseUncheckedUpdateWithoutFieldInput>
  }

  export type CustomerResponseUpdateManyWithWhereWithoutFieldInput = {
    where: CustomerResponseScalarWhereInput
    data: XOR<CustomerResponseUpdateManyMutationInput, CustomerResponseUncheckedUpdateManyWithoutFieldInput>
  }

  export type CustomerResponseScalarWhereInput = {
    AND?: CustomerResponseScalarWhereInput | CustomerResponseScalarWhereInput[]
    OR?: CustomerResponseScalarWhereInput[]
    NOT?: CustomerResponseScalarWhereInput | CustomerResponseScalarWhereInput[]
    id?: IntFilter<"CustomerResponse"> | number
    userCustomerId?: IntFilter<"CustomerResponse"> | number
    fieldId?: IntFilter<"CustomerResponse"> | number
    answer?: StringFilter<"CustomerResponse"> | string
    createdAt?: DateTimeFilter<"CustomerResponse"> | Date | string
  }

  export type UserCustomerCreateWithoutResponsesInput = {
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    loyaltyPoint?: number
    referralCode?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    user: UserCreateNestedOneWithoutCustomerProfileInput
    addresses?: UserCustomerAddressCreateNestedManyWithoutCustomerInput
    member?: UserMemberCreateNestedOneWithoutCustomerInput
  }

  export type UserCustomerUncheckedCreateWithoutResponsesInput = {
    id?: number
    userId: number
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    loyaltyPoint?: number
    referralCode?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    addresses?: UserCustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    member?: UserMemberUncheckedCreateNestedOneWithoutCustomerInput
  }

  export type UserCustomerCreateOrConnectWithoutResponsesInput = {
    where: UserCustomerWhereUniqueInput
    create: XOR<UserCustomerCreateWithoutResponsesInput, UserCustomerUncheckedCreateWithoutResponsesInput>
  }

  export type CustomerFormFieldCreateWithoutResponsesInput = {
    label: string
    fieldKey: string
    type?: $Enums.FieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerFormFieldUncheckedCreateWithoutResponsesInput = {
    id?: number
    label: string
    fieldKey: string
    type?: $Enums.FieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerFormFieldCreateOrConnectWithoutResponsesInput = {
    where: CustomerFormFieldWhereUniqueInput
    create: XOR<CustomerFormFieldCreateWithoutResponsesInput, CustomerFormFieldUncheckedCreateWithoutResponsesInput>
  }

  export type UserCustomerUpsertWithoutResponsesInput = {
    update: XOR<UserCustomerUpdateWithoutResponsesInput, UserCustomerUncheckedUpdateWithoutResponsesInput>
    create: XOR<UserCustomerCreateWithoutResponsesInput, UserCustomerUncheckedCreateWithoutResponsesInput>
    where?: UserCustomerWhereInput
  }

  export type UserCustomerUpdateToOneWithWhereWithoutResponsesInput = {
    where?: UserCustomerWhereInput
    data: XOR<UserCustomerUpdateWithoutResponsesInput, UserCustomerUncheckedUpdateWithoutResponsesInput>
  }

  export type UserCustomerUpdateWithoutResponsesInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoint?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCustomerProfileNestedInput
    addresses?: UserCustomerAddressUpdateManyWithoutCustomerNestedInput
    member?: UserMemberUpdateOneWithoutCustomerNestedInput
  }

  export type UserCustomerUncheckedUpdateWithoutResponsesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoint?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addresses?: UserCustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    member?: UserMemberUncheckedUpdateOneWithoutCustomerNestedInput
  }

  export type CustomerFormFieldUpsertWithoutResponsesInput = {
    update: XOR<CustomerFormFieldUpdateWithoutResponsesInput, CustomerFormFieldUncheckedUpdateWithoutResponsesInput>
    create: XOR<CustomerFormFieldCreateWithoutResponsesInput, CustomerFormFieldUncheckedCreateWithoutResponsesInput>
    where?: CustomerFormFieldWhereInput
  }

  export type CustomerFormFieldUpdateToOneWithWhereWithoutResponsesInput = {
    where?: CustomerFormFieldWhereInput
    data: XOR<CustomerFormFieldUpdateWithoutResponsesInput, CustomerFormFieldUncheckedUpdateWithoutResponsesInput>
  }

  export type CustomerFormFieldUpdateWithoutResponsesInput = {
    label?: StringFieldUpdateOperationsInput | string
    fieldKey?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerFormFieldUncheckedUpdateWithoutResponsesInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    fieldKey?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemTypeCreateWithoutItemsInput = {
    name: string
    description?: string | null
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemTypeUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    description?: string | null
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemTypeCreateOrConnectWithoutItemsInput = {
    where: ItemTypeWhereUniqueInput
    create: XOR<ItemTypeCreateWithoutItemsInput, ItemTypeUncheckedCreateWithoutItemsInput>
  }

  export type ItemCategoryCreateWithoutItemsInput = {
    name: string
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    parent?: ItemCategoryCreateNestedOneWithoutChildrenInput
    children?: ItemCategoryCreateNestedManyWithoutParentInput
    attributeTemplates?: ItemAttributeTemplateCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryUncheckedCreateWithoutItemsInput = {
    id?: number
    parentId?: number | null
    name: string
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: ItemCategoryUncheckedCreateNestedManyWithoutParentInput
    attributeTemplates?: ItemAttributeTemplateUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryCreateOrConnectWithoutItemsInput = {
    where: ItemCategoryWhereUniqueInput
    create: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
  }

  export type ItemVariantCreateWithoutItemInput = {
    id?: bigint | number
    code: string
    name?: string | null
    imageUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    quantity?: number
    options?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    prices?: ItemPriceCreateNestedManyWithoutVariantInput
  }

  export type ItemVariantUncheckedCreateWithoutItemInput = {
    id?: bigint | number
    code: string
    name?: string | null
    imageUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    quantity?: number
    options?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    prices?: ItemPriceUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ItemVariantCreateOrConnectWithoutItemInput = {
    where: ItemVariantWhereUniqueInput
    create: XOR<ItemVariantCreateWithoutItemInput, ItemVariantUncheckedCreateWithoutItemInput>
  }

  export type ItemVariantCreateManyItemInputEnvelope = {
    data: ItemVariantCreateManyItemInput | ItemVariantCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ItemImageCreateWithoutItemInput = {
    id?: bigint | number
    url: string
    isPrimary?: boolean
    sortOrder?: number
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemImageUncheckedCreateWithoutItemInput = {
    id?: bigint | number
    url: string
    isPrimary?: boolean
    sortOrder?: number
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemImageCreateOrConnectWithoutItemInput = {
    where: ItemImageWhereUniqueInput
    create: XOR<ItemImageCreateWithoutItemInput, ItemImageUncheckedCreateWithoutItemInput>
  }

  export type ItemImageCreateManyItemInputEnvelope = {
    data: ItemImageCreateManyItemInput | ItemImageCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ItemVideoCreateWithoutItemInput = {
    id?: bigint | number
    url: string
    provider?: string | null
    isPrimary?: boolean
    sortOrder?: number
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemVideoUncheckedCreateWithoutItemInput = {
    id?: bigint | number
    url: string
    provider?: string | null
    isPrimary?: boolean
    sortOrder?: number
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemVideoCreateOrConnectWithoutItemInput = {
    where: ItemVideoWhereUniqueInput
    create: XOR<ItemVideoCreateWithoutItemInput, ItemVideoUncheckedCreateWithoutItemInput>
  }

  export type ItemVideoCreateManyItemInputEnvelope = {
    data: ItemVideoCreateManyItemInput | ItemVideoCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ItemUpdateHistoryCreateWithoutItemInput = {
    id?: bigint | number
    itemName: string
    userId: number
    userName: string
    columnName: string
    createdAt?: Date | string
  }

  export type ItemUpdateHistoryUncheckedCreateWithoutItemInput = {
    id?: bigint | number
    itemName: string
    userId: number
    userName: string
    columnName: string
    createdAt?: Date | string
  }

  export type ItemUpdateHistoryCreateOrConnectWithoutItemInput = {
    where: ItemUpdateHistoryWhereUniqueInput
    create: XOR<ItemUpdateHistoryCreateWithoutItemInput, ItemUpdateHistoryUncheckedCreateWithoutItemInput>
  }

  export type ItemUpdateHistoryCreateManyItemInputEnvelope = {
    data: ItemUpdateHistoryCreateManyItemInput | ItemUpdateHistoryCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ItemTypeUpsertWithoutItemsInput = {
    update: XOR<ItemTypeUpdateWithoutItemsInput, ItemTypeUncheckedUpdateWithoutItemsInput>
    create: XOR<ItemTypeCreateWithoutItemsInput, ItemTypeUncheckedCreateWithoutItemsInput>
    where?: ItemTypeWhereInput
  }

  export type ItemTypeUpdateToOneWithWhereWithoutItemsInput = {
    where?: ItemTypeWhereInput
    data: XOR<ItemTypeUpdateWithoutItemsInput, ItemTypeUncheckedUpdateWithoutItemsInput>
  }

  export type ItemTypeUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemTypeUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemCategoryUpsertWithoutItemsInput = {
    update: XOR<ItemCategoryUpdateWithoutItemsInput, ItemCategoryUncheckedUpdateWithoutItemsInput>
    create: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
    where?: ItemCategoryWhereInput
  }

  export type ItemCategoryUpdateToOneWithWhereWithoutItemsInput = {
    where?: ItemCategoryWhereInput
    data: XOR<ItemCategoryUpdateWithoutItemsInput, ItemCategoryUncheckedUpdateWithoutItemsInput>
  }

  export type ItemCategoryUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: ItemCategoryUpdateOneWithoutChildrenNestedInput
    children?: ItemCategoryUpdateManyWithoutParentNestedInput
    attributeTemplates?: ItemAttributeTemplateUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ItemCategoryUncheckedUpdateManyWithoutParentNestedInput
    attributeTemplates?: ItemAttributeTemplateUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ItemVariantUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemVariantWhereUniqueInput
    update: XOR<ItemVariantUpdateWithoutItemInput, ItemVariantUncheckedUpdateWithoutItemInput>
    create: XOR<ItemVariantCreateWithoutItemInput, ItemVariantUncheckedCreateWithoutItemInput>
  }

  export type ItemVariantUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemVariantWhereUniqueInput
    data: XOR<ItemVariantUpdateWithoutItemInput, ItemVariantUncheckedUpdateWithoutItemInput>
  }

  export type ItemVariantUpdateManyWithWhereWithoutItemInput = {
    where: ItemVariantScalarWhereInput
    data: XOR<ItemVariantUpdateManyMutationInput, ItemVariantUncheckedUpdateManyWithoutItemInput>
  }

  export type ItemVariantScalarWhereInput = {
    AND?: ItemVariantScalarWhereInput | ItemVariantScalarWhereInput[]
    OR?: ItemVariantScalarWhereInput[]
    NOT?: ItemVariantScalarWhereInput | ItemVariantScalarWhereInput[]
    id?: BigIntFilter<"ItemVariant"> | bigint | number
    itemId?: BigIntFilter<"ItemVariant"> | bigint | number
    code?: StringFilter<"ItemVariant"> | string
    name?: StringNullableFilter<"ItemVariant"> | string | null
    imageUrl?: StringNullableFilter<"ItemVariant"> | string | null
    price?: DecimalFilter<"ItemVariant"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"ItemVariant"> | number
    options?: JsonNullableFilter<"ItemVariant">
    isActive?: BoolFilter<"ItemVariant"> | boolean
    createdBy?: IntNullableFilter<"ItemVariant"> | number | null
    updatedBy?: IntNullableFilter<"ItemVariant"> | number | null
    deletedBy?: IntNullableFilter<"ItemVariant"> | number | null
    createdAt?: DateTimeFilter<"ItemVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ItemVariant"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemVariant"> | Date | string | null
  }

  export type ItemImageUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemImageWhereUniqueInput
    update: XOR<ItemImageUpdateWithoutItemInput, ItemImageUncheckedUpdateWithoutItemInput>
    create: XOR<ItemImageCreateWithoutItemInput, ItemImageUncheckedCreateWithoutItemInput>
  }

  export type ItemImageUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemImageWhereUniqueInput
    data: XOR<ItemImageUpdateWithoutItemInput, ItemImageUncheckedUpdateWithoutItemInput>
  }

  export type ItemImageUpdateManyWithWhereWithoutItemInput = {
    where: ItemImageScalarWhereInput
    data: XOR<ItemImageUpdateManyMutationInput, ItemImageUncheckedUpdateManyWithoutItemInput>
  }

  export type ItemImageScalarWhereInput = {
    AND?: ItemImageScalarWhereInput | ItemImageScalarWhereInput[]
    OR?: ItemImageScalarWhereInput[]
    NOT?: ItemImageScalarWhereInput | ItemImageScalarWhereInput[]
    id?: BigIntFilter<"ItemImage"> | bigint | number
    itemId?: BigIntFilter<"ItemImage"> | bigint | number
    url?: StringFilter<"ItemImage"> | string
    isPrimary?: BoolFilter<"ItemImage"> | boolean
    sortOrder?: IntFilter<"ItemImage"> | number
    createdBy?: IntNullableFilter<"ItemImage"> | number | null
    updatedBy?: IntNullableFilter<"ItemImage"> | number | null
    deletedBy?: IntNullableFilter<"ItemImage"> | number | null
    createdAt?: DateTimeFilter<"ItemImage"> | Date | string
    updatedAt?: DateTimeFilter<"ItemImage"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemImage"> | Date | string | null
  }

  export type ItemVideoUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemVideoWhereUniqueInput
    update: XOR<ItemVideoUpdateWithoutItemInput, ItemVideoUncheckedUpdateWithoutItemInput>
    create: XOR<ItemVideoCreateWithoutItemInput, ItemVideoUncheckedCreateWithoutItemInput>
  }

  export type ItemVideoUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemVideoWhereUniqueInput
    data: XOR<ItemVideoUpdateWithoutItemInput, ItemVideoUncheckedUpdateWithoutItemInput>
  }

  export type ItemVideoUpdateManyWithWhereWithoutItemInput = {
    where: ItemVideoScalarWhereInput
    data: XOR<ItemVideoUpdateManyMutationInput, ItemVideoUncheckedUpdateManyWithoutItemInput>
  }

  export type ItemVideoScalarWhereInput = {
    AND?: ItemVideoScalarWhereInput | ItemVideoScalarWhereInput[]
    OR?: ItemVideoScalarWhereInput[]
    NOT?: ItemVideoScalarWhereInput | ItemVideoScalarWhereInput[]
    id?: BigIntFilter<"ItemVideo"> | bigint | number
    itemId?: BigIntFilter<"ItemVideo"> | bigint | number
    url?: StringFilter<"ItemVideo"> | string
    provider?: StringNullableFilter<"ItemVideo"> | string | null
    isPrimary?: BoolFilter<"ItemVideo"> | boolean
    sortOrder?: IntFilter<"ItemVideo"> | number
    createdBy?: IntNullableFilter<"ItemVideo"> | number | null
    updatedBy?: IntNullableFilter<"ItemVideo"> | number | null
    deletedBy?: IntNullableFilter<"ItemVideo"> | number | null
    createdAt?: DateTimeFilter<"ItemVideo"> | Date | string
    updatedAt?: DateTimeFilter<"ItemVideo"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemVideo"> | Date | string | null
  }

  export type ItemUpdateHistoryUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemUpdateHistoryWhereUniqueInput
    update: XOR<ItemUpdateHistoryUpdateWithoutItemInput, ItemUpdateHistoryUncheckedUpdateWithoutItemInput>
    create: XOR<ItemUpdateHistoryCreateWithoutItemInput, ItemUpdateHistoryUncheckedCreateWithoutItemInput>
  }

  export type ItemUpdateHistoryUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemUpdateHistoryWhereUniqueInput
    data: XOR<ItemUpdateHistoryUpdateWithoutItemInput, ItemUpdateHistoryUncheckedUpdateWithoutItemInput>
  }

  export type ItemUpdateHistoryUpdateManyWithWhereWithoutItemInput = {
    where: ItemUpdateHistoryScalarWhereInput
    data: XOR<ItemUpdateHistoryUpdateManyMutationInput, ItemUpdateHistoryUncheckedUpdateManyWithoutItemInput>
  }

  export type ItemUpdateHistoryScalarWhereInput = {
    AND?: ItemUpdateHistoryScalarWhereInput | ItemUpdateHistoryScalarWhereInput[]
    OR?: ItemUpdateHistoryScalarWhereInput[]
    NOT?: ItemUpdateHistoryScalarWhereInput | ItemUpdateHistoryScalarWhereInput[]
    id?: BigIntFilter<"ItemUpdateHistory"> | bigint | number
    itemId?: BigIntFilter<"ItemUpdateHistory"> | bigint | number
    itemName?: StringFilter<"ItemUpdateHistory"> | string
    userId?: IntFilter<"ItemUpdateHistory"> | number
    userName?: StringFilter<"ItemUpdateHistory"> | string
    columnName?: StringFilter<"ItemUpdateHistory"> | string
    createdAt?: DateTimeFilter<"ItemUpdateHistory"> | Date | string
  }

  export type ItemCategoryCreateWithoutAttributeTemplatesInput = {
    name: string
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    parent?: ItemCategoryCreateNestedOneWithoutChildrenInput
    children?: ItemCategoryCreateNestedManyWithoutParentInput
    items?: ItemCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryUncheckedCreateWithoutAttributeTemplatesInput = {
    id?: number
    parentId?: number | null
    name: string
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: ItemCategoryUncheckedCreateNestedManyWithoutParentInput
    items?: ItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryCreateOrConnectWithoutAttributeTemplatesInput = {
    where: ItemCategoryWhereUniqueInput
    create: XOR<ItemCategoryCreateWithoutAttributeTemplatesInput, ItemCategoryUncheckedCreateWithoutAttributeTemplatesInput>
  }

  export type ItemCategoryUpsertWithoutAttributeTemplatesInput = {
    update: XOR<ItemCategoryUpdateWithoutAttributeTemplatesInput, ItemCategoryUncheckedUpdateWithoutAttributeTemplatesInput>
    create: XOR<ItemCategoryCreateWithoutAttributeTemplatesInput, ItemCategoryUncheckedCreateWithoutAttributeTemplatesInput>
    where?: ItemCategoryWhereInput
  }

  export type ItemCategoryUpdateToOneWithWhereWithoutAttributeTemplatesInput = {
    where?: ItemCategoryWhereInput
    data: XOR<ItemCategoryUpdateWithoutAttributeTemplatesInput, ItemCategoryUncheckedUpdateWithoutAttributeTemplatesInput>
  }

  export type ItemCategoryUpdateWithoutAttributeTemplatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: ItemCategoryUpdateOneWithoutChildrenNestedInput
    children?: ItemCategoryUpdateManyWithoutParentNestedInput
    items?: ItemUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryUncheckedUpdateWithoutAttributeTemplatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ItemCategoryUncheckedUpdateManyWithoutParentNestedInput
    items?: ItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryCreateWithoutChildrenInput = {
    name: string
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    parent?: ItemCategoryCreateNestedOneWithoutChildrenInput
    items?: ItemCreateNestedManyWithoutCategoryInput
    attributeTemplates?: ItemAttributeTemplateCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryUncheckedCreateWithoutChildrenInput = {
    id?: number
    parentId?: number | null
    name: string
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: ItemUncheckedCreateNestedManyWithoutCategoryInput
    attributeTemplates?: ItemAttributeTemplateUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryCreateOrConnectWithoutChildrenInput = {
    where: ItemCategoryWhereUniqueInput
    create: XOR<ItemCategoryCreateWithoutChildrenInput, ItemCategoryUncheckedCreateWithoutChildrenInput>
  }

  export type ItemCategoryCreateWithoutParentInput = {
    name: string
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: ItemCategoryCreateNestedManyWithoutParentInput
    items?: ItemCreateNestedManyWithoutCategoryInput
    attributeTemplates?: ItemAttributeTemplateCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryUncheckedCreateWithoutParentInput = {
    id?: number
    name: string
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: ItemCategoryUncheckedCreateNestedManyWithoutParentInput
    items?: ItemUncheckedCreateNestedManyWithoutCategoryInput
    attributeTemplates?: ItemAttributeTemplateUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryCreateOrConnectWithoutParentInput = {
    where: ItemCategoryWhereUniqueInput
    create: XOR<ItemCategoryCreateWithoutParentInput, ItemCategoryUncheckedCreateWithoutParentInput>
  }

  export type ItemCategoryCreateManyParentInputEnvelope = {
    data: ItemCategoryCreateManyParentInput | ItemCategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ItemCreateWithoutCategoryInput = {
    id?: bigint | number
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    tags?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    status?: $Enums.ItemStatus
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    itemType: ItemTypeCreateNestedOneWithoutItemsInput
    variants?: ItemVariantCreateNestedManyWithoutItemInput
    images?: ItemImageCreateNestedManyWithoutItemInput
    videos?: ItemVideoCreateNestedManyWithoutItemInput
    updateHistories?: ItemUpdateHistoryCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutCategoryInput = {
    id?: bigint | number
    itemTypeId: number
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    tags?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    status?: $Enums.ItemStatus
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    variants?: ItemVariantUncheckedCreateNestedManyWithoutItemInput
    images?: ItemImageUncheckedCreateNestedManyWithoutItemInput
    videos?: ItemVideoUncheckedCreateNestedManyWithoutItemInput
    updateHistories?: ItemUpdateHistoryUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutCategoryInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput>
  }

  export type ItemCreateManyCategoryInputEnvelope = {
    data: ItemCreateManyCategoryInput | ItemCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ItemAttributeTemplateCreateWithoutCategoryInput = {
    name: string
    type?: $Enums.AttributeType
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemAttributeTemplateUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    type?: $Enums.AttributeType
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemAttributeTemplateCreateOrConnectWithoutCategoryInput = {
    where: ItemAttributeTemplateWhereUniqueInput
    create: XOR<ItemAttributeTemplateCreateWithoutCategoryInput, ItemAttributeTemplateUncheckedCreateWithoutCategoryInput>
  }

  export type ItemAttributeTemplateCreateManyCategoryInputEnvelope = {
    data: ItemAttributeTemplateCreateManyCategoryInput | ItemAttributeTemplateCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ItemCategoryUpsertWithoutChildrenInput = {
    update: XOR<ItemCategoryUpdateWithoutChildrenInput, ItemCategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<ItemCategoryCreateWithoutChildrenInput, ItemCategoryUncheckedCreateWithoutChildrenInput>
    where?: ItemCategoryWhereInput
  }

  export type ItemCategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ItemCategoryWhereInput
    data: XOR<ItemCategoryUpdateWithoutChildrenInput, ItemCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type ItemCategoryUpdateWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: ItemCategoryUpdateOneWithoutChildrenNestedInput
    items?: ItemUpdateManyWithoutCategoryNestedInput
    attributeTemplates?: ItemAttributeTemplateUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: ItemUncheckedUpdateManyWithoutCategoryNestedInput
    attributeTemplates?: ItemAttributeTemplateUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: ItemCategoryWhereUniqueInput
    update: XOR<ItemCategoryUpdateWithoutParentInput, ItemCategoryUncheckedUpdateWithoutParentInput>
    create: XOR<ItemCategoryCreateWithoutParentInput, ItemCategoryUncheckedCreateWithoutParentInput>
  }

  export type ItemCategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: ItemCategoryWhereUniqueInput
    data: XOR<ItemCategoryUpdateWithoutParentInput, ItemCategoryUncheckedUpdateWithoutParentInput>
  }

  export type ItemCategoryUpdateManyWithWhereWithoutParentInput = {
    where: ItemCategoryScalarWhereInput
    data: XOR<ItemCategoryUpdateManyMutationInput, ItemCategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type ItemCategoryScalarWhereInput = {
    AND?: ItemCategoryScalarWhereInput | ItemCategoryScalarWhereInput[]
    OR?: ItemCategoryScalarWhereInput[]
    NOT?: ItemCategoryScalarWhereInput | ItemCategoryScalarWhereInput[]
    id?: IntFilter<"ItemCategory"> | number
    parentId?: IntNullableFilter<"ItemCategory"> | number | null
    name?: StringFilter<"ItemCategory"> | string
    createdBy?: IntNullableFilter<"ItemCategory"> | number | null
    updatedBy?: IntNullableFilter<"ItemCategory"> | number | null
    deletedBy?: IntNullableFilter<"ItemCategory"> | number | null
    createdAt?: DateTimeFilter<"ItemCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ItemCategory"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemCategory"> | Date | string | null
  }

  export type ItemUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutCategoryInput, ItemUncheckedUpdateWithoutCategoryInput>
    create: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutCategoryInput, ItemUncheckedUpdateWithoutCategoryInput>
  }

  export type ItemUpdateManyWithWhereWithoutCategoryInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ItemScalarWhereInput = {
    AND?: ItemScalarWhereInput | ItemScalarWhereInput[]
    OR?: ItemScalarWhereInput[]
    NOT?: ItemScalarWhereInput | ItemScalarWhereInput[]
    id?: BigIntFilter<"Item"> | bigint | number
    itemTypeId?: IntFilter<"Item"> | number
    itemCategoryId?: IntFilter<"Item"> | number
    name?: StringFilter<"Item"> | string
    slug?: StringFilter<"Item"> | string
    description?: StringNullableFilter<"Item"> | string | null
    shortDescription?: StringNullableFilter<"Item"> | string | null
    tags?: StringNullableFilter<"Item"> | string | null
    attributes?: JsonNullableFilter<"Item">
    metaTitle?: StringNullableFilter<"Item"> | string | null
    metaDescription?: StringNullableFilter<"Item"> | string | null
    status?: EnumItemStatusFilter<"Item"> | $Enums.ItemStatus
    isPinned?: BoolFilter<"Item"> | boolean
    isFavorite?: BoolFilter<"Item"> | boolean
    isDeleted?: BoolFilter<"Item"> | boolean
    createdBy?: IntNullableFilter<"Item"> | number | null
    updatedBy?: IntNullableFilter<"Item"> | number | null
    deletedBy?: IntNullableFilter<"Item"> | number | null
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Item"> | Date | string | null
  }

  export type ItemAttributeTemplateUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ItemAttributeTemplateWhereUniqueInput
    update: XOR<ItemAttributeTemplateUpdateWithoutCategoryInput, ItemAttributeTemplateUncheckedUpdateWithoutCategoryInput>
    create: XOR<ItemAttributeTemplateCreateWithoutCategoryInput, ItemAttributeTemplateUncheckedCreateWithoutCategoryInput>
  }

  export type ItemAttributeTemplateUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ItemAttributeTemplateWhereUniqueInput
    data: XOR<ItemAttributeTemplateUpdateWithoutCategoryInput, ItemAttributeTemplateUncheckedUpdateWithoutCategoryInput>
  }

  export type ItemAttributeTemplateUpdateManyWithWhereWithoutCategoryInput = {
    where: ItemAttributeTemplateScalarWhereInput
    data: XOR<ItemAttributeTemplateUpdateManyMutationInput, ItemAttributeTemplateUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ItemAttributeTemplateScalarWhereInput = {
    AND?: ItemAttributeTemplateScalarWhereInput | ItemAttributeTemplateScalarWhereInput[]
    OR?: ItemAttributeTemplateScalarWhereInput[]
    NOT?: ItemAttributeTemplateScalarWhereInput | ItemAttributeTemplateScalarWhereInput[]
    id?: IntFilter<"ItemAttributeTemplate"> | number
    itemCategoryId?: IntFilter<"ItemAttributeTemplate"> | number
    name?: StringFilter<"ItemAttributeTemplate"> | string
    type?: EnumAttributeTypeFilter<"ItemAttributeTemplate"> | $Enums.AttributeType
    createdBy?: IntNullableFilter<"ItemAttributeTemplate"> | number | null
    updatedBy?: IntNullableFilter<"ItemAttributeTemplate"> | number | null
    deletedBy?: IntNullableFilter<"ItemAttributeTemplate"> | number | null
    createdAt?: DateTimeFilter<"ItemAttributeTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ItemAttributeTemplate"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemAttributeTemplate"> | Date | string | null
  }

  export type ItemCreateWithoutImagesInput = {
    id?: bigint | number
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    tags?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    status?: $Enums.ItemStatus
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    itemType: ItemTypeCreateNestedOneWithoutItemsInput
    category: ItemCategoryCreateNestedOneWithoutItemsInput
    variants?: ItemVariantCreateNestedManyWithoutItemInput
    videos?: ItemVideoCreateNestedManyWithoutItemInput
    updateHistories?: ItemUpdateHistoryCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutImagesInput = {
    id?: bigint | number
    itemTypeId: number
    itemCategoryId: number
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    tags?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    status?: $Enums.ItemStatus
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    variants?: ItemVariantUncheckedCreateNestedManyWithoutItemInput
    videos?: ItemVideoUncheckedCreateNestedManyWithoutItemInput
    updateHistories?: ItemUpdateHistoryUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutImagesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutImagesInput, ItemUncheckedCreateWithoutImagesInput>
  }

  export type ItemUpsertWithoutImagesInput = {
    update: XOR<ItemUpdateWithoutImagesInput, ItemUncheckedUpdateWithoutImagesInput>
    create: XOR<ItemCreateWithoutImagesInput, ItemUncheckedCreateWithoutImagesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutImagesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutImagesInput, ItemUncheckedUpdateWithoutImagesInput>
  }

  export type ItemUpdateWithoutImagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumItemStatusFieldUpdateOperationsInput | $Enums.ItemStatus
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemType?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    category?: ItemCategoryUpdateOneRequiredWithoutItemsNestedInput
    variants?: ItemVariantUpdateManyWithoutItemNestedInput
    videos?: ItemVideoUpdateManyWithoutItemNestedInput
    updateHistories?: ItemUpdateHistoryUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutImagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    itemCategoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumItemStatusFieldUpdateOperationsInput | $Enums.ItemStatus
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variants?: ItemVariantUncheckedUpdateManyWithoutItemNestedInput
    videos?: ItemVideoUncheckedUpdateManyWithoutItemNestedInput
    updateHistories?: ItemUpdateHistoryUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemVariantCreateWithoutPricesInput = {
    id?: bigint | number
    code: string
    name?: string | null
    imageUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    quantity?: number
    options?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    item: ItemCreateNestedOneWithoutVariantsInput
  }

  export type ItemVariantUncheckedCreateWithoutPricesInput = {
    id?: bigint | number
    itemId: bigint | number
    code: string
    name?: string | null
    imageUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    quantity?: number
    options?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemVariantCreateOrConnectWithoutPricesInput = {
    where: ItemVariantWhereUniqueInput
    create: XOR<ItemVariantCreateWithoutPricesInput, ItemVariantUncheckedCreateWithoutPricesInput>
  }

  export type ItemVariantUpsertWithoutPricesInput = {
    update: XOR<ItemVariantUpdateWithoutPricesInput, ItemVariantUncheckedUpdateWithoutPricesInput>
    create: XOR<ItemVariantCreateWithoutPricesInput, ItemVariantUncheckedCreateWithoutPricesInput>
    where?: ItemVariantWhereInput
  }

  export type ItemVariantUpdateToOneWithWhereWithoutPricesInput = {
    where?: ItemVariantWhereInput
    data: XOR<ItemVariantUpdateWithoutPricesInput, ItemVariantUncheckedUpdateWithoutPricesInput>
  }

  export type ItemVariantUpdateWithoutPricesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item?: ItemUpdateOneRequiredWithoutVariantsNestedInput
  }

  export type ItemVariantUncheckedUpdateWithoutPricesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemCreateWithoutItemTypeInput = {
    id?: bigint | number
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    tags?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    status?: $Enums.ItemStatus
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    category: ItemCategoryCreateNestedOneWithoutItemsInput
    variants?: ItemVariantCreateNestedManyWithoutItemInput
    images?: ItemImageCreateNestedManyWithoutItemInput
    videos?: ItemVideoCreateNestedManyWithoutItemInput
    updateHistories?: ItemUpdateHistoryCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutItemTypeInput = {
    id?: bigint | number
    itemCategoryId: number
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    tags?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    status?: $Enums.ItemStatus
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    variants?: ItemVariantUncheckedCreateNestedManyWithoutItemInput
    images?: ItemImageUncheckedCreateNestedManyWithoutItemInput
    videos?: ItemVideoUncheckedCreateNestedManyWithoutItemInput
    updateHistories?: ItemUpdateHistoryUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutItemTypeInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutItemTypeInput, ItemUncheckedCreateWithoutItemTypeInput>
  }

  export type ItemCreateManyItemTypeInputEnvelope = {
    data: ItemCreateManyItemTypeInput | ItemCreateManyItemTypeInput[]
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithWhereUniqueWithoutItemTypeInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutItemTypeInput, ItemUncheckedUpdateWithoutItemTypeInput>
    create: XOR<ItemCreateWithoutItemTypeInput, ItemUncheckedCreateWithoutItemTypeInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutItemTypeInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutItemTypeInput, ItemUncheckedUpdateWithoutItemTypeInput>
  }

  export type ItemUpdateManyWithWhereWithoutItemTypeInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItemTypeInput>
  }

  export type ItemCreateWithoutUpdateHistoriesInput = {
    id?: bigint | number
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    tags?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    status?: $Enums.ItemStatus
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    itemType: ItemTypeCreateNestedOneWithoutItemsInput
    category: ItemCategoryCreateNestedOneWithoutItemsInput
    variants?: ItemVariantCreateNestedManyWithoutItemInput
    images?: ItemImageCreateNestedManyWithoutItemInput
    videos?: ItemVideoCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutUpdateHistoriesInput = {
    id?: bigint | number
    itemTypeId: number
    itemCategoryId: number
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    tags?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    status?: $Enums.ItemStatus
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    variants?: ItemVariantUncheckedCreateNestedManyWithoutItemInput
    images?: ItemImageUncheckedCreateNestedManyWithoutItemInput
    videos?: ItemVideoUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutUpdateHistoriesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutUpdateHistoriesInput, ItemUncheckedCreateWithoutUpdateHistoriesInput>
  }

  export type ItemUpsertWithoutUpdateHistoriesInput = {
    update: XOR<ItemUpdateWithoutUpdateHistoriesInput, ItemUncheckedUpdateWithoutUpdateHistoriesInput>
    create: XOR<ItemCreateWithoutUpdateHistoriesInput, ItemUncheckedCreateWithoutUpdateHistoriesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutUpdateHistoriesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutUpdateHistoriesInput, ItemUncheckedUpdateWithoutUpdateHistoriesInput>
  }

  export type ItemUpdateWithoutUpdateHistoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumItemStatusFieldUpdateOperationsInput | $Enums.ItemStatus
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemType?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    category?: ItemCategoryUpdateOneRequiredWithoutItemsNestedInput
    variants?: ItemVariantUpdateManyWithoutItemNestedInput
    images?: ItemImageUpdateManyWithoutItemNestedInput
    videos?: ItemVideoUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutUpdateHistoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    itemCategoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumItemStatusFieldUpdateOperationsInput | $Enums.ItemStatus
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variants?: ItemVariantUncheckedUpdateManyWithoutItemNestedInput
    images?: ItemImageUncheckedUpdateManyWithoutItemNestedInput
    videos?: ItemVideoUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateWithoutVariantsInput = {
    id?: bigint | number
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    tags?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    status?: $Enums.ItemStatus
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    itemType: ItemTypeCreateNestedOneWithoutItemsInput
    category: ItemCategoryCreateNestedOneWithoutItemsInput
    images?: ItemImageCreateNestedManyWithoutItemInput
    videos?: ItemVideoCreateNestedManyWithoutItemInput
    updateHistories?: ItemUpdateHistoryCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutVariantsInput = {
    id?: bigint | number
    itemTypeId: number
    itemCategoryId: number
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    tags?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    status?: $Enums.ItemStatus
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    images?: ItemImageUncheckedCreateNestedManyWithoutItemInput
    videos?: ItemVideoUncheckedCreateNestedManyWithoutItemInput
    updateHistories?: ItemUpdateHistoryUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutVariantsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutVariantsInput, ItemUncheckedCreateWithoutVariantsInput>
  }

  export type ItemPriceCreateWithoutVariantInput = {
    id?: bigint | number
    price: Decimal | DecimalJsLike | number | string
    priceType?: $Enums.PriceType
    startDate?: Date | string | null
    endDate?: Date | string | null
    dayOfWeek?: number | null
    startTime?: string | null
    endTime?: string | null
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemPriceUncheckedCreateWithoutVariantInput = {
    id?: bigint | number
    price: Decimal | DecimalJsLike | number | string
    priceType?: $Enums.PriceType
    startDate?: Date | string | null
    endDate?: Date | string | null
    dayOfWeek?: number | null
    startTime?: string | null
    endTime?: string | null
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemPriceCreateOrConnectWithoutVariantInput = {
    where: ItemPriceWhereUniqueInput
    create: XOR<ItemPriceCreateWithoutVariantInput, ItemPriceUncheckedCreateWithoutVariantInput>
  }

  export type ItemPriceCreateManyVariantInputEnvelope = {
    data: ItemPriceCreateManyVariantInput | ItemPriceCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithoutVariantsInput = {
    update: XOR<ItemUpdateWithoutVariantsInput, ItemUncheckedUpdateWithoutVariantsInput>
    create: XOR<ItemCreateWithoutVariantsInput, ItemUncheckedCreateWithoutVariantsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutVariantsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutVariantsInput, ItemUncheckedUpdateWithoutVariantsInput>
  }

  export type ItemUpdateWithoutVariantsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumItemStatusFieldUpdateOperationsInput | $Enums.ItemStatus
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemType?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    category?: ItemCategoryUpdateOneRequiredWithoutItemsNestedInput
    images?: ItemImageUpdateManyWithoutItemNestedInput
    videos?: ItemVideoUpdateManyWithoutItemNestedInput
    updateHistories?: ItemUpdateHistoryUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutVariantsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    itemCategoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumItemStatusFieldUpdateOperationsInput | $Enums.ItemStatus
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: ItemImageUncheckedUpdateManyWithoutItemNestedInput
    videos?: ItemVideoUncheckedUpdateManyWithoutItemNestedInput
    updateHistories?: ItemUpdateHistoryUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemPriceUpsertWithWhereUniqueWithoutVariantInput = {
    where: ItemPriceWhereUniqueInput
    update: XOR<ItemPriceUpdateWithoutVariantInput, ItemPriceUncheckedUpdateWithoutVariantInput>
    create: XOR<ItemPriceCreateWithoutVariantInput, ItemPriceUncheckedCreateWithoutVariantInput>
  }

  export type ItemPriceUpdateWithWhereUniqueWithoutVariantInput = {
    where: ItemPriceWhereUniqueInput
    data: XOR<ItemPriceUpdateWithoutVariantInput, ItemPriceUncheckedUpdateWithoutVariantInput>
  }

  export type ItemPriceUpdateManyWithWhereWithoutVariantInput = {
    where: ItemPriceScalarWhereInput
    data: XOR<ItemPriceUpdateManyMutationInput, ItemPriceUncheckedUpdateManyWithoutVariantInput>
  }

  export type ItemPriceScalarWhereInput = {
    AND?: ItemPriceScalarWhereInput | ItemPriceScalarWhereInput[]
    OR?: ItemPriceScalarWhereInput[]
    NOT?: ItemPriceScalarWhereInput | ItemPriceScalarWhereInput[]
    id?: BigIntFilter<"ItemPrice"> | bigint | number
    itemVariantId?: BigIntFilter<"ItemPrice"> | bigint | number
    price?: DecimalFilter<"ItemPrice"> | Decimal | DecimalJsLike | number | string
    priceType?: EnumPriceTypeFilter<"ItemPrice"> | $Enums.PriceType
    startDate?: DateTimeNullableFilter<"ItemPrice"> | Date | string | null
    endDate?: DateTimeNullableFilter<"ItemPrice"> | Date | string | null
    dayOfWeek?: IntNullableFilter<"ItemPrice"> | number | null
    startTime?: StringNullableFilter<"ItemPrice"> | string | null
    endTime?: StringNullableFilter<"ItemPrice"> | string | null
    createdBy?: IntNullableFilter<"ItemPrice"> | number | null
    updatedBy?: IntNullableFilter<"ItemPrice"> | number | null
    deletedBy?: IntNullableFilter<"ItemPrice"> | number | null
    createdAt?: DateTimeFilter<"ItemPrice"> | Date | string
    updatedAt?: DateTimeFilter<"ItemPrice"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ItemPrice"> | Date | string | null
  }

  export type ItemCreateWithoutVideosInput = {
    id?: bigint | number
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    tags?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    status?: $Enums.ItemStatus
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    itemType: ItemTypeCreateNestedOneWithoutItemsInput
    category: ItemCategoryCreateNestedOneWithoutItemsInput
    variants?: ItemVariantCreateNestedManyWithoutItemInput
    images?: ItemImageCreateNestedManyWithoutItemInput
    updateHistories?: ItemUpdateHistoryCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutVideosInput = {
    id?: bigint | number
    itemTypeId: number
    itemCategoryId: number
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    tags?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    status?: $Enums.ItemStatus
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    variants?: ItemVariantUncheckedCreateNestedManyWithoutItemInput
    images?: ItemImageUncheckedCreateNestedManyWithoutItemInput
    updateHistories?: ItemUpdateHistoryUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutVideosInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutVideosInput, ItemUncheckedCreateWithoutVideosInput>
  }

  export type ItemUpsertWithoutVideosInput = {
    update: XOR<ItemUpdateWithoutVideosInput, ItemUncheckedUpdateWithoutVideosInput>
    create: XOR<ItemCreateWithoutVideosInput, ItemUncheckedCreateWithoutVideosInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutVideosInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutVideosInput, ItemUncheckedUpdateWithoutVideosInput>
  }

  export type ItemUpdateWithoutVideosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumItemStatusFieldUpdateOperationsInput | $Enums.ItemStatus
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemType?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    category?: ItemCategoryUpdateOneRequiredWithoutItemsNestedInput
    variants?: ItemVariantUpdateManyWithoutItemNestedInput
    images?: ItemImageUpdateManyWithoutItemNestedInput
    updateHistories?: ItemUpdateHistoryUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutVideosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    itemCategoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumItemStatusFieldUpdateOperationsInput | $Enums.ItemStatus
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variants?: ItemVariantUncheckedUpdateManyWithoutItemNestedInput
    images?: ItemImageUncheckedUpdateManyWithoutItemNestedInput
    updateHistories?: ItemUpdateHistoryUncheckedUpdateManyWithoutItemNestedInput
  }

  export type UserAdminCreateWithoutUserInput = {
    fullName: string
    employeeId?: string | null
    department?: string | null
    phoneNumber?: string | null
    accessLevel?: number
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
  }

  export type UserAdminUncheckedCreateWithoutUserInput = {
    id?: number
    fullName: string
    employeeId?: string | null
    department?: string | null
    phoneNumber?: string | null
    accessLevel?: number
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
  }

  export type UserAdminCreateOrConnectWithoutUserInput = {
    where: UserAdminWhereUniqueInput
    create: XOR<UserAdminCreateWithoutUserInput, UserAdminUncheckedCreateWithoutUserInput>
  }

  export type UserCustomerCreateWithoutUserInput = {
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    loyaltyPoint?: number
    referralCode?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    addresses?: UserCustomerAddressCreateNestedManyWithoutCustomerInput
    member?: UserMemberCreateNestedOneWithoutCustomerInput
    responses?: CustomerResponseCreateNestedManyWithoutCustomerInput
  }

  export type UserCustomerUncheckedCreateWithoutUserInput = {
    id?: number
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    loyaltyPoint?: number
    referralCode?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    addresses?: UserCustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    member?: UserMemberUncheckedCreateNestedOneWithoutCustomerInput
    responses?: CustomerResponseUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type UserCustomerCreateOrConnectWithoutUserInput = {
    where: UserCustomerWhereUniqueInput
    create: XOR<UserCustomerCreateWithoutUserInput, UserCustomerUncheckedCreateWithoutUserInput>
  }

  export type UserAdminUpsertWithoutUserInput = {
    update: XOR<UserAdminUpdateWithoutUserInput, UserAdminUncheckedUpdateWithoutUserInput>
    create: XOR<UserAdminCreateWithoutUserInput, UserAdminUncheckedCreateWithoutUserInput>
    where?: UserAdminWhereInput
  }

  export type UserAdminUpdateToOneWithWhereWithoutUserInput = {
    where?: UserAdminWhereInput
    data: XOR<UserAdminUpdateWithoutUserInput, UserAdminUncheckedUpdateWithoutUserInput>
  }

  export type UserAdminUpdateWithoutUserInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: IntFieldUpdateOperationsInput | number
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAdminUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: IntFieldUpdateOperationsInput | number
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCustomerUpsertWithoutUserInput = {
    update: XOR<UserCustomerUpdateWithoutUserInput, UserCustomerUncheckedUpdateWithoutUserInput>
    create: XOR<UserCustomerCreateWithoutUserInput, UserCustomerUncheckedCreateWithoutUserInput>
    where?: UserCustomerWhereInput
  }

  export type UserCustomerUpdateToOneWithWhereWithoutUserInput = {
    where?: UserCustomerWhereInput
    data: XOR<UserCustomerUpdateWithoutUserInput, UserCustomerUncheckedUpdateWithoutUserInput>
  }

  export type UserCustomerUpdateWithoutUserInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoint?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addresses?: UserCustomerAddressUpdateManyWithoutCustomerNestedInput
    member?: UserMemberUpdateOneWithoutCustomerNestedInput
    responses?: CustomerResponseUpdateManyWithoutCustomerNestedInput
  }

  export type UserCustomerUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoint?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addresses?: UserCustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    member?: UserMemberUncheckedUpdateOneWithoutCustomerNestedInput
    responses?: CustomerResponseUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserCreateWithoutAdminProfileInput = {
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerProfile?: UserCustomerCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminProfileInput = {
    id?: number
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerProfile?: UserCustomerUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
  }

  export type UserUpsertWithoutAdminProfileInput = {
    update: XOR<UserUpdateWithoutAdminProfileInput, UserUncheckedUpdateWithoutAdminProfileInput>
    create: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminProfileInput, UserUncheckedUpdateWithoutAdminProfileInput>
  }

  export type UserUpdateWithoutAdminProfileInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerProfile?: UserCustomerUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerProfile?: UserCustomerUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutCustomerProfileInput = {
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    adminProfile?: UserAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCustomerProfileInput = {
    id?: number
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    adminProfile?: UserAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCustomerProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomerProfileInput, UserUncheckedCreateWithoutCustomerProfileInput>
  }

  export type UserCustomerAddressCreateWithoutCustomerInput = {
    label: string
    recipientName: string
    recipientPhone: string
    fullAddress: string
    note?: string | null
    isPrimary?: boolean
  }

  export type UserCustomerAddressUncheckedCreateWithoutCustomerInput = {
    id?: number
    label: string
    recipientName: string
    recipientPhone: string
    fullAddress: string
    note?: string | null
    isPrimary?: boolean
  }

  export type UserCustomerAddressCreateOrConnectWithoutCustomerInput = {
    where: UserCustomerAddressWhereUniqueInput
    create: XOR<UserCustomerAddressCreateWithoutCustomerInput, UserCustomerAddressUncheckedCreateWithoutCustomerInput>
  }

  export type UserCustomerAddressCreateManyCustomerInputEnvelope = {
    data: UserCustomerAddressCreateManyCustomerInput | UserCustomerAddressCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type UserMemberCreateWithoutCustomerInput = {
    tier?: $Enums.MemberTier
    memberNumber: string
    joinedAt?: Date | string
    expiredAt?: Date | string | null
  }

  export type UserMemberUncheckedCreateWithoutCustomerInput = {
    id?: number
    tier?: $Enums.MemberTier
    memberNumber: string
    joinedAt?: Date | string
    expiredAt?: Date | string | null
  }

  export type UserMemberCreateOrConnectWithoutCustomerInput = {
    where: UserMemberWhereUniqueInput
    create: XOR<UserMemberCreateWithoutCustomerInput, UserMemberUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerResponseCreateWithoutCustomerInput = {
    answer: string
    createdAt?: Date | string
    field: CustomerFormFieldCreateNestedOneWithoutResponsesInput
  }

  export type CustomerResponseUncheckedCreateWithoutCustomerInput = {
    id?: number
    fieldId: number
    answer: string
    createdAt?: Date | string
  }

  export type CustomerResponseCreateOrConnectWithoutCustomerInput = {
    where: CustomerResponseWhereUniqueInput
    create: XOR<CustomerResponseCreateWithoutCustomerInput, CustomerResponseUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerResponseCreateManyCustomerInputEnvelope = {
    data: CustomerResponseCreateManyCustomerInput | CustomerResponseCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCustomerProfileInput = {
    update: XOR<UserUpdateWithoutCustomerProfileInput, UserUncheckedUpdateWithoutCustomerProfileInput>
    create: XOR<UserCreateWithoutCustomerProfileInput, UserUncheckedCreateWithoutCustomerProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCustomerProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCustomerProfileInput, UserUncheckedUpdateWithoutCustomerProfileInput>
  }

  export type UserUpdateWithoutCustomerProfileInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminProfile?: UserAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomerProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminProfile?: UserAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCustomerAddressUpsertWithWhereUniqueWithoutCustomerInput = {
    where: UserCustomerAddressWhereUniqueInput
    update: XOR<UserCustomerAddressUpdateWithoutCustomerInput, UserCustomerAddressUncheckedUpdateWithoutCustomerInput>
    create: XOR<UserCustomerAddressCreateWithoutCustomerInput, UserCustomerAddressUncheckedCreateWithoutCustomerInput>
  }

  export type UserCustomerAddressUpdateWithWhereUniqueWithoutCustomerInput = {
    where: UserCustomerAddressWhereUniqueInput
    data: XOR<UserCustomerAddressUpdateWithoutCustomerInput, UserCustomerAddressUncheckedUpdateWithoutCustomerInput>
  }

  export type UserCustomerAddressUpdateManyWithWhereWithoutCustomerInput = {
    where: UserCustomerAddressScalarWhereInput
    data: XOR<UserCustomerAddressUpdateManyMutationInput, UserCustomerAddressUncheckedUpdateManyWithoutCustomerInput>
  }

  export type UserCustomerAddressScalarWhereInput = {
    AND?: UserCustomerAddressScalarWhereInput | UserCustomerAddressScalarWhereInput[]
    OR?: UserCustomerAddressScalarWhereInput[]
    NOT?: UserCustomerAddressScalarWhereInput | UserCustomerAddressScalarWhereInput[]
    id?: IntFilter<"UserCustomerAddress"> | number
    userCustomerId?: IntFilter<"UserCustomerAddress"> | number
    label?: StringFilter<"UserCustomerAddress"> | string
    recipientName?: StringFilter<"UserCustomerAddress"> | string
    recipientPhone?: StringFilter<"UserCustomerAddress"> | string
    fullAddress?: StringFilter<"UserCustomerAddress"> | string
    note?: StringNullableFilter<"UserCustomerAddress"> | string | null
    isPrimary?: BoolFilter<"UserCustomerAddress"> | boolean
  }

  export type UserMemberUpsertWithoutCustomerInput = {
    update: XOR<UserMemberUpdateWithoutCustomerInput, UserMemberUncheckedUpdateWithoutCustomerInput>
    create: XOR<UserMemberCreateWithoutCustomerInput, UserMemberUncheckedCreateWithoutCustomerInput>
    where?: UserMemberWhereInput
  }

  export type UserMemberUpdateToOneWithWhereWithoutCustomerInput = {
    where?: UserMemberWhereInput
    data: XOR<UserMemberUpdateWithoutCustomerInput, UserMemberUncheckedUpdateWithoutCustomerInput>
  }

  export type UserMemberUpdateWithoutCustomerInput = {
    tier?: EnumMemberTierFieldUpdateOperationsInput | $Enums.MemberTier
    memberNumber?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserMemberUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    tier?: EnumMemberTierFieldUpdateOperationsInput | $Enums.MemberTier
    memberNumber?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerResponseUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerResponseWhereUniqueInput
    update: XOR<CustomerResponseUpdateWithoutCustomerInput, CustomerResponseUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerResponseCreateWithoutCustomerInput, CustomerResponseUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerResponseUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerResponseWhereUniqueInput
    data: XOR<CustomerResponseUpdateWithoutCustomerInput, CustomerResponseUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerResponseUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerResponseScalarWhereInput
    data: XOR<CustomerResponseUpdateManyMutationInput, CustomerResponseUncheckedUpdateManyWithoutCustomerInput>
  }

  export type UserCustomerCreateWithoutAddressesInput = {
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    loyaltyPoint?: number
    referralCode?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    user: UserCreateNestedOneWithoutCustomerProfileInput
    member?: UserMemberCreateNestedOneWithoutCustomerInput
    responses?: CustomerResponseCreateNestedManyWithoutCustomerInput
  }

  export type UserCustomerUncheckedCreateWithoutAddressesInput = {
    id?: number
    userId: number
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    loyaltyPoint?: number
    referralCode?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    member?: UserMemberUncheckedCreateNestedOneWithoutCustomerInput
    responses?: CustomerResponseUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type UserCustomerCreateOrConnectWithoutAddressesInput = {
    where: UserCustomerWhereUniqueInput
    create: XOR<UserCustomerCreateWithoutAddressesInput, UserCustomerUncheckedCreateWithoutAddressesInput>
  }

  export type UserCustomerUpsertWithoutAddressesInput = {
    update: XOR<UserCustomerUpdateWithoutAddressesInput, UserCustomerUncheckedUpdateWithoutAddressesInput>
    create: XOR<UserCustomerCreateWithoutAddressesInput, UserCustomerUncheckedCreateWithoutAddressesInput>
    where?: UserCustomerWhereInput
  }

  export type UserCustomerUpdateToOneWithWhereWithoutAddressesInput = {
    where?: UserCustomerWhereInput
    data: XOR<UserCustomerUpdateWithoutAddressesInput, UserCustomerUncheckedUpdateWithoutAddressesInput>
  }

  export type UserCustomerUpdateWithoutAddressesInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoint?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCustomerProfileNestedInput
    member?: UserMemberUpdateOneWithoutCustomerNestedInput
    responses?: CustomerResponseUpdateManyWithoutCustomerNestedInput
  }

  export type UserCustomerUncheckedUpdateWithoutAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoint?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member?: UserMemberUncheckedUpdateOneWithoutCustomerNestedInput
    responses?: CustomerResponseUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserCustomerCreateWithoutMemberInput = {
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    loyaltyPoint?: number
    referralCode?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    user: UserCreateNestedOneWithoutCustomerProfileInput
    addresses?: UserCustomerAddressCreateNestedManyWithoutCustomerInput
    responses?: CustomerResponseCreateNestedManyWithoutCustomerInput
  }

  export type UserCustomerUncheckedCreateWithoutMemberInput = {
    id?: number
    userId: number
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    loyaltyPoint?: number
    referralCode?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    addresses?: UserCustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    responses?: CustomerResponseUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type UserCustomerCreateOrConnectWithoutMemberInput = {
    where: UserCustomerWhereUniqueInput
    create: XOR<UserCustomerCreateWithoutMemberInput, UserCustomerUncheckedCreateWithoutMemberInput>
  }

  export type UserCustomerUpsertWithoutMemberInput = {
    update: XOR<UserCustomerUpdateWithoutMemberInput, UserCustomerUncheckedUpdateWithoutMemberInput>
    create: XOR<UserCustomerCreateWithoutMemberInput, UserCustomerUncheckedCreateWithoutMemberInput>
    where?: UserCustomerWhereInput
  }

  export type UserCustomerUpdateToOneWithWhereWithoutMemberInput = {
    where?: UserCustomerWhereInput
    data: XOR<UserCustomerUpdateWithoutMemberInput, UserCustomerUncheckedUpdateWithoutMemberInput>
  }

  export type UserCustomerUpdateWithoutMemberInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoint?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCustomerProfileNestedInput
    addresses?: UserCustomerAddressUpdateManyWithoutCustomerNestedInput
    responses?: CustomerResponseUpdateManyWithoutCustomerNestedInput
  }

  export type UserCustomerUncheckedUpdateWithoutMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoint?: IntFieldUpdateOperationsInput | number
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addresses?: UserCustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    responses?: CustomerResponseUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerResponseCreateManyFieldInput = {
    id?: number
    userCustomerId: number
    answer: string
    createdAt?: Date | string
  }

  export type CustomerResponseUpdateWithoutFieldInput = {
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserCustomerUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type CustomerResponseUncheckedUpdateWithoutFieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCustomerId?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerResponseUncheckedUpdateManyWithoutFieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCustomerId?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemVariantCreateManyItemInput = {
    id?: bigint | number
    code: string
    name?: string | null
    imageUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    quantity?: number
    options?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemImageCreateManyItemInput = {
    id?: bigint | number
    url: string
    isPrimary?: boolean
    sortOrder?: number
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemVideoCreateManyItemInput = {
    id?: bigint | number
    url: string
    provider?: string | null
    isPrimary?: boolean
    sortOrder?: number
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemUpdateHistoryCreateManyItemInput = {
    id?: bigint | number
    itemName: string
    userId: number
    userName: string
    columnName: string
    createdAt?: Date | string
  }

  export type ItemVariantUpdateWithoutItemInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prices?: ItemPriceUpdateManyWithoutVariantNestedInput
  }

  export type ItemVariantUncheckedUpdateWithoutItemInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prices?: ItemPriceUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type ItemVariantUncheckedUpdateManyWithoutItemInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemImageUpdateWithoutItemInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemImageUncheckedUpdateWithoutItemInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemImageUncheckedUpdateManyWithoutItemInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemVideoUpdateWithoutItemInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemVideoUncheckedUpdateWithoutItemInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemVideoUncheckedUpdateManyWithoutItemInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemUpdateHistoryUpdateWithoutItemInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemName?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUpdateHistoryUncheckedUpdateWithoutItemInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemName?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUpdateHistoryUncheckedUpdateManyWithoutItemInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemName?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCategoryCreateManyParentInput = {
    id?: number
    name: string
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemCreateManyCategoryInput = {
    id?: bigint | number
    itemTypeId: number
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    tags?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    status?: $Enums.ItemStatus
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemAttributeTemplateCreateManyCategoryInput = {
    id?: number
    name: string
    type?: $Enums.AttributeType
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemCategoryUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ItemCategoryUpdateManyWithoutParentNestedInput
    items?: ItemUpdateManyWithoutCategoryNestedInput
    attributeTemplates?: ItemAttributeTemplateUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ItemCategoryUncheckedUpdateManyWithoutParentNestedInput
    items?: ItemUncheckedUpdateManyWithoutCategoryNestedInput
    attributeTemplates?: ItemAttributeTemplateUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemUpdateWithoutCategoryInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumItemStatusFieldUpdateOperationsInput | $Enums.ItemStatus
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemType?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    variants?: ItemVariantUpdateManyWithoutItemNestedInput
    images?: ItemImageUpdateManyWithoutItemNestedInput
    videos?: ItemVideoUpdateManyWithoutItemNestedInput
    updateHistories?: ItemUpdateHistoryUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutCategoryInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumItemStatusFieldUpdateOperationsInput | $Enums.ItemStatus
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variants?: ItemVariantUncheckedUpdateManyWithoutItemNestedInput
    images?: ItemImageUncheckedUpdateManyWithoutItemNestedInput
    videos?: ItemVideoUncheckedUpdateManyWithoutItemNestedInput
    updateHistories?: ItemUpdateHistoryUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutCategoryInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumItemStatusFieldUpdateOperationsInput | $Enums.ItemStatus
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemAttributeTemplateUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAttributeTypeFieldUpdateOperationsInput | $Enums.AttributeType
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemAttributeTemplateUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAttributeTypeFieldUpdateOperationsInput | $Enums.AttributeType
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemAttributeTemplateUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAttributeTypeFieldUpdateOperationsInput | $Enums.AttributeType
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemCreateManyItemTypeInput = {
    id?: bigint | number
    itemCategoryId: number
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    tags?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    status?: $Enums.ItemStatus
    isPinned?: boolean
    isFavorite?: boolean
    isDeleted?: boolean
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemUpdateWithoutItemTypeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumItemStatusFieldUpdateOperationsInput | $Enums.ItemStatus
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: ItemCategoryUpdateOneRequiredWithoutItemsNestedInput
    variants?: ItemVariantUpdateManyWithoutItemNestedInput
    images?: ItemImageUpdateManyWithoutItemNestedInput
    videos?: ItemVideoUpdateManyWithoutItemNestedInput
    updateHistories?: ItemUpdateHistoryUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutItemTypeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCategoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumItemStatusFieldUpdateOperationsInput | $Enums.ItemStatus
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variants?: ItemVariantUncheckedUpdateManyWithoutItemNestedInput
    images?: ItemImageUncheckedUpdateManyWithoutItemNestedInput
    videos?: ItemVideoUncheckedUpdateManyWithoutItemNestedInput
    updateHistories?: ItemUpdateHistoryUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutItemTypeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCategoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumItemStatusFieldUpdateOperationsInput | $Enums.ItemStatus
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemPriceCreateManyVariantInput = {
    id?: bigint | number
    price: Decimal | DecimalJsLike | number | string
    priceType?: $Enums.PriceType
    startDate?: Date | string | null
    endDate?: Date | string | null
    dayOfWeek?: number | null
    startTime?: string | null
    endTime?: string | null
    createdBy?: number | null
    updatedBy?: number | null
    deletedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ItemPriceUpdateWithoutVariantInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceType?: EnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemPriceUncheckedUpdateWithoutVariantInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceType?: EnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemPriceUncheckedUpdateManyWithoutVariantInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceType?: EnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCustomerAddressCreateManyCustomerInput = {
    id?: number
    label: string
    recipientName: string
    recipientPhone: string
    fullAddress: string
    note?: string | null
    isPrimary?: boolean
  }

  export type CustomerResponseCreateManyCustomerInput = {
    id?: number
    fieldId: number
    answer: string
    createdAt?: Date | string
  }

  export type UserCustomerAddressUpdateWithoutCustomerInput = {
    label?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientPhone?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCustomerAddressUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientPhone?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCustomerAddressUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientPhone?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomerResponseUpdateWithoutCustomerInput = {
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: CustomerFormFieldUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type CustomerResponseUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    fieldId?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerResponseUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    fieldId?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}